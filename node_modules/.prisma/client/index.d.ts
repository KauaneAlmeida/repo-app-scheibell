
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model PasswordReset
 * 
 */
export type PasswordReset = $Result.DefaultSelection<Prisma.$PasswordResetPayload>
/**
 * Model Clinic
 * 
 */
export type Clinic = $Result.DefaultSelection<Prisma.$ClinicPayload>
/**
 * Model Patient
 * 
 */
export type Patient = $Result.DefaultSelection<Prisma.$PatientPayload>
/**
 * Model Appointment
 * 
 */
export type Appointment = $Result.DefaultSelection<Prisma.$AppointmentPayload>
/**
 * Model MedicationLog
 * 
 */
export type MedicationLog = $Result.DefaultSelection<Prisma.$MedicationLogPayload>
/**
 * Model Exam
 * 
 */
export type Exam = $Result.DefaultSelection<Prisma.$ExamPayload>
/**
 * Model SystemContentTemplate
 * 
 */
export type SystemContentTemplate = $Result.DefaultSelection<Prisma.$SystemContentTemplatePayload>
/**
 * Model ClinicContent
 * 
 */
export type ClinicContent = $Result.DefaultSelection<Prisma.$ClinicContentPayload>
/**
 * Model PatientContentAdjustment
 * 
 */
export type PatientContentAdjustment = $Result.DefaultSelection<Prisma.$PatientContentAdjustmentPayload>
/**
 * Model TrainingProtocol
 * Protocolo de treino padrão (configurado pela clínica ou sistema)
 */
export type TrainingProtocol = $Result.DefaultSelection<Prisma.$TrainingProtocolPayload>
/**
 * Model TrainingWeek
 * Semana do protocolo de treino
 */
export type TrainingWeek = $Result.DefaultSelection<Prisma.$TrainingWeekPayload>
/**
 * Model TrainingSession
 * Sessão de treino (ex: 3 sessões por semana)
 */
export type TrainingSession = $Result.DefaultSelection<Prisma.$TrainingSessionPayload>
/**
 * Model PatientTrainingProgress
 * Progresso do paciente na semana
 */
export type PatientTrainingProgress = $Result.DefaultSelection<Prisma.$PatientTrainingProgressPayload>
/**
 * Model PatientSessionCompletion
 * Registro de conclusão de sessão de treino
 */
export type PatientSessionCompletion = $Result.DefaultSelection<Prisma.$PatientSessionCompletionPayload>
/**
 * Model ChatConversation
 * 
 */
export type ChatConversation = $Result.DefaultSelection<Prisma.$ChatConversationPayload>
/**
 * Model ChatMessage
 * 
 */
export type ChatMessage = $Result.DefaultSelection<Prisma.$ChatMessagePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  PATIENT: 'PATIENT',
  CLINIC_ADMIN: 'CLINIC_ADMIN',
  CLINIC_STAFF: 'CLINIC_STAFF',
  THIRD_PARTY: 'THIRD_PARTY'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const AppointmentType: {
  RETURN_VISIT: 'RETURN_VISIT',
  EVALUATION: 'EVALUATION',
  PHYSIOTHERAPY: 'PHYSIOTHERAPY',
  EXAM: 'EXAM',
  OTHER: 'OTHER'
};

export type AppointmentType = (typeof AppointmentType)[keyof typeof AppointmentType]


export const AppointmentStatus: {
  PENDING: 'PENDING',
  CONFIRMED: 'CONFIRMED',
  CANCELLED: 'CANCELLED',
  COMPLETED: 'COMPLETED'
};

export type AppointmentStatus = (typeof AppointmentStatus)[keyof typeof AppointmentStatus]


export const ExamStatus: {
  PENDING: 'PENDING',
  AVAILABLE: 'AVAILABLE',
  VIEWED: 'VIEWED'
};

export type ExamStatus = (typeof ExamStatus)[keyof typeof ExamStatus]


export const ContentType: {
  SYMPTOMS: 'SYMPTOMS',
  DIET: 'DIET',
  ACTIVITIES: 'ACTIVITIES',
  CARE: 'CARE',
  TRAINING: 'TRAINING',
  EXAMS: 'EXAMS',
  DOCUMENTS: 'DOCUMENTS',
  MEDICATIONS: 'MEDICATIONS',
  DIARY: 'DIARY'
};

export type ContentType = (typeof ContentType)[keyof typeof ContentType]


export const ContentCategory: {
  NORMAL: 'NORMAL',
  WARNING: 'WARNING',
  EMERGENCY: 'EMERGENCY',
  ALLOWED: 'ALLOWED',
  RESTRICTED: 'RESTRICTED',
  PROHIBITED: 'PROHIBITED',
  INFO: 'INFO'
};

export type ContentCategory = (typeof ContentCategory)[keyof typeof ContentCategory]


export const AdjustmentType: {
  ADD: 'ADD',
  DISABLE: 'DISABLE',
  MODIFY: 'MODIFY'
};

export type AdjustmentType = (typeof AdjustmentType)[keyof typeof AdjustmentType]


export const TrainingWeekStatus: {
  COMPLETED: 'COMPLETED',
  CURRENT: 'CURRENT',
  FUTURE: 'FUTURE'
};

export type TrainingWeekStatus = (typeof TrainingWeekStatus)[keyof typeof TrainingWeekStatus]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type AppointmentType = $Enums.AppointmentType

export const AppointmentType: typeof $Enums.AppointmentType

export type AppointmentStatus = $Enums.AppointmentStatus

export const AppointmentStatus: typeof $Enums.AppointmentStatus

export type ExamStatus = $Enums.ExamStatus

export const ExamStatus: typeof $Enums.ExamStatus

export type ContentType = $Enums.ContentType

export const ContentType: typeof $Enums.ContentType

export type ContentCategory = $Enums.ContentCategory

export const ContentCategory: typeof $Enums.ContentCategory

export type AdjustmentType = $Enums.AdjustmentType

export const AdjustmentType: typeof $Enums.AdjustmentType

export type TrainingWeekStatus = $Enums.TrainingWeekStatus

export const TrainingWeekStatus: typeof $Enums.TrainingWeekStatus

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.passwordReset`: Exposes CRUD operations for the **PasswordReset** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordResets
    * const passwordResets = await prisma.passwordReset.findMany()
    * ```
    */
  get passwordReset(): Prisma.PasswordResetDelegate<ExtArgs>;

  /**
   * `prisma.clinic`: Exposes CRUD operations for the **Clinic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Clinics
    * const clinics = await prisma.clinic.findMany()
    * ```
    */
  get clinic(): Prisma.ClinicDelegate<ExtArgs>;

  /**
   * `prisma.patient`: Exposes CRUD operations for the **Patient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Patients
    * const patients = await prisma.patient.findMany()
    * ```
    */
  get patient(): Prisma.PatientDelegate<ExtArgs>;

  /**
   * `prisma.appointment`: Exposes CRUD operations for the **Appointment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Appointments
    * const appointments = await prisma.appointment.findMany()
    * ```
    */
  get appointment(): Prisma.AppointmentDelegate<ExtArgs>;

  /**
   * `prisma.medicationLog`: Exposes CRUD operations for the **MedicationLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MedicationLogs
    * const medicationLogs = await prisma.medicationLog.findMany()
    * ```
    */
  get medicationLog(): Prisma.MedicationLogDelegate<ExtArgs>;

  /**
   * `prisma.exam`: Exposes CRUD operations for the **Exam** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Exams
    * const exams = await prisma.exam.findMany()
    * ```
    */
  get exam(): Prisma.ExamDelegate<ExtArgs>;

  /**
   * `prisma.systemContentTemplate`: Exposes CRUD operations for the **SystemContentTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemContentTemplates
    * const systemContentTemplates = await prisma.systemContentTemplate.findMany()
    * ```
    */
  get systemContentTemplate(): Prisma.SystemContentTemplateDelegate<ExtArgs>;

  /**
   * `prisma.clinicContent`: Exposes CRUD operations for the **ClinicContent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ClinicContents
    * const clinicContents = await prisma.clinicContent.findMany()
    * ```
    */
  get clinicContent(): Prisma.ClinicContentDelegate<ExtArgs>;

  /**
   * `prisma.patientContentAdjustment`: Exposes CRUD operations for the **PatientContentAdjustment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PatientContentAdjustments
    * const patientContentAdjustments = await prisma.patientContentAdjustment.findMany()
    * ```
    */
  get patientContentAdjustment(): Prisma.PatientContentAdjustmentDelegate<ExtArgs>;

  /**
   * `prisma.trainingProtocol`: Exposes CRUD operations for the **TrainingProtocol** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrainingProtocols
    * const trainingProtocols = await prisma.trainingProtocol.findMany()
    * ```
    */
  get trainingProtocol(): Prisma.TrainingProtocolDelegate<ExtArgs>;

  /**
   * `prisma.trainingWeek`: Exposes CRUD operations for the **TrainingWeek** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrainingWeeks
    * const trainingWeeks = await prisma.trainingWeek.findMany()
    * ```
    */
  get trainingWeek(): Prisma.TrainingWeekDelegate<ExtArgs>;

  /**
   * `prisma.trainingSession`: Exposes CRUD operations for the **TrainingSession** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrainingSessions
    * const trainingSessions = await prisma.trainingSession.findMany()
    * ```
    */
  get trainingSession(): Prisma.TrainingSessionDelegate<ExtArgs>;

  /**
   * `prisma.patientTrainingProgress`: Exposes CRUD operations for the **PatientTrainingProgress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PatientTrainingProgresses
    * const patientTrainingProgresses = await prisma.patientTrainingProgress.findMany()
    * ```
    */
  get patientTrainingProgress(): Prisma.PatientTrainingProgressDelegate<ExtArgs>;

  /**
   * `prisma.patientSessionCompletion`: Exposes CRUD operations for the **PatientSessionCompletion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PatientSessionCompletions
    * const patientSessionCompletions = await prisma.patientSessionCompletion.findMany()
    * ```
    */
  get patientSessionCompletion(): Prisma.PatientSessionCompletionDelegate<ExtArgs>;

  /**
   * `prisma.chatConversation`: Exposes CRUD operations for the **ChatConversation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatConversations
    * const chatConversations = await prisma.chatConversation.findMany()
    * ```
    */
  get chatConversation(): Prisma.ChatConversationDelegate<ExtArgs>;

  /**
   * `prisma.chatMessage`: Exposes CRUD operations for the **ChatMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChatMessages
    * const chatMessages = await prisma.chatMessage.findMany()
    * ```
    */
  get chatMessage(): Prisma.ChatMessageDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    PasswordReset: 'PasswordReset',
    Clinic: 'Clinic',
    Patient: 'Patient',
    Appointment: 'Appointment',
    MedicationLog: 'MedicationLog',
    Exam: 'Exam',
    SystemContentTemplate: 'SystemContentTemplate',
    ClinicContent: 'ClinicContent',
    PatientContentAdjustment: 'PatientContentAdjustment',
    TrainingProtocol: 'TrainingProtocol',
    TrainingWeek: 'TrainingWeek',
    TrainingSession: 'TrainingSession',
    PatientTrainingProgress: 'PatientTrainingProgress',
    PatientSessionCompletion: 'PatientSessionCompletion',
    ChatConversation: 'ChatConversation',
    ChatMessage: 'ChatMessage'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "passwordReset" | "clinic" | "patient" | "appointment" | "medicationLog" | "exam" | "systemContentTemplate" | "clinicContent" | "patientContentAdjustment" | "trainingProtocol" | "trainingWeek" | "trainingSession" | "patientTrainingProgress" | "patientSessionCompletion" | "chatConversation" | "chatMessage"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      PasswordReset: {
        payload: Prisma.$PasswordResetPayload<ExtArgs>
        fields: Prisma.PasswordResetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordResetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordResetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>
          }
          findFirst: {
            args: Prisma.PasswordResetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordResetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>
          }
          findMany: {
            args: Prisma.PasswordResetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>[]
          }
          create: {
            args: Prisma.PasswordResetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>
          }
          createMany: {
            args: Prisma.PasswordResetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordResetCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>[]
          }
          delete: {
            args: Prisma.PasswordResetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>
          }
          update: {
            args: Prisma.PasswordResetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>
          }
          deleteMany: {
            args: Prisma.PasswordResetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordResetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PasswordResetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetPayload>
          }
          aggregate: {
            args: Prisma.PasswordResetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordReset>
          }
          groupBy: {
            args: Prisma.PasswordResetGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordResetCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetCountAggregateOutputType> | number
          }
        }
      }
      Clinic: {
        payload: Prisma.$ClinicPayload<ExtArgs>
        fields: Prisma.ClinicFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClinicFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClinicFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>
          }
          findFirst: {
            args: Prisma.ClinicFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClinicFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>
          }
          findMany: {
            args: Prisma.ClinicFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>[]
          }
          create: {
            args: Prisma.ClinicCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>
          }
          createMany: {
            args: Prisma.ClinicCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClinicCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>[]
          }
          delete: {
            args: Prisma.ClinicDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>
          }
          update: {
            args: Prisma.ClinicUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>
          }
          deleteMany: {
            args: Prisma.ClinicDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClinicUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClinicUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicPayload>
          }
          aggregate: {
            args: Prisma.ClinicAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClinic>
          }
          groupBy: {
            args: Prisma.ClinicGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClinicGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClinicCountArgs<ExtArgs>
            result: $Utils.Optional<ClinicCountAggregateOutputType> | number
          }
        }
      }
      Patient: {
        payload: Prisma.$PatientPayload<ExtArgs>
        fields: Prisma.PatientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findFirst: {
            args: Prisma.PatientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          findMany: {
            args: Prisma.PatientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          create: {
            args: Prisma.PatientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          createMany: {
            args: Prisma.PatientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PatientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>[]
          }
          delete: {
            args: Prisma.PatientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          update: {
            args: Prisma.PatientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          deleteMany: {
            args: Prisma.PatientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PatientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PatientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientPayload>
          }
          aggregate: {
            args: Prisma.PatientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatient>
          }
          groupBy: {
            args: Prisma.PatientGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatientGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatientCountArgs<ExtArgs>
            result: $Utils.Optional<PatientCountAggregateOutputType> | number
          }
        }
      }
      Appointment: {
        payload: Prisma.$AppointmentPayload<ExtArgs>
        fields: Prisma.AppointmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppointmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppointmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          findFirst: {
            args: Prisma.AppointmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppointmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          findMany: {
            args: Prisma.AppointmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          create: {
            args: Prisma.AppointmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          createMany: {
            args: Prisma.AppointmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AppointmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>[]
          }
          delete: {
            args: Prisma.AppointmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          update: {
            args: Prisma.AppointmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          deleteMany: {
            args: Prisma.AppointmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AppointmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AppointmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppointmentPayload>
          }
          aggregate: {
            args: Prisma.AppointmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAppointment>
          }
          groupBy: {
            args: Prisma.AppointmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppointmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppointmentCountArgs<ExtArgs>
            result: $Utils.Optional<AppointmentCountAggregateOutputType> | number
          }
        }
      }
      MedicationLog: {
        payload: Prisma.$MedicationLogPayload<ExtArgs>
        fields: Prisma.MedicationLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MedicationLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MedicationLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationLogPayload>
          }
          findFirst: {
            args: Prisma.MedicationLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MedicationLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationLogPayload>
          }
          findMany: {
            args: Prisma.MedicationLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationLogPayload>[]
          }
          create: {
            args: Prisma.MedicationLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationLogPayload>
          }
          createMany: {
            args: Prisma.MedicationLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MedicationLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationLogPayload>[]
          }
          delete: {
            args: Prisma.MedicationLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationLogPayload>
          }
          update: {
            args: Prisma.MedicationLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationLogPayload>
          }
          deleteMany: {
            args: Prisma.MedicationLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MedicationLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.MedicationLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MedicationLogPayload>
          }
          aggregate: {
            args: Prisma.MedicationLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMedicationLog>
          }
          groupBy: {
            args: Prisma.MedicationLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<MedicationLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.MedicationLogCountArgs<ExtArgs>
            result: $Utils.Optional<MedicationLogCountAggregateOutputType> | number
          }
        }
      }
      Exam: {
        payload: Prisma.$ExamPayload<ExtArgs>
        fields: Prisma.ExamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          findFirst: {
            args: Prisma.ExamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          findMany: {
            args: Prisma.ExamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>[]
          }
          create: {
            args: Prisma.ExamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          createMany: {
            args: Prisma.ExamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>[]
          }
          delete: {
            args: Prisma.ExamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          update: {
            args: Prisma.ExamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          deleteMany: {
            args: Prisma.ExamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExamPayload>
          }
          aggregate: {
            args: Prisma.ExamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExam>
          }
          groupBy: {
            args: Prisma.ExamGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExamGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExamCountArgs<ExtArgs>
            result: $Utils.Optional<ExamCountAggregateOutputType> | number
          }
        }
      }
      SystemContentTemplate: {
        payload: Prisma.$SystemContentTemplatePayload<ExtArgs>
        fields: Prisma.SystemContentTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemContentTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemContentTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemContentTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemContentTemplatePayload>
          }
          findFirst: {
            args: Prisma.SystemContentTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemContentTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemContentTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemContentTemplatePayload>
          }
          findMany: {
            args: Prisma.SystemContentTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemContentTemplatePayload>[]
          }
          create: {
            args: Prisma.SystemContentTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemContentTemplatePayload>
          }
          createMany: {
            args: Prisma.SystemContentTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemContentTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemContentTemplatePayload>[]
          }
          delete: {
            args: Prisma.SystemContentTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemContentTemplatePayload>
          }
          update: {
            args: Prisma.SystemContentTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemContentTemplatePayload>
          }
          deleteMany: {
            args: Prisma.SystemContentTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemContentTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SystemContentTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemContentTemplatePayload>
          }
          aggregate: {
            args: Prisma.SystemContentTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemContentTemplate>
          }
          groupBy: {
            args: Prisma.SystemContentTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemContentTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemContentTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<SystemContentTemplateCountAggregateOutputType> | number
          }
        }
      }
      ClinicContent: {
        payload: Prisma.$ClinicContentPayload<ExtArgs>
        fields: Prisma.ClinicContentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClinicContentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicContentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClinicContentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicContentPayload>
          }
          findFirst: {
            args: Prisma.ClinicContentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicContentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClinicContentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicContentPayload>
          }
          findMany: {
            args: Prisma.ClinicContentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicContentPayload>[]
          }
          create: {
            args: Prisma.ClinicContentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicContentPayload>
          }
          createMany: {
            args: Prisma.ClinicContentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClinicContentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicContentPayload>[]
          }
          delete: {
            args: Prisma.ClinicContentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicContentPayload>
          }
          update: {
            args: Prisma.ClinicContentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicContentPayload>
          }
          deleteMany: {
            args: Prisma.ClinicContentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClinicContentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ClinicContentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClinicContentPayload>
          }
          aggregate: {
            args: Prisma.ClinicContentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClinicContent>
          }
          groupBy: {
            args: Prisma.ClinicContentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClinicContentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClinicContentCountArgs<ExtArgs>
            result: $Utils.Optional<ClinicContentCountAggregateOutputType> | number
          }
        }
      }
      PatientContentAdjustment: {
        payload: Prisma.$PatientContentAdjustmentPayload<ExtArgs>
        fields: Prisma.PatientContentAdjustmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatientContentAdjustmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientContentAdjustmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatientContentAdjustmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientContentAdjustmentPayload>
          }
          findFirst: {
            args: Prisma.PatientContentAdjustmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientContentAdjustmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatientContentAdjustmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientContentAdjustmentPayload>
          }
          findMany: {
            args: Prisma.PatientContentAdjustmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientContentAdjustmentPayload>[]
          }
          create: {
            args: Prisma.PatientContentAdjustmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientContentAdjustmentPayload>
          }
          createMany: {
            args: Prisma.PatientContentAdjustmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PatientContentAdjustmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientContentAdjustmentPayload>[]
          }
          delete: {
            args: Prisma.PatientContentAdjustmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientContentAdjustmentPayload>
          }
          update: {
            args: Prisma.PatientContentAdjustmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientContentAdjustmentPayload>
          }
          deleteMany: {
            args: Prisma.PatientContentAdjustmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PatientContentAdjustmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PatientContentAdjustmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientContentAdjustmentPayload>
          }
          aggregate: {
            args: Prisma.PatientContentAdjustmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatientContentAdjustment>
          }
          groupBy: {
            args: Prisma.PatientContentAdjustmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatientContentAdjustmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatientContentAdjustmentCountArgs<ExtArgs>
            result: $Utils.Optional<PatientContentAdjustmentCountAggregateOutputType> | number
          }
        }
      }
      TrainingProtocol: {
        payload: Prisma.$TrainingProtocolPayload<ExtArgs>
        fields: Prisma.TrainingProtocolFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrainingProtocolFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingProtocolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainingProtocolFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingProtocolPayload>
          }
          findFirst: {
            args: Prisma.TrainingProtocolFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingProtocolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainingProtocolFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingProtocolPayload>
          }
          findMany: {
            args: Prisma.TrainingProtocolFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingProtocolPayload>[]
          }
          create: {
            args: Prisma.TrainingProtocolCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingProtocolPayload>
          }
          createMany: {
            args: Prisma.TrainingProtocolCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrainingProtocolCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingProtocolPayload>[]
          }
          delete: {
            args: Prisma.TrainingProtocolDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingProtocolPayload>
          }
          update: {
            args: Prisma.TrainingProtocolUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingProtocolPayload>
          }
          deleteMany: {
            args: Prisma.TrainingProtocolDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrainingProtocolUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TrainingProtocolUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingProtocolPayload>
          }
          aggregate: {
            args: Prisma.TrainingProtocolAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrainingProtocol>
          }
          groupBy: {
            args: Prisma.TrainingProtocolGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrainingProtocolGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrainingProtocolCountArgs<ExtArgs>
            result: $Utils.Optional<TrainingProtocolCountAggregateOutputType> | number
          }
        }
      }
      TrainingWeek: {
        payload: Prisma.$TrainingWeekPayload<ExtArgs>
        fields: Prisma.TrainingWeekFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrainingWeekFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingWeekPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainingWeekFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingWeekPayload>
          }
          findFirst: {
            args: Prisma.TrainingWeekFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingWeekPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainingWeekFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingWeekPayload>
          }
          findMany: {
            args: Prisma.TrainingWeekFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingWeekPayload>[]
          }
          create: {
            args: Prisma.TrainingWeekCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingWeekPayload>
          }
          createMany: {
            args: Prisma.TrainingWeekCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrainingWeekCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingWeekPayload>[]
          }
          delete: {
            args: Prisma.TrainingWeekDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingWeekPayload>
          }
          update: {
            args: Prisma.TrainingWeekUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingWeekPayload>
          }
          deleteMany: {
            args: Prisma.TrainingWeekDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrainingWeekUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TrainingWeekUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingWeekPayload>
          }
          aggregate: {
            args: Prisma.TrainingWeekAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrainingWeek>
          }
          groupBy: {
            args: Prisma.TrainingWeekGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrainingWeekGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrainingWeekCountArgs<ExtArgs>
            result: $Utils.Optional<TrainingWeekCountAggregateOutputType> | number
          }
        }
      }
      TrainingSession: {
        payload: Prisma.$TrainingSessionPayload<ExtArgs>
        fields: Prisma.TrainingSessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrainingSessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingSessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrainingSessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingSessionPayload>
          }
          findFirst: {
            args: Prisma.TrainingSessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingSessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrainingSessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingSessionPayload>
          }
          findMany: {
            args: Prisma.TrainingSessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingSessionPayload>[]
          }
          create: {
            args: Prisma.TrainingSessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingSessionPayload>
          }
          createMany: {
            args: Prisma.TrainingSessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrainingSessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingSessionPayload>[]
          }
          delete: {
            args: Prisma.TrainingSessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingSessionPayload>
          }
          update: {
            args: Prisma.TrainingSessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingSessionPayload>
          }
          deleteMany: {
            args: Prisma.TrainingSessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrainingSessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TrainingSessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrainingSessionPayload>
          }
          aggregate: {
            args: Prisma.TrainingSessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrainingSession>
          }
          groupBy: {
            args: Prisma.TrainingSessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrainingSessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrainingSessionCountArgs<ExtArgs>
            result: $Utils.Optional<TrainingSessionCountAggregateOutputType> | number
          }
        }
      }
      PatientTrainingProgress: {
        payload: Prisma.$PatientTrainingProgressPayload<ExtArgs>
        fields: Prisma.PatientTrainingProgressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatientTrainingProgressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientTrainingProgressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatientTrainingProgressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientTrainingProgressPayload>
          }
          findFirst: {
            args: Prisma.PatientTrainingProgressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientTrainingProgressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatientTrainingProgressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientTrainingProgressPayload>
          }
          findMany: {
            args: Prisma.PatientTrainingProgressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientTrainingProgressPayload>[]
          }
          create: {
            args: Prisma.PatientTrainingProgressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientTrainingProgressPayload>
          }
          createMany: {
            args: Prisma.PatientTrainingProgressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PatientTrainingProgressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientTrainingProgressPayload>[]
          }
          delete: {
            args: Prisma.PatientTrainingProgressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientTrainingProgressPayload>
          }
          update: {
            args: Prisma.PatientTrainingProgressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientTrainingProgressPayload>
          }
          deleteMany: {
            args: Prisma.PatientTrainingProgressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PatientTrainingProgressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PatientTrainingProgressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientTrainingProgressPayload>
          }
          aggregate: {
            args: Prisma.PatientTrainingProgressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatientTrainingProgress>
          }
          groupBy: {
            args: Prisma.PatientTrainingProgressGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatientTrainingProgressGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatientTrainingProgressCountArgs<ExtArgs>
            result: $Utils.Optional<PatientTrainingProgressCountAggregateOutputType> | number
          }
        }
      }
      PatientSessionCompletion: {
        payload: Prisma.$PatientSessionCompletionPayload<ExtArgs>
        fields: Prisma.PatientSessionCompletionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PatientSessionCompletionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientSessionCompletionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PatientSessionCompletionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientSessionCompletionPayload>
          }
          findFirst: {
            args: Prisma.PatientSessionCompletionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientSessionCompletionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PatientSessionCompletionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientSessionCompletionPayload>
          }
          findMany: {
            args: Prisma.PatientSessionCompletionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientSessionCompletionPayload>[]
          }
          create: {
            args: Prisma.PatientSessionCompletionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientSessionCompletionPayload>
          }
          createMany: {
            args: Prisma.PatientSessionCompletionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PatientSessionCompletionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientSessionCompletionPayload>[]
          }
          delete: {
            args: Prisma.PatientSessionCompletionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientSessionCompletionPayload>
          }
          update: {
            args: Prisma.PatientSessionCompletionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientSessionCompletionPayload>
          }
          deleteMany: {
            args: Prisma.PatientSessionCompletionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PatientSessionCompletionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PatientSessionCompletionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PatientSessionCompletionPayload>
          }
          aggregate: {
            args: Prisma.PatientSessionCompletionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePatientSessionCompletion>
          }
          groupBy: {
            args: Prisma.PatientSessionCompletionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PatientSessionCompletionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PatientSessionCompletionCountArgs<ExtArgs>
            result: $Utils.Optional<PatientSessionCompletionCountAggregateOutputType> | number
          }
        }
      }
      ChatConversation: {
        payload: Prisma.$ChatConversationPayload<ExtArgs>
        fields: Prisma.ChatConversationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatConversationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatConversationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatConversationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatConversationPayload>
          }
          findFirst: {
            args: Prisma.ChatConversationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatConversationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatConversationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatConversationPayload>
          }
          findMany: {
            args: Prisma.ChatConversationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatConversationPayload>[]
          }
          create: {
            args: Prisma.ChatConversationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatConversationPayload>
          }
          createMany: {
            args: Prisma.ChatConversationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatConversationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatConversationPayload>[]
          }
          delete: {
            args: Prisma.ChatConversationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatConversationPayload>
          }
          update: {
            args: Prisma.ChatConversationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatConversationPayload>
          }
          deleteMany: {
            args: Prisma.ChatConversationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatConversationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChatConversationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatConversationPayload>
          }
          aggregate: {
            args: Prisma.ChatConversationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatConversation>
          }
          groupBy: {
            args: Prisma.ChatConversationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatConversationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatConversationCountArgs<ExtArgs>
            result: $Utils.Optional<ChatConversationCountAggregateOutputType> | number
          }
        }
      }
      ChatMessage: {
        payload: Prisma.$ChatMessagePayload<ExtArgs>
        fields: Prisma.ChatMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChatMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChatMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          findFirst: {
            args: Prisma.ChatMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChatMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          findMany: {
            args: Prisma.ChatMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
          }
          create: {
            args: Prisma.ChatMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          createMany: {
            args: Prisma.ChatMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChatMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>[]
          }
          delete: {
            args: Prisma.ChatMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          update: {
            args: Prisma.ChatMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          deleteMany: {
            args: Prisma.ChatMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChatMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChatMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChatMessagePayload>
          }
          aggregate: {
            args: Prisma.ChatMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChatMessage>
          }
          groupBy: {
            args: Prisma.ChatMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChatMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChatMessageCountArgs<ExtArgs>
            result: $Utils.Optional<ChatMessageCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    passwordResets: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    passwordResets?: boolean | UserCountOutputTypeCountPasswordResetsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPasswordResetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetWhereInput
  }


  /**
   * Count Type ClinicCountOutputType
   */

  export type ClinicCountOutputType = {
    users: number
    patients: number
    contents: number
    trainingProtocols: number
  }

  export type ClinicCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | ClinicCountOutputTypeCountUsersArgs
    patients?: boolean | ClinicCountOutputTypeCountPatientsArgs
    contents?: boolean | ClinicCountOutputTypeCountContentsArgs
    trainingProtocols?: boolean | ClinicCountOutputTypeCountTrainingProtocolsArgs
  }

  // Custom InputTypes
  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicCountOutputType
     */
    select?: ClinicCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
  }

  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeCountPatientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientWhereInput
  }

  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeCountContentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClinicContentWhereInput
  }

  /**
   * ClinicCountOutputType without action
   */
  export type ClinicCountOutputTypeCountTrainingProtocolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingProtocolWhereInput
  }


  /**
   * Count Type PatientCountOutputType
   */

  export type PatientCountOutputType = {
    contentAdjustments: number
    appointments: number
    medicationLogs: number
    chatConversations: number
    exams: number
    trainingProgress: number
    sessionCompletions: number
  }

  export type PatientCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contentAdjustments?: boolean | PatientCountOutputTypeCountContentAdjustmentsArgs
    appointments?: boolean | PatientCountOutputTypeCountAppointmentsArgs
    medicationLogs?: boolean | PatientCountOutputTypeCountMedicationLogsArgs
    chatConversations?: boolean | PatientCountOutputTypeCountChatConversationsArgs
    exams?: boolean | PatientCountOutputTypeCountExamsArgs
    trainingProgress?: boolean | PatientCountOutputTypeCountTrainingProgressArgs
    sessionCompletions?: boolean | PatientCountOutputTypeCountSessionCompletionsArgs
  }

  // Custom InputTypes
  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientCountOutputType
     */
    select?: PatientCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountContentAdjustmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientContentAdjustmentWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountAppointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountMedicationLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicationLogWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountChatConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatConversationWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountExamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountTrainingProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientTrainingProgressWhereInput
  }

  /**
   * PatientCountOutputType without action
   */
  export type PatientCountOutputTypeCountSessionCompletionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientSessionCompletionWhereInput
  }


  /**
   * Count Type ClinicContentCountOutputType
   */

  export type ClinicContentCountOutputType = {
    patientAdjustments: number
  }

  export type ClinicContentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patientAdjustments?: boolean | ClinicContentCountOutputTypeCountPatientAdjustmentsArgs
  }

  // Custom InputTypes
  /**
   * ClinicContentCountOutputType without action
   */
  export type ClinicContentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicContentCountOutputType
     */
    select?: ClinicContentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClinicContentCountOutputType without action
   */
  export type ClinicContentCountOutputTypeCountPatientAdjustmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientContentAdjustmentWhereInput
  }


  /**
   * Count Type TrainingProtocolCountOutputType
   */

  export type TrainingProtocolCountOutputType = {
    weeks: number
  }

  export type TrainingProtocolCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    weeks?: boolean | TrainingProtocolCountOutputTypeCountWeeksArgs
  }

  // Custom InputTypes
  /**
   * TrainingProtocolCountOutputType without action
   */
  export type TrainingProtocolCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingProtocolCountOutputType
     */
    select?: TrainingProtocolCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TrainingProtocolCountOutputType without action
   */
  export type TrainingProtocolCountOutputTypeCountWeeksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingWeekWhereInput
  }


  /**
   * Count Type TrainingWeekCountOutputType
   */

  export type TrainingWeekCountOutputType = {
    sessions: number
    progress: number
  }

  export type TrainingWeekCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sessions?: boolean | TrainingWeekCountOutputTypeCountSessionsArgs
    progress?: boolean | TrainingWeekCountOutputTypeCountProgressArgs
  }

  // Custom InputTypes
  /**
   * TrainingWeekCountOutputType without action
   */
  export type TrainingWeekCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingWeekCountOutputType
     */
    select?: TrainingWeekCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TrainingWeekCountOutputType without action
   */
  export type TrainingWeekCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingSessionWhereInput
  }

  /**
   * TrainingWeekCountOutputType without action
   */
  export type TrainingWeekCountOutputTypeCountProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientTrainingProgressWhereInput
  }


  /**
   * Count Type TrainingSessionCountOutputType
   */

  export type TrainingSessionCountOutputType = {
    completions: number
  }

  export type TrainingSessionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    completions?: boolean | TrainingSessionCountOutputTypeCountCompletionsArgs
  }

  // Custom InputTypes
  /**
   * TrainingSessionCountOutputType without action
   */
  export type TrainingSessionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSessionCountOutputType
     */
    select?: TrainingSessionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TrainingSessionCountOutputType without action
   */
  export type TrainingSessionCountOutputTypeCountCompletionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientSessionCompletionWhereInput
  }


  /**
   * Count Type ChatConversationCountOutputType
   */

  export type ChatConversationCountOutputType = {
    messages: number
  }

  export type ChatConversationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | ChatConversationCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * ChatConversationCountOutputType without action
   */
  export type ChatConversationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatConversationCountOutputType
     */
    select?: ChatConversationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChatConversationCountOutputType without action
   */
  export type ChatConversationCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    name: string | null
    role: $Enums.UserRole | null
    clinicId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    passwordHash: string | null
    name: string | null
    role: $Enums.UserRole | null
    clinicId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    passwordHash: number
    name: number
    role: number
    clinicId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    name?: true
    role?: true
    clinicId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    name?: true
    role?: true
    clinicId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    passwordHash?: true
    name?: true
    role?: true
    clinicId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    passwordHash: string
    name: string
    role: $Enums.UserRole
    clinicId: string | null
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    name?: boolean
    role?: boolean
    clinicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinic?: boolean | User$clinicArgs<ExtArgs>
    patient?: boolean | User$patientArgs<ExtArgs>
    passwordResets?: boolean | User$passwordResetsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    name?: boolean
    role?: boolean
    clinicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinic?: boolean | User$clinicArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    passwordHash?: boolean
    name?: boolean
    role?: boolean
    clinicId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | User$clinicArgs<ExtArgs>
    patient?: boolean | User$patientArgs<ExtArgs>
    passwordResets?: boolean | User$passwordResetsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | User$clinicArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      clinic: Prisma.$ClinicPayload<ExtArgs> | null
      patient: Prisma.$PatientPayload<ExtArgs> | null
      passwordResets: Prisma.$PasswordResetPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      passwordHash: string
      name: string
      role: $Enums.UserRole
      clinicId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clinic<T extends User$clinicArgs<ExtArgs> = {}>(args?: Subset<T, User$clinicArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    patient<T extends User$patientArgs<ExtArgs> = {}>(args?: Subset<T, User$patientArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    passwordResets<T extends User$passwordResetsArgs<ExtArgs> = {}>(args?: Subset<T, User$passwordResetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly passwordHash: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly clinicId: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.clinic
   */
  export type User$clinicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    where?: ClinicWhereInput
  }

  /**
   * User.patient
   */
  export type User$patientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    where?: PatientWhereInput
  }

  /**
   * User.passwordResets
   */
  export type User$passwordResetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    where?: PasswordResetWhereInput
    orderBy?: PasswordResetOrderByWithRelationInput | PasswordResetOrderByWithRelationInput[]
    cursor?: PasswordResetWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordResetScalarFieldEnum | PasswordResetScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model PasswordReset
   */

  export type AggregatePasswordReset = {
    _count: PasswordResetCountAggregateOutputType | null
    _min: PasswordResetMinAggregateOutputType | null
    _max: PasswordResetMaxAggregateOutputType | null
  }

  export type PasswordResetMinAggregateOutputType = {
    id: string | null
    userId: string | null
    code: string | null
    expiresAt: Date | null
    used: boolean | null
    createdAt: Date | null
  }

  export type PasswordResetMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    code: string | null
    expiresAt: Date | null
    used: boolean | null
    createdAt: Date | null
  }

  export type PasswordResetCountAggregateOutputType = {
    id: number
    userId: number
    code: number
    expiresAt: number
    used: number
    createdAt: number
    _all: number
  }


  export type PasswordResetMinAggregateInputType = {
    id?: true
    userId?: true
    code?: true
    expiresAt?: true
    used?: true
    createdAt?: true
  }

  export type PasswordResetMaxAggregateInputType = {
    id?: true
    userId?: true
    code?: true
    expiresAt?: true
    used?: true
    createdAt?: true
  }

  export type PasswordResetCountAggregateInputType = {
    id?: true
    userId?: true
    code?: true
    expiresAt?: true
    used?: true
    createdAt?: true
    _all?: true
  }

  export type PasswordResetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordReset to aggregate.
     */
    where?: PasswordResetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResets to fetch.
     */
    orderBy?: PasswordResetOrderByWithRelationInput | PasswordResetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordResetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordResets
    **/
    _count?: true | PasswordResetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordResetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordResetMaxAggregateInputType
  }

  export type GetPasswordResetAggregateType<T extends PasswordResetAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordReset]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordReset[P]>
      : GetScalarType<T[P], AggregatePasswordReset[P]>
  }




  export type PasswordResetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetWhereInput
    orderBy?: PasswordResetOrderByWithAggregationInput | PasswordResetOrderByWithAggregationInput[]
    by: PasswordResetScalarFieldEnum[] | PasswordResetScalarFieldEnum
    having?: PasswordResetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordResetCountAggregateInputType | true
    _min?: PasswordResetMinAggregateInputType
    _max?: PasswordResetMaxAggregateInputType
  }

  export type PasswordResetGroupByOutputType = {
    id: string
    userId: string
    code: string
    expiresAt: Date
    used: boolean
    createdAt: Date
    _count: PasswordResetCountAggregateOutputType | null
    _min: PasswordResetMinAggregateOutputType | null
    _max: PasswordResetMaxAggregateOutputType | null
  }

  type GetPasswordResetGroupByPayload<T extends PasswordResetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordResetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordResetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordResetGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordResetGroupByOutputType[P]>
        }
      >
    >


  export type PasswordResetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    code?: boolean
    expiresAt?: boolean
    used?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordReset"]>

  export type PasswordResetSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    code?: boolean
    expiresAt?: boolean
    used?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordReset"]>

  export type PasswordResetSelectScalar = {
    id?: boolean
    userId?: boolean
    code?: boolean
    expiresAt?: boolean
    used?: boolean
    createdAt?: boolean
  }

  export type PasswordResetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PasswordResetIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PasswordResetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordReset"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      code: string
      expiresAt: Date
      used: boolean
      createdAt: Date
    }, ExtArgs["result"]["passwordReset"]>
    composites: {}
  }

  type PasswordResetGetPayload<S extends boolean | null | undefined | PasswordResetDefaultArgs> = $Result.GetResult<Prisma.$PasswordResetPayload, S>

  type PasswordResetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PasswordResetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PasswordResetCountAggregateInputType | true
    }

  export interface PasswordResetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordReset'], meta: { name: 'PasswordReset' } }
    /**
     * Find zero or one PasswordReset that matches the filter.
     * @param {PasswordResetFindUniqueArgs} args - Arguments to find a PasswordReset
     * @example
     * // Get one PasswordReset
     * const passwordReset = await prisma.passwordReset.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordResetFindUniqueArgs>(args: SelectSubset<T, PasswordResetFindUniqueArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PasswordReset that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PasswordResetFindUniqueOrThrowArgs} args - Arguments to find a PasswordReset
     * @example
     * // Get one PasswordReset
     * const passwordReset = await prisma.passwordReset.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordResetFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordResetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PasswordReset that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetFindFirstArgs} args - Arguments to find a PasswordReset
     * @example
     * // Get one PasswordReset
     * const passwordReset = await prisma.passwordReset.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordResetFindFirstArgs>(args?: SelectSubset<T, PasswordResetFindFirstArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PasswordReset that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetFindFirstOrThrowArgs} args - Arguments to find a PasswordReset
     * @example
     * // Get one PasswordReset
     * const passwordReset = await prisma.passwordReset.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordResetFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordResetFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PasswordResets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordResets
     * const passwordResets = await prisma.passwordReset.findMany()
     * 
     * // Get first 10 PasswordResets
     * const passwordResets = await prisma.passwordReset.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordResetWithIdOnly = await prisma.passwordReset.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordResetFindManyArgs>(args?: SelectSubset<T, PasswordResetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PasswordReset.
     * @param {PasswordResetCreateArgs} args - Arguments to create a PasswordReset.
     * @example
     * // Create one PasswordReset
     * const PasswordReset = await prisma.passwordReset.create({
     *   data: {
     *     // ... data to create a PasswordReset
     *   }
     * })
     * 
     */
    create<T extends PasswordResetCreateArgs>(args: SelectSubset<T, PasswordResetCreateArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PasswordResets.
     * @param {PasswordResetCreateManyArgs} args - Arguments to create many PasswordResets.
     * @example
     * // Create many PasswordResets
     * const passwordReset = await prisma.passwordReset.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordResetCreateManyArgs>(args?: SelectSubset<T, PasswordResetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordResets and returns the data saved in the database.
     * @param {PasswordResetCreateManyAndReturnArgs} args - Arguments to create many PasswordResets.
     * @example
     * // Create many PasswordResets
     * const passwordReset = await prisma.passwordReset.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordResets and only return the `id`
     * const passwordResetWithIdOnly = await prisma.passwordReset.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordResetCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordResetCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PasswordReset.
     * @param {PasswordResetDeleteArgs} args - Arguments to delete one PasswordReset.
     * @example
     * // Delete one PasswordReset
     * const PasswordReset = await prisma.passwordReset.delete({
     *   where: {
     *     // ... filter to delete one PasswordReset
     *   }
     * })
     * 
     */
    delete<T extends PasswordResetDeleteArgs>(args: SelectSubset<T, PasswordResetDeleteArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PasswordReset.
     * @param {PasswordResetUpdateArgs} args - Arguments to update one PasswordReset.
     * @example
     * // Update one PasswordReset
     * const passwordReset = await prisma.passwordReset.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordResetUpdateArgs>(args: SelectSubset<T, PasswordResetUpdateArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PasswordResets.
     * @param {PasswordResetDeleteManyArgs} args - Arguments to filter PasswordResets to delete.
     * @example
     * // Delete a few PasswordResets
     * const { count } = await prisma.passwordReset.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordResetDeleteManyArgs>(args?: SelectSubset<T, PasswordResetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordResets
     * const passwordReset = await prisma.passwordReset.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordResetUpdateManyArgs>(args: SelectSubset<T, PasswordResetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PasswordReset.
     * @param {PasswordResetUpsertArgs} args - Arguments to update or create a PasswordReset.
     * @example
     * // Update or create a PasswordReset
     * const passwordReset = await prisma.passwordReset.upsert({
     *   create: {
     *     // ... data to create a PasswordReset
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordReset we want to update
     *   }
     * })
     */
    upsert<T extends PasswordResetUpsertArgs>(args: SelectSubset<T, PasswordResetUpsertArgs<ExtArgs>>): Prisma__PasswordResetClient<$Result.GetResult<Prisma.$PasswordResetPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PasswordResets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetCountArgs} args - Arguments to filter PasswordResets to count.
     * @example
     * // Count the number of PasswordResets
     * const count = await prisma.passwordReset.count({
     *   where: {
     *     // ... the filter for the PasswordResets we want to count
     *   }
     * })
    **/
    count<T extends PasswordResetCountArgs>(
      args?: Subset<T, PasswordResetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordResetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordReset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordResetAggregateArgs>(args: Subset<T, PasswordResetAggregateArgs>): Prisma.PrismaPromise<GetPasswordResetAggregateType<T>>

    /**
     * Group by PasswordReset.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordResetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordResetGroupByArgs['orderBy'] }
        : { orderBy?: PasswordResetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordResetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordResetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordReset model
   */
  readonly fields: PasswordResetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordReset.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordResetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordReset model
   */ 
  interface PasswordResetFieldRefs {
    readonly id: FieldRef<"PasswordReset", 'String'>
    readonly userId: FieldRef<"PasswordReset", 'String'>
    readonly code: FieldRef<"PasswordReset", 'String'>
    readonly expiresAt: FieldRef<"PasswordReset", 'DateTime'>
    readonly used: FieldRef<"PasswordReset", 'Boolean'>
    readonly createdAt: FieldRef<"PasswordReset", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PasswordReset findUnique
   */
  export type PasswordResetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * Filter, which PasswordReset to fetch.
     */
    where: PasswordResetWhereUniqueInput
  }

  /**
   * PasswordReset findUniqueOrThrow
   */
  export type PasswordResetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * Filter, which PasswordReset to fetch.
     */
    where: PasswordResetWhereUniqueInput
  }

  /**
   * PasswordReset findFirst
   */
  export type PasswordResetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * Filter, which PasswordReset to fetch.
     */
    where?: PasswordResetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResets to fetch.
     */
    orderBy?: PasswordResetOrderByWithRelationInput | PasswordResetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResets.
     */
    cursor?: PasswordResetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResets.
     */
    distinct?: PasswordResetScalarFieldEnum | PasswordResetScalarFieldEnum[]
  }

  /**
   * PasswordReset findFirstOrThrow
   */
  export type PasswordResetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * Filter, which PasswordReset to fetch.
     */
    where?: PasswordResetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResets to fetch.
     */
    orderBy?: PasswordResetOrderByWithRelationInput | PasswordResetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResets.
     */
    cursor?: PasswordResetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResets.
     */
    distinct?: PasswordResetScalarFieldEnum | PasswordResetScalarFieldEnum[]
  }

  /**
   * PasswordReset findMany
   */
  export type PasswordResetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * Filter, which PasswordResets to fetch.
     */
    where?: PasswordResetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResets to fetch.
     */
    orderBy?: PasswordResetOrderByWithRelationInput | PasswordResetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordResets.
     */
    cursor?: PasswordResetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordResets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResets.
     */
    skip?: number
    distinct?: PasswordResetScalarFieldEnum | PasswordResetScalarFieldEnum[]
  }

  /**
   * PasswordReset create
   */
  export type PasswordResetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * The data needed to create a PasswordReset.
     */
    data: XOR<PasswordResetCreateInput, PasswordResetUncheckedCreateInput>
  }

  /**
   * PasswordReset createMany
   */
  export type PasswordResetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordResets.
     */
    data: PasswordResetCreateManyInput | PasswordResetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordReset createManyAndReturn
   */
  export type PasswordResetCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PasswordResets.
     */
    data: PasswordResetCreateManyInput | PasswordResetCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordReset update
   */
  export type PasswordResetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * The data needed to update a PasswordReset.
     */
    data: XOR<PasswordResetUpdateInput, PasswordResetUncheckedUpdateInput>
    /**
     * Choose, which PasswordReset to update.
     */
    where: PasswordResetWhereUniqueInput
  }

  /**
   * PasswordReset updateMany
   */
  export type PasswordResetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordResets.
     */
    data: XOR<PasswordResetUpdateManyMutationInput, PasswordResetUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResets to update
     */
    where?: PasswordResetWhereInput
  }

  /**
   * PasswordReset upsert
   */
  export type PasswordResetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * The filter to search for the PasswordReset to update in case it exists.
     */
    where: PasswordResetWhereUniqueInput
    /**
     * In case the PasswordReset found by the `where` argument doesn't exist, create a new PasswordReset with this data.
     */
    create: XOR<PasswordResetCreateInput, PasswordResetUncheckedCreateInput>
    /**
     * In case the PasswordReset was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordResetUpdateInput, PasswordResetUncheckedUpdateInput>
  }

  /**
   * PasswordReset delete
   */
  export type PasswordResetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
    /**
     * Filter which PasswordReset to delete.
     */
    where: PasswordResetWhereUniqueInput
  }

  /**
   * PasswordReset deleteMany
   */
  export type PasswordResetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResets to delete
     */
    where?: PasswordResetWhereInput
  }

  /**
   * PasswordReset without action
   */
  export type PasswordResetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordReset
     */
    select?: PasswordResetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordResetInclude<ExtArgs> | null
  }


  /**
   * Model Clinic
   */

  export type AggregateClinic = {
    _count: ClinicCountAggregateOutputType | null
    _min: ClinicMinAggregateOutputType | null
    _max: ClinicMaxAggregateOutputType | null
  }

  export type ClinicMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    address: string | null
    logoUrl: string | null
    primaryColor: string | null
    secondaryColor: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClinicMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    phone: string | null
    address: string | null
    logoUrl: string | null
    primaryColor: string | null
    secondaryColor: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClinicCountAggregateOutputType = {
    id: number
    name: number
    email: number
    phone: number
    address: number
    logoUrl: number
    primaryColor: number
    secondaryColor: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClinicMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    logoUrl?: true
    primaryColor?: true
    secondaryColor?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClinicMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    logoUrl?: true
    primaryColor?: true
    secondaryColor?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClinicCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    phone?: true
    address?: true
    logoUrl?: true
    primaryColor?: true
    secondaryColor?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClinicAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clinic to aggregate.
     */
    where?: ClinicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clinics to fetch.
     */
    orderBy?: ClinicOrderByWithRelationInput | ClinicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClinicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clinics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clinics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Clinics
    **/
    _count?: true | ClinicCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClinicMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClinicMaxAggregateInputType
  }

  export type GetClinicAggregateType<T extends ClinicAggregateArgs> = {
        [P in keyof T & keyof AggregateClinic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClinic[P]>
      : GetScalarType<T[P], AggregateClinic[P]>
  }




  export type ClinicGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClinicWhereInput
    orderBy?: ClinicOrderByWithAggregationInput | ClinicOrderByWithAggregationInput[]
    by: ClinicScalarFieldEnum[] | ClinicScalarFieldEnum
    having?: ClinicScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClinicCountAggregateInputType | true
    _min?: ClinicMinAggregateInputType
    _max?: ClinicMaxAggregateInputType
  }

  export type ClinicGroupByOutputType = {
    id: string
    name: string
    email: string | null
    phone: string | null
    address: string | null
    logoUrl: string | null
    primaryColor: string | null
    secondaryColor: string | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ClinicCountAggregateOutputType | null
    _min: ClinicMinAggregateOutputType | null
    _max: ClinicMaxAggregateOutputType | null
  }

  type GetClinicGroupByPayload<T extends ClinicGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClinicGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClinicGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClinicGroupByOutputType[P]>
            : GetScalarType<T[P], ClinicGroupByOutputType[P]>
        }
      >
    >


  export type ClinicSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    logoUrl?: boolean
    primaryColor?: boolean
    secondaryColor?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    users?: boolean | Clinic$usersArgs<ExtArgs>
    patients?: boolean | Clinic$patientsArgs<ExtArgs>
    contents?: boolean | Clinic$contentsArgs<ExtArgs>
    trainingProtocols?: boolean | Clinic$trainingProtocolsArgs<ExtArgs>
    _count?: boolean | ClinicCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clinic"]>

  export type ClinicSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    logoUrl?: boolean
    primaryColor?: boolean
    secondaryColor?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["clinic"]>

  export type ClinicSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    logoUrl?: boolean
    primaryColor?: boolean
    secondaryColor?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClinicInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    users?: boolean | Clinic$usersArgs<ExtArgs>
    patients?: boolean | Clinic$patientsArgs<ExtArgs>
    contents?: boolean | Clinic$contentsArgs<ExtArgs>
    trainingProtocols?: boolean | Clinic$trainingProtocolsArgs<ExtArgs>
    _count?: boolean | ClinicCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClinicIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ClinicPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Clinic"
    objects: {
      users: Prisma.$UserPayload<ExtArgs>[]
      patients: Prisma.$PatientPayload<ExtArgs>[]
      contents: Prisma.$ClinicContentPayload<ExtArgs>[]
      trainingProtocols: Prisma.$TrainingProtocolPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string | null
      phone: string | null
      address: string | null
      logoUrl: string | null
      primaryColor: string | null
      secondaryColor: string | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["clinic"]>
    composites: {}
  }

  type ClinicGetPayload<S extends boolean | null | undefined | ClinicDefaultArgs> = $Result.GetResult<Prisma.$ClinicPayload, S>

  type ClinicCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClinicFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClinicCountAggregateInputType | true
    }

  export interface ClinicDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Clinic'], meta: { name: 'Clinic' } }
    /**
     * Find zero or one Clinic that matches the filter.
     * @param {ClinicFindUniqueArgs} args - Arguments to find a Clinic
     * @example
     * // Get one Clinic
     * const clinic = await prisma.clinic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClinicFindUniqueArgs>(args: SelectSubset<T, ClinicFindUniqueArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Clinic that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClinicFindUniqueOrThrowArgs} args - Arguments to find a Clinic
     * @example
     * // Get one Clinic
     * const clinic = await prisma.clinic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClinicFindUniqueOrThrowArgs>(args: SelectSubset<T, ClinicFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Clinic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicFindFirstArgs} args - Arguments to find a Clinic
     * @example
     * // Get one Clinic
     * const clinic = await prisma.clinic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClinicFindFirstArgs>(args?: SelectSubset<T, ClinicFindFirstArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Clinic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicFindFirstOrThrowArgs} args - Arguments to find a Clinic
     * @example
     * // Get one Clinic
     * const clinic = await prisma.clinic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClinicFindFirstOrThrowArgs>(args?: SelectSubset<T, ClinicFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Clinics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Clinics
     * const clinics = await prisma.clinic.findMany()
     * 
     * // Get first 10 Clinics
     * const clinics = await prisma.clinic.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clinicWithIdOnly = await prisma.clinic.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClinicFindManyArgs>(args?: SelectSubset<T, ClinicFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Clinic.
     * @param {ClinicCreateArgs} args - Arguments to create a Clinic.
     * @example
     * // Create one Clinic
     * const Clinic = await prisma.clinic.create({
     *   data: {
     *     // ... data to create a Clinic
     *   }
     * })
     * 
     */
    create<T extends ClinicCreateArgs>(args: SelectSubset<T, ClinicCreateArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Clinics.
     * @param {ClinicCreateManyArgs} args - Arguments to create many Clinics.
     * @example
     * // Create many Clinics
     * const clinic = await prisma.clinic.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClinicCreateManyArgs>(args?: SelectSubset<T, ClinicCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Clinics and returns the data saved in the database.
     * @param {ClinicCreateManyAndReturnArgs} args - Arguments to create many Clinics.
     * @example
     * // Create many Clinics
     * const clinic = await prisma.clinic.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Clinics and only return the `id`
     * const clinicWithIdOnly = await prisma.clinic.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClinicCreateManyAndReturnArgs>(args?: SelectSubset<T, ClinicCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Clinic.
     * @param {ClinicDeleteArgs} args - Arguments to delete one Clinic.
     * @example
     * // Delete one Clinic
     * const Clinic = await prisma.clinic.delete({
     *   where: {
     *     // ... filter to delete one Clinic
     *   }
     * })
     * 
     */
    delete<T extends ClinicDeleteArgs>(args: SelectSubset<T, ClinicDeleteArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Clinic.
     * @param {ClinicUpdateArgs} args - Arguments to update one Clinic.
     * @example
     * // Update one Clinic
     * const clinic = await prisma.clinic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClinicUpdateArgs>(args: SelectSubset<T, ClinicUpdateArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Clinics.
     * @param {ClinicDeleteManyArgs} args - Arguments to filter Clinics to delete.
     * @example
     * // Delete a few Clinics
     * const { count } = await prisma.clinic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClinicDeleteManyArgs>(args?: SelectSubset<T, ClinicDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Clinics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Clinics
     * const clinic = await prisma.clinic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClinicUpdateManyArgs>(args: SelectSubset<T, ClinicUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Clinic.
     * @param {ClinicUpsertArgs} args - Arguments to update or create a Clinic.
     * @example
     * // Update or create a Clinic
     * const clinic = await prisma.clinic.upsert({
     *   create: {
     *     // ... data to create a Clinic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Clinic we want to update
     *   }
     * })
     */
    upsert<T extends ClinicUpsertArgs>(args: SelectSubset<T, ClinicUpsertArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Clinics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicCountArgs} args - Arguments to filter Clinics to count.
     * @example
     * // Count the number of Clinics
     * const count = await prisma.clinic.count({
     *   where: {
     *     // ... the filter for the Clinics we want to count
     *   }
     * })
    **/
    count<T extends ClinicCountArgs>(
      args?: Subset<T, ClinicCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClinicCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Clinic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClinicAggregateArgs>(args: Subset<T, ClinicAggregateArgs>): Prisma.PrismaPromise<GetClinicAggregateType<T>>

    /**
     * Group by Clinic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClinicGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClinicGroupByArgs['orderBy'] }
        : { orderBy?: ClinicGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClinicGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClinicGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Clinic model
   */
  readonly fields: ClinicFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Clinic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClinicClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    users<T extends Clinic$usersArgs<ExtArgs> = {}>(args?: Subset<T, Clinic$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany"> | Null>
    patients<T extends Clinic$patientsArgs<ExtArgs> = {}>(args?: Subset<T, Clinic$patientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findMany"> | Null>
    contents<T extends Clinic$contentsArgs<ExtArgs> = {}>(args?: Subset<T, Clinic$contentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicContentPayload<ExtArgs>, T, "findMany"> | Null>
    trainingProtocols<T extends Clinic$trainingProtocolsArgs<ExtArgs> = {}>(args?: Subset<T, Clinic$trainingProtocolsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingProtocolPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Clinic model
   */ 
  interface ClinicFieldRefs {
    readonly id: FieldRef<"Clinic", 'String'>
    readonly name: FieldRef<"Clinic", 'String'>
    readonly email: FieldRef<"Clinic", 'String'>
    readonly phone: FieldRef<"Clinic", 'String'>
    readonly address: FieldRef<"Clinic", 'String'>
    readonly logoUrl: FieldRef<"Clinic", 'String'>
    readonly primaryColor: FieldRef<"Clinic", 'String'>
    readonly secondaryColor: FieldRef<"Clinic", 'String'>
    readonly isActive: FieldRef<"Clinic", 'Boolean'>
    readonly createdAt: FieldRef<"Clinic", 'DateTime'>
    readonly updatedAt: FieldRef<"Clinic", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Clinic findUnique
   */
  export type ClinicFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    /**
     * Filter, which Clinic to fetch.
     */
    where: ClinicWhereUniqueInput
  }

  /**
   * Clinic findUniqueOrThrow
   */
  export type ClinicFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    /**
     * Filter, which Clinic to fetch.
     */
    where: ClinicWhereUniqueInput
  }

  /**
   * Clinic findFirst
   */
  export type ClinicFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    /**
     * Filter, which Clinic to fetch.
     */
    where?: ClinicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clinics to fetch.
     */
    orderBy?: ClinicOrderByWithRelationInput | ClinicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clinics.
     */
    cursor?: ClinicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clinics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clinics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clinics.
     */
    distinct?: ClinicScalarFieldEnum | ClinicScalarFieldEnum[]
  }

  /**
   * Clinic findFirstOrThrow
   */
  export type ClinicFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    /**
     * Filter, which Clinic to fetch.
     */
    where?: ClinicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clinics to fetch.
     */
    orderBy?: ClinicOrderByWithRelationInput | ClinicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Clinics.
     */
    cursor?: ClinicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clinics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clinics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Clinics.
     */
    distinct?: ClinicScalarFieldEnum | ClinicScalarFieldEnum[]
  }

  /**
   * Clinic findMany
   */
  export type ClinicFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    /**
     * Filter, which Clinics to fetch.
     */
    where?: ClinicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Clinics to fetch.
     */
    orderBy?: ClinicOrderByWithRelationInput | ClinicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Clinics.
     */
    cursor?: ClinicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Clinics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Clinics.
     */
    skip?: number
    distinct?: ClinicScalarFieldEnum | ClinicScalarFieldEnum[]
  }

  /**
   * Clinic create
   */
  export type ClinicCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    /**
     * The data needed to create a Clinic.
     */
    data: XOR<ClinicCreateInput, ClinicUncheckedCreateInput>
  }

  /**
   * Clinic createMany
   */
  export type ClinicCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Clinics.
     */
    data: ClinicCreateManyInput | ClinicCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Clinic createManyAndReturn
   */
  export type ClinicCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Clinics.
     */
    data: ClinicCreateManyInput | ClinicCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Clinic update
   */
  export type ClinicUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    /**
     * The data needed to update a Clinic.
     */
    data: XOR<ClinicUpdateInput, ClinicUncheckedUpdateInput>
    /**
     * Choose, which Clinic to update.
     */
    where: ClinicWhereUniqueInput
  }

  /**
   * Clinic updateMany
   */
  export type ClinicUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Clinics.
     */
    data: XOR<ClinicUpdateManyMutationInput, ClinicUncheckedUpdateManyInput>
    /**
     * Filter which Clinics to update
     */
    where?: ClinicWhereInput
  }

  /**
   * Clinic upsert
   */
  export type ClinicUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    /**
     * The filter to search for the Clinic to update in case it exists.
     */
    where: ClinicWhereUniqueInput
    /**
     * In case the Clinic found by the `where` argument doesn't exist, create a new Clinic with this data.
     */
    create: XOR<ClinicCreateInput, ClinicUncheckedCreateInput>
    /**
     * In case the Clinic was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClinicUpdateInput, ClinicUncheckedUpdateInput>
  }

  /**
   * Clinic delete
   */
  export type ClinicDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    /**
     * Filter which Clinic to delete.
     */
    where: ClinicWhereUniqueInput
  }

  /**
   * Clinic deleteMany
   */
  export type ClinicDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Clinics to delete
     */
    where?: ClinicWhereInput
  }

  /**
   * Clinic.users
   */
  export type Clinic$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    cursor?: UserWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * Clinic.patients
   */
  export type Clinic$patientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    where?: PatientWhereInput
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    cursor?: PatientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Clinic.contents
   */
  export type Clinic$contentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicContent
     */
    select?: ClinicContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicContentInclude<ExtArgs> | null
    where?: ClinicContentWhereInput
    orderBy?: ClinicContentOrderByWithRelationInput | ClinicContentOrderByWithRelationInput[]
    cursor?: ClinicContentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClinicContentScalarFieldEnum | ClinicContentScalarFieldEnum[]
  }

  /**
   * Clinic.trainingProtocols
   */
  export type Clinic$trainingProtocolsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingProtocol
     */
    select?: TrainingProtocolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingProtocolInclude<ExtArgs> | null
    where?: TrainingProtocolWhereInput
    orderBy?: TrainingProtocolOrderByWithRelationInput | TrainingProtocolOrderByWithRelationInput[]
    cursor?: TrainingProtocolWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingProtocolScalarFieldEnum | TrainingProtocolScalarFieldEnum[]
  }

  /**
   * Clinic without action
   */
  export type ClinicDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
  }


  /**
   * Model Patient
   */

  export type AggregatePatient = {
    _count: PatientCountAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  export type PatientMinAggregateOutputType = {
    id: string | null
    userId: string | null
    clinicId: string | null
    cpf: string | null
    phone: string | null
    birthDate: Date | null
    surgeryDate: Date | null
    surgeryType: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PatientMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    clinicId: string | null
    cpf: string | null
    phone: string | null
    birthDate: Date | null
    surgeryDate: Date | null
    surgeryType: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PatientCountAggregateOutputType = {
    id: number
    userId: number
    clinicId: number
    cpf: number
    phone: number
    birthDate: number
    surgeryDate: number
    surgeryType: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PatientMinAggregateInputType = {
    id?: true
    userId?: true
    clinicId?: true
    cpf?: true
    phone?: true
    birthDate?: true
    surgeryDate?: true
    surgeryType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PatientMaxAggregateInputType = {
    id?: true
    userId?: true
    clinicId?: true
    cpf?: true
    phone?: true
    birthDate?: true
    surgeryDate?: true
    surgeryType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PatientCountAggregateInputType = {
    id?: true
    userId?: true
    clinicId?: true
    cpf?: true
    phone?: true
    birthDate?: true
    surgeryDate?: true
    surgeryType?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PatientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patient to aggregate.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Patients
    **/
    _count?: true | PatientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatientMaxAggregateInputType
  }

  export type GetPatientAggregateType<T extends PatientAggregateArgs> = {
        [P in keyof T & keyof AggregatePatient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatient[P]>
      : GetScalarType<T[P], AggregatePatient[P]>
  }




  export type PatientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientWhereInput
    orderBy?: PatientOrderByWithAggregationInput | PatientOrderByWithAggregationInput[]
    by: PatientScalarFieldEnum[] | PatientScalarFieldEnum
    having?: PatientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatientCountAggregateInputType | true
    _min?: PatientMinAggregateInputType
    _max?: PatientMaxAggregateInputType
  }

  export type PatientGroupByOutputType = {
    id: string
    userId: string
    clinicId: string
    cpf: string | null
    phone: string | null
    birthDate: Date | null
    surgeryDate: Date | null
    surgeryType: string | null
    createdAt: Date
    updatedAt: Date
    _count: PatientCountAggregateOutputType | null
    _min: PatientMinAggregateOutputType | null
    _max: PatientMaxAggregateOutputType | null
  }

  type GetPatientGroupByPayload<T extends PatientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatientGroupByOutputType[P]>
            : GetScalarType<T[P], PatientGroupByOutputType[P]>
        }
      >
    >


  export type PatientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    clinicId?: boolean
    cpf?: boolean
    phone?: boolean
    birthDate?: boolean
    surgeryDate?: boolean
    surgeryType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    contentAdjustments?: boolean | Patient$contentAdjustmentsArgs<ExtArgs>
    appointments?: boolean | Patient$appointmentsArgs<ExtArgs>
    medicationLogs?: boolean | Patient$medicationLogsArgs<ExtArgs>
    chatConversations?: boolean | Patient$chatConversationsArgs<ExtArgs>
    exams?: boolean | Patient$examsArgs<ExtArgs>
    trainingProgress?: boolean | Patient$trainingProgressArgs<ExtArgs>
    sessionCompletions?: boolean | Patient$sessionCompletionsArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    clinicId?: boolean
    cpf?: boolean
    phone?: boolean
    birthDate?: boolean
    surgeryDate?: boolean
    surgeryType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patient"]>

  export type PatientSelectScalar = {
    id?: boolean
    userId?: boolean
    clinicId?: boolean
    cpf?: boolean
    phone?: boolean
    birthDate?: boolean
    surgeryDate?: boolean
    surgeryType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PatientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    contentAdjustments?: boolean | Patient$contentAdjustmentsArgs<ExtArgs>
    appointments?: boolean | Patient$appointmentsArgs<ExtArgs>
    medicationLogs?: boolean | Patient$medicationLogsArgs<ExtArgs>
    chatConversations?: boolean | Patient$chatConversationsArgs<ExtArgs>
    exams?: boolean | Patient$examsArgs<ExtArgs>
    trainingProgress?: boolean | Patient$trainingProgressArgs<ExtArgs>
    sessionCompletions?: boolean | Patient$sessionCompletionsArgs<ExtArgs>
    _count?: boolean | PatientCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PatientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
  }

  export type $PatientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Patient"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      clinic: Prisma.$ClinicPayload<ExtArgs>
      contentAdjustments: Prisma.$PatientContentAdjustmentPayload<ExtArgs>[]
      appointments: Prisma.$AppointmentPayload<ExtArgs>[]
      medicationLogs: Prisma.$MedicationLogPayload<ExtArgs>[]
      chatConversations: Prisma.$ChatConversationPayload<ExtArgs>[]
      exams: Prisma.$ExamPayload<ExtArgs>[]
      trainingProgress: Prisma.$PatientTrainingProgressPayload<ExtArgs>[]
      sessionCompletions: Prisma.$PatientSessionCompletionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      clinicId: string
      cpf: string | null
      phone: string | null
      birthDate: Date | null
      surgeryDate: Date | null
      surgeryType: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["patient"]>
    composites: {}
  }

  type PatientGetPayload<S extends boolean | null | undefined | PatientDefaultArgs> = $Result.GetResult<Prisma.$PatientPayload, S>

  type PatientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PatientFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PatientCountAggregateInputType | true
    }

  export interface PatientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Patient'], meta: { name: 'Patient' } }
    /**
     * Find zero or one Patient that matches the filter.
     * @param {PatientFindUniqueArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PatientFindUniqueArgs>(args: SelectSubset<T, PatientFindUniqueArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Patient that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PatientFindUniqueOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PatientFindUniqueOrThrowArgs>(args: SelectSubset<T, PatientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Patient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PatientFindFirstArgs>(args?: SelectSubset<T, PatientFindFirstArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Patient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindFirstOrThrowArgs} args - Arguments to find a Patient
     * @example
     * // Get one Patient
     * const patient = await prisma.patient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PatientFindFirstOrThrowArgs>(args?: SelectSubset<T, PatientFindFirstOrThrowArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Patients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Patients
     * const patients = await prisma.patient.findMany()
     * 
     * // Get first 10 Patients
     * const patients = await prisma.patient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patientWithIdOnly = await prisma.patient.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PatientFindManyArgs>(args?: SelectSubset<T, PatientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Patient.
     * @param {PatientCreateArgs} args - Arguments to create a Patient.
     * @example
     * // Create one Patient
     * const Patient = await prisma.patient.create({
     *   data: {
     *     // ... data to create a Patient
     *   }
     * })
     * 
     */
    create<T extends PatientCreateArgs>(args: SelectSubset<T, PatientCreateArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Patients.
     * @param {PatientCreateManyArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patient = await prisma.patient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PatientCreateManyArgs>(args?: SelectSubset<T, PatientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Patients and returns the data saved in the database.
     * @param {PatientCreateManyAndReturnArgs} args - Arguments to create many Patients.
     * @example
     * // Create many Patients
     * const patient = await prisma.patient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Patients and only return the `id`
     * const patientWithIdOnly = await prisma.patient.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PatientCreateManyAndReturnArgs>(args?: SelectSubset<T, PatientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Patient.
     * @param {PatientDeleteArgs} args - Arguments to delete one Patient.
     * @example
     * // Delete one Patient
     * const Patient = await prisma.patient.delete({
     *   where: {
     *     // ... filter to delete one Patient
     *   }
     * })
     * 
     */
    delete<T extends PatientDeleteArgs>(args: SelectSubset<T, PatientDeleteArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Patient.
     * @param {PatientUpdateArgs} args - Arguments to update one Patient.
     * @example
     * // Update one Patient
     * const patient = await prisma.patient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PatientUpdateArgs>(args: SelectSubset<T, PatientUpdateArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Patients.
     * @param {PatientDeleteManyArgs} args - Arguments to filter Patients to delete.
     * @example
     * // Delete a few Patients
     * const { count } = await prisma.patient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PatientDeleteManyArgs>(args?: SelectSubset<T, PatientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Patients
     * const patient = await prisma.patient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PatientUpdateManyArgs>(args: SelectSubset<T, PatientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Patient.
     * @param {PatientUpsertArgs} args - Arguments to update or create a Patient.
     * @example
     * // Update or create a Patient
     * const patient = await prisma.patient.upsert({
     *   create: {
     *     // ... data to create a Patient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Patient we want to update
     *   }
     * })
     */
    upsert<T extends PatientUpsertArgs>(args: SelectSubset<T, PatientUpsertArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Patients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientCountArgs} args - Arguments to filter Patients to count.
     * @example
     * // Count the number of Patients
     * const count = await prisma.patient.count({
     *   where: {
     *     // ... the filter for the Patients we want to count
     *   }
     * })
    **/
    count<T extends PatientCountArgs>(
      args?: Subset<T, PatientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatientAggregateArgs>(args: Subset<T, PatientAggregateArgs>): Prisma.PrismaPromise<GetPatientAggregateType<T>>

    /**
     * Group by Patient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatientGroupByArgs['orderBy'] }
        : { orderBy?: PatientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Patient model
   */
  readonly fields: PatientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Patient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    clinic<T extends ClinicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClinicDefaultArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    contentAdjustments<T extends Patient$contentAdjustmentsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$contentAdjustmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientContentAdjustmentPayload<ExtArgs>, T, "findMany"> | Null>
    appointments<T extends Patient$appointmentsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$appointmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany"> | Null>
    medicationLogs<T extends Patient$medicationLogsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$medicationLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicationLogPayload<ExtArgs>, T, "findMany"> | Null>
    chatConversations<T extends Patient$chatConversationsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$chatConversationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatConversationPayload<ExtArgs>, T, "findMany"> | Null>
    exams<T extends Patient$examsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$examsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findMany"> | Null>
    trainingProgress<T extends Patient$trainingProgressArgs<ExtArgs> = {}>(args?: Subset<T, Patient$trainingProgressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientTrainingProgressPayload<ExtArgs>, T, "findMany"> | Null>
    sessionCompletions<T extends Patient$sessionCompletionsArgs<ExtArgs> = {}>(args?: Subset<T, Patient$sessionCompletionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientSessionCompletionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Patient model
   */ 
  interface PatientFieldRefs {
    readonly id: FieldRef<"Patient", 'String'>
    readonly userId: FieldRef<"Patient", 'String'>
    readonly clinicId: FieldRef<"Patient", 'String'>
    readonly cpf: FieldRef<"Patient", 'String'>
    readonly phone: FieldRef<"Patient", 'String'>
    readonly birthDate: FieldRef<"Patient", 'DateTime'>
    readonly surgeryDate: FieldRef<"Patient", 'DateTime'>
    readonly surgeryType: FieldRef<"Patient", 'String'>
    readonly createdAt: FieldRef<"Patient", 'DateTime'>
    readonly updatedAt: FieldRef<"Patient", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Patient findUnique
   */
  export type PatientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findUniqueOrThrow
   */
  export type PatientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient findFirst
   */
  export type PatientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient findFirstOrThrow
   */
  export type PatientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patient to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Patients.
     */
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient findMany
   */
  export type PatientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter, which Patients to fetch.
     */
    where?: PatientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Patients to fetch.
     */
    orderBy?: PatientOrderByWithRelationInput | PatientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Patients.
     */
    cursor?: PatientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Patients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Patients.
     */
    skip?: number
    distinct?: PatientScalarFieldEnum | PatientScalarFieldEnum[]
  }

  /**
   * Patient create
   */
  export type PatientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to create a Patient.
     */
    data: XOR<PatientCreateInput, PatientUncheckedCreateInput>
  }

  /**
   * Patient createMany
   */
  export type PatientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Patients.
     */
    data: PatientCreateManyInput | PatientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Patient createManyAndReturn
   */
  export type PatientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Patients.
     */
    data: PatientCreateManyInput | PatientCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Patient update
   */
  export type PatientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The data needed to update a Patient.
     */
    data: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
    /**
     * Choose, which Patient to update.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient updateMany
   */
  export type PatientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Patients.
     */
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyInput>
    /**
     * Filter which Patients to update
     */
    where?: PatientWhereInput
  }

  /**
   * Patient upsert
   */
  export type PatientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * The filter to search for the Patient to update in case it exists.
     */
    where: PatientWhereUniqueInput
    /**
     * In case the Patient found by the `where` argument doesn't exist, create a new Patient with this data.
     */
    create: XOR<PatientCreateInput, PatientUncheckedCreateInput>
    /**
     * In case the Patient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatientUpdateInput, PatientUncheckedUpdateInput>
  }

  /**
   * Patient delete
   */
  export type PatientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
    /**
     * Filter which Patient to delete.
     */
    where: PatientWhereUniqueInput
  }

  /**
   * Patient deleteMany
   */
  export type PatientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Patients to delete
     */
    where?: PatientWhereInput
  }

  /**
   * Patient.contentAdjustments
   */
  export type Patient$contentAdjustmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientContentAdjustment
     */
    select?: PatientContentAdjustmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientContentAdjustmentInclude<ExtArgs> | null
    where?: PatientContentAdjustmentWhereInput
    orderBy?: PatientContentAdjustmentOrderByWithRelationInput | PatientContentAdjustmentOrderByWithRelationInput[]
    cursor?: PatientContentAdjustmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatientContentAdjustmentScalarFieldEnum | PatientContentAdjustmentScalarFieldEnum[]
  }

  /**
   * Patient.appointments
   */
  export type Patient$appointmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    cursor?: AppointmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Patient.medicationLogs
   */
  export type Patient$medicationLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationLog
     */
    select?: MedicationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationLogInclude<ExtArgs> | null
    where?: MedicationLogWhereInput
    orderBy?: MedicationLogOrderByWithRelationInput | MedicationLogOrderByWithRelationInput[]
    cursor?: MedicationLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MedicationLogScalarFieldEnum | MedicationLogScalarFieldEnum[]
  }

  /**
   * Patient.chatConversations
   */
  export type Patient$chatConversationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatConversation
     */
    select?: ChatConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatConversationInclude<ExtArgs> | null
    where?: ChatConversationWhereInput
    orderBy?: ChatConversationOrderByWithRelationInput | ChatConversationOrderByWithRelationInput[]
    cursor?: ChatConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatConversationScalarFieldEnum | ChatConversationScalarFieldEnum[]
  }

  /**
   * Patient.exams
   */
  export type Patient$examsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    where?: ExamWhereInput
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    cursor?: ExamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Patient.trainingProgress
   */
  export type Patient$trainingProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientTrainingProgress
     */
    select?: PatientTrainingProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientTrainingProgressInclude<ExtArgs> | null
    where?: PatientTrainingProgressWhereInput
    orderBy?: PatientTrainingProgressOrderByWithRelationInput | PatientTrainingProgressOrderByWithRelationInput[]
    cursor?: PatientTrainingProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatientTrainingProgressScalarFieldEnum | PatientTrainingProgressScalarFieldEnum[]
  }

  /**
   * Patient.sessionCompletions
   */
  export type Patient$sessionCompletionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientSessionCompletion
     */
    select?: PatientSessionCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientSessionCompletionInclude<ExtArgs> | null
    where?: PatientSessionCompletionWhereInput
    orderBy?: PatientSessionCompletionOrderByWithRelationInput | PatientSessionCompletionOrderByWithRelationInput[]
    cursor?: PatientSessionCompletionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatientSessionCompletionScalarFieldEnum | PatientSessionCompletionScalarFieldEnum[]
  }

  /**
   * Patient without action
   */
  export type PatientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Patient
     */
    select?: PatientSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientInclude<ExtArgs> | null
  }


  /**
   * Model Appointment
   */

  export type AggregateAppointment = {
    _count: AppointmentCountAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  export type AppointmentMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    title: string | null
    description: string | null
    date: Date | null
    time: string | null
    type: $Enums.AppointmentType | null
    status: $Enums.AppointmentStatus | null
    location: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AppointmentMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    title: string | null
    description: string | null
    date: Date | null
    time: string | null
    type: $Enums.AppointmentType | null
    status: $Enums.AppointmentStatus | null
    location: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AppointmentCountAggregateOutputType = {
    id: number
    patientId: number
    title: number
    description: number
    date: number
    time: number
    type: number
    status: number
    location: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AppointmentMinAggregateInputType = {
    id?: true
    patientId?: true
    title?: true
    description?: true
    date?: true
    time?: true
    type?: true
    status?: true
    location?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AppointmentMaxAggregateInputType = {
    id?: true
    patientId?: true
    title?: true
    description?: true
    date?: true
    time?: true
    type?: true
    status?: true
    location?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AppointmentCountAggregateInputType = {
    id?: true
    patientId?: true
    title?: true
    description?: true
    date?: true
    time?: true
    type?: true
    status?: true
    location?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AppointmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointment to aggregate.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Appointments
    **/
    _count?: true | AppointmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppointmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppointmentMaxAggregateInputType
  }

  export type GetAppointmentAggregateType<T extends AppointmentAggregateArgs> = {
        [P in keyof T & keyof AggregateAppointment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppointment[P]>
      : GetScalarType<T[P], AggregateAppointment[P]>
  }




  export type AppointmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppointmentWhereInput
    orderBy?: AppointmentOrderByWithAggregationInput | AppointmentOrderByWithAggregationInput[]
    by: AppointmentScalarFieldEnum[] | AppointmentScalarFieldEnum
    having?: AppointmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppointmentCountAggregateInputType | true
    _min?: AppointmentMinAggregateInputType
    _max?: AppointmentMaxAggregateInputType
  }

  export type AppointmentGroupByOutputType = {
    id: string
    patientId: string
    title: string
    description: string | null
    date: Date
    time: string
    type: $Enums.AppointmentType
    status: $Enums.AppointmentStatus
    location: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: AppointmentCountAggregateOutputType | null
    _min: AppointmentMinAggregateOutputType | null
    _max: AppointmentMaxAggregateOutputType | null
  }

  type GetAppointmentGroupByPayload<T extends AppointmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppointmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppointmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
            : GetScalarType<T[P], AppointmentGroupByOutputType[P]>
        }
      >
    >


  export type AppointmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    title?: boolean
    description?: boolean
    date?: boolean
    time?: boolean
    type?: boolean
    status?: boolean
    location?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    title?: boolean
    description?: boolean
    date?: boolean
    time?: boolean
    type?: boolean
    status?: boolean
    location?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appointment"]>

  export type AppointmentSelectScalar = {
    id?: boolean
    patientId?: boolean
    title?: boolean
    description?: boolean
    date?: boolean
    time?: boolean
    type?: boolean
    status?: boolean
    location?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AppointmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type AppointmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }

  export type $AppointmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Appointment"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      title: string
      description: string | null
      date: Date
      time: string
      type: $Enums.AppointmentType
      status: $Enums.AppointmentStatus
      location: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["appointment"]>
    composites: {}
  }

  type AppointmentGetPayload<S extends boolean | null | undefined | AppointmentDefaultArgs> = $Result.GetResult<Prisma.$AppointmentPayload, S>

  type AppointmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AppointmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AppointmentCountAggregateInputType | true
    }

  export interface AppointmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Appointment'], meta: { name: 'Appointment' } }
    /**
     * Find zero or one Appointment that matches the filter.
     * @param {AppointmentFindUniqueArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AppointmentFindUniqueArgs>(args: SelectSubset<T, AppointmentFindUniqueArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Appointment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AppointmentFindUniqueOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AppointmentFindUniqueOrThrowArgs>(args: SelectSubset<T, AppointmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Appointment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AppointmentFindFirstArgs>(args?: SelectSubset<T, AppointmentFindFirstArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Appointment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindFirstOrThrowArgs} args - Arguments to find a Appointment
     * @example
     * // Get one Appointment
     * const appointment = await prisma.appointment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AppointmentFindFirstOrThrowArgs>(args?: SelectSubset<T, AppointmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Appointments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Appointments
     * const appointments = await prisma.appointment.findMany()
     * 
     * // Get first 10 Appointments
     * const appointments = await prisma.appointment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appointmentWithIdOnly = await prisma.appointment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AppointmentFindManyArgs>(args?: SelectSubset<T, AppointmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Appointment.
     * @param {AppointmentCreateArgs} args - Arguments to create a Appointment.
     * @example
     * // Create one Appointment
     * const Appointment = await prisma.appointment.create({
     *   data: {
     *     // ... data to create a Appointment
     *   }
     * })
     * 
     */
    create<T extends AppointmentCreateArgs>(args: SelectSubset<T, AppointmentCreateArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Appointments.
     * @param {AppointmentCreateManyArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointment = await prisma.appointment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AppointmentCreateManyArgs>(args?: SelectSubset<T, AppointmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Appointments and returns the data saved in the database.
     * @param {AppointmentCreateManyAndReturnArgs} args - Arguments to create many Appointments.
     * @example
     * // Create many Appointments
     * const appointment = await prisma.appointment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Appointments and only return the `id`
     * const appointmentWithIdOnly = await prisma.appointment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AppointmentCreateManyAndReturnArgs>(args?: SelectSubset<T, AppointmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Appointment.
     * @param {AppointmentDeleteArgs} args - Arguments to delete one Appointment.
     * @example
     * // Delete one Appointment
     * const Appointment = await prisma.appointment.delete({
     *   where: {
     *     // ... filter to delete one Appointment
     *   }
     * })
     * 
     */
    delete<T extends AppointmentDeleteArgs>(args: SelectSubset<T, AppointmentDeleteArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Appointment.
     * @param {AppointmentUpdateArgs} args - Arguments to update one Appointment.
     * @example
     * // Update one Appointment
     * const appointment = await prisma.appointment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AppointmentUpdateArgs>(args: SelectSubset<T, AppointmentUpdateArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Appointments.
     * @param {AppointmentDeleteManyArgs} args - Arguments to filter Appointments to delete.
     * @example
     * // Delete a few Appointments
     * const { count } = await prisma.appointment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AppointmentDeleteManyArgs>(args?: SelectSubset<T, AppointmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Appointments
     * const appointment = await prisma.appointment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AppointmentUpdateManyArgs>(args: SelectSubset<T, AppointmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Appointment.
     * @param {AppointmentUpsertArgs} args - Arguments to update or create a Appointment.
     * @example
     * // Update or create a Appointment
     * const appointment = await prisma.appointment.upsert({
     *   create: {
     *     // ... data to create a Appointment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Appointment we want to update
     *   }
     * })
     */
    upsert<T extends AppointmentUpsertArgs>(args: SelectSubset<T, AppointmentUpsertArgs<ExtArgs>>): Prisma__AppointmentClient<$Result.GetResult<Prisma.$AppointmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Appointments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentCountArgs} args - Arguments to filter Appointments to count.
     * @example
     * // Count the number of Appointments
     * const count = await prisma.appointment.count({
     *   where: {
     *     // ... the filter for the Appointments we want to count
     *   }
     * })
    **/
    count<T extends AppointmentCountArgs>(
      args?: Subset<T, AppointmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppointmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppointmentAggregateArgs>(args: Subset<T, AppointmentAggregateArgs>): Prisma.PrismaPromise<GetAppointmentAggregateType<T>>

    /**
     * Group by Appointment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppointmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppointmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppointmentGroupByArgs['orderBy'] }
        : { orderBy?: AppointmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppointmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppointmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Appointment model
   */
  readonly fields: AppointmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Appointment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppointmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Appointment model
   */ 
  interface AppointmentFieldRefs {
    readonly id: FieldRef<"Appointment", 'String'>
    readonly patientId: FieldRef<"Appointment", 'String'>
    readonly title: FieldRef<"Appointment", 'String'>
    readonly description: FieldRef<"Appointment", 'String'>
    readonly date: FieldRef<"Appointment", 'DateTime'>
    readonly time: FieldRef<"Appointment", 'String'>
    readonly type: FieldRef<"Appointment", 'AppointmentType'>
    readonly status: FieldRef<"Appointment", 'AppointmentStatus'>
    readonly location: FieldRef<"Appointment", 'String'>
    readonly notes: FieldRef<"Appointment", 'String'>
    readonly createdAt: FieldRef<"Appointment", 'DateTime'>
    readonly updatedAt: FieldRef<"Appointment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Appointment findUnique
   */
  export type AppointmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment findUniqueOrThrow
   */
  export type AppointmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment findFirst
   */
  export type AppointmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment findFirstOrThrow
   */
  export type AppointmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointment to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Appointments.
     */
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment findMany
   */
  export type AppointmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter, which Appointments to fetch.
     */
    where?: AppointmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Appointments to fetch.
     */
    orderBy?: AppointmentOrderByWithRelationInput | AppointmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Appointments.
     */
    cursor?: AppointmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Appointments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Appointments.
     */
    skip?: number
    distinct?: AppointmentScalarFieldEnum | AppointmentScalarFieldEnum[]
  }

  /**
   * Appointment create
   */
  export type AppointmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Appointment.
     */
    data: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
  }

  /**
   * Appointment createMany
   */
  export type AppointmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Appointments.
     */
    data: AppointmentCreateManyInput | AppointmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Appointment createManyAndReturn
   */
  export type AppointmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Appointments.
     */
    data: AppointmentCreateManyInput | AppointmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Appointment update
   */
  export type AppointmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Appointment.
     */
    data: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
    /**
     * Choose, which Appointment to update.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment updateMany
   */
  export type AppointmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Appointments.
     */
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyInput>
    /**
     * Filter which Appointments to update
     */
    where?: AppointmentWhereInput
  }

  /**
   * Appointment upsert
   */
  export type AppointmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Appointment to update in case it exists.
     */
    where: AppointmentWhereUniqueInput
    /**
     * In case the Appointment found by the `where` argument doesn't exist, create a new Appointment with this data.
     */
    create: XOR<AppointmentCreateInput, AppointmentUncheckedCreateInput>
    /**
     * In case the Appointment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppointmentUpdateInput, AppointmentUncheckedUpdateInput>
  }

  /**
   * Appointment delete
   */
  export type AppointmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
    /**
     * Filter which Appointment to delete.
     */
    where: AppointmentWhereUniqueInput
  }

  /**
   * Appointment deleteMany
   */
  export type AppointmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Appointments to delete
     */
    where?: AppointmentWhereInput
  }

  /**
   * Appointment without action
   */
  export type AppointmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Appointment
     */
    select?: AppointmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppointmentInclude<ExtArgs> | null
  }


  /**
   * Model MedicationLog
   */

  export type AggregateMedicationLog = {
    _count: MedicationLogCountAggregateOutputType | null
    _min: MedicationLogMinAggregateOutputType | null
    _max: MedicationLogMaxAggregateOutputType | null
  }

  export type MedicationLogMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    contentId: string | null
    takenAt: Date | null
    scheduledTime: string | null
    createdAt: Date | null
  }

  export type MedicationLogMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    contentId: string | null
    takenAt: Date | null
    scheduledTime: string | null
    createdAt: Date | null
  }

  export type MedicationLogCountAggregateOutputType = {
    id: number
    patientId: number
    contentId: number
    takenAt: number
    scheduledTime: number
    createdAt: number
    _all: number
  }


  export type MedicationLogMinAggregateInputType = {
    id?: true
    patientId?: true
    contentId?: true
    takenAt?: true
    scheduledTime?: true
    createdAt?: true
  }

  export type MedicationLogMaxAggregateInputType = {
    id?: true
    patientId?: true
    contentId?: true
    takenAt?: true
    scheduledTime?: true
    createdAt?: true
  }

  export type MedicationLogCountAggregateInputType = {
    id?: true
    patientId?: true
    contentId?: true
    takenAt?: true
    scheduledTime?: true
    createdAt?: true
    _all?: true
  }

  export type MedicationLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicationLog to aggregate.
     */
    where?: MedicationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicationLogs to fetch.
     */
    orderBy?: MedicationLogOrderByWithRelationInput | MedicationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MedicationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MedicationLogs
    **/
    _count?: true | MedicationLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MedicationLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MedicationLogMaxAggregateInputType
  }

  export type GetMedicationLogAggregateType<T extends MedicationLogAggregateArgs> = {
        [P in keyof T & keyof AggregateMedicationLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMedicationLog[P]>
      : GetScalarType<T[P], AggregateMedicationLog[P]>
  }




  export type MedicationLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MedicationLogWhereInput
    orderBy?: MedicationLogOrderByWithAggregationInput | MedicationLogOrderByWithAggregationInput[]
    by: MedicationLogScalarFieldEnum[] | MedicationLogScalarFieldEnum
    having?: MedicationLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MedicationLogCountAggregateInputType | true
    _min?: MedicationLogMinAggregateInputType
    _max?: MedicationLogMaxAggregateInputType
  }

  export type MedicationLogGroupByOutputType = {
    id: string
    patientId: string
    contentId: string
    takenAt: Date
    scheduledTime: string
    createdAt: Date
    _count: MedicationLogCountAggregateOutputType | null
    _min: MedicationLogMinAggregateOutputType | null
    _max: MedicationLogMaxAggregateOutputType | null
  }

  type GetMedicationLogGroupByPayload<T extends MedicationLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MedicationLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MedicationLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MedicationLogGroupByOutputType[P]>
            : GetScalarType<T[P], MedicationLogGroupByOutputType[P]>
        }
      >
    >


  export type MedicationLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    contentId?: boolean
    takenAt?: boolean
    scheduledTime?: boolean
    createdAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicationLog"]>

  export type MedicationLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    contentId?: boolean
    takenAt?: boolean
    scheduledTime?: boolean
    createdAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["medicationLog"]>

  export type MedicationLogSelectScalar = {
    id?: boolean
    patientId?: boolean
    contentId?: boolean
    takenAt?: boolean
    scheduledTime?: boolean
    createdAt?: boolean
  }

  export type MedicationLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type MedicationLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }

  export type $MedicationLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MedicationLog"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      contentId: string
      takenAt: Date
      scheduledTime: string
      createdAt: Date
    }, ExtArgs["result"]["medicationLog"]>
    composites: {}
  }

  type MedicationLogGetPayload<S extends boolean | null | undefined | MedicationLogDefaultArgs> = $Result.GetResult<Prisma.$MedicationLogPayload, S>

  type MedicationLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<MedicationLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: MedicationLogCountAggregateInputType | true
    }

  export interface MedicationLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MedicationLog'], meta: { name: 'MedicationLog' } }
    /**
     * Find zero or one MedicationLog that matches the filter.
     * @param {MedicationLogFindUniqueArgs} args - Arguments to find a MedicationLog
     * @example
     * // Get one MedicationLog
     * const medicationLog = await prisma.medicationLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MedicationLogFindUniqueArgs>(args: SelectSubset<T, MedicationLogFindUniqueArgs<ExtArgs>>): Prisma__MedicationLogClient<$Result.GetResult<Prisma.$MedicationLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one MedicationLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {MedicationLogFindUniqueOrThrowArgs} args - Arguments to find a MedicationLog
     * @example
     * // Get one MedicationLog
     * const medicationLog = await prisma.medicationLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MedicationLogFindUniqueOrThrowArgs>(args: SelectSubset<T, MedicationLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MedicationLogClient<$Result.GetResult<Prisma.$MedicationLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first MedicationLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationLogFindFirstArgs} args - Arguments to find a MedicationLog
     * @example
     * // Get one MedicationLog
     * const medicationLog = await prisma.medicationLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MedicationLogFindFirstArgs>(args?: SelectSubset<T, MedicationLogFindFirstArgs<ExtArgs>>): Prisma__MedicationLogClient<$Result.GetResult<Prisma.$MedicationLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first MedicationLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationLogFindFirstOrThrowArgs} args - Arguments to find a MedicationLog
     * @example
     * // Get one MedicationLog
     * const medicationLog = await prisma.medicationLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MedicationLogFindFirstOrThrowArgs>(args?: SelectSubset<T, MedicationLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__MedicationLogClient<$Result.GetResult<Prisma.$MedicationLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more MedicationLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MedicationLogs
     * const medicationLogs = await prisma.medicationLog.findMany()
     * 
     * // Get first 10 MedicationLogs
     * const medicationLogs = await prisma.medicationLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const medicationLogWithIdOnly = await prisma.medicationLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MedicationLogFindManyArgs>(args?: SelectSubset<T, MedicationLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicationLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a MedicationLog.
     * @param {MedicationLogCreateArgs} args - Arguments to create a MedicationLog.
     * @example
     * // Create one MedicationLog
     * const MedicationLog = await prisma.medicationLog.create({
     *   data: {
     *     // ... data to create a MedicationLog
     *   }
     * })
     * 
     */
    create<T extends MedicationLogCreateArgs>(args: SelectSubset<T, MedicationLogCreateArgs<ExtArgs>>): Prisma__MedicationLogClient<$Result.GetResult<Prisma.$MedicationLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many MedicationLogs.
     * @param {MedicationLogCreateManyArgs} args - Arguments to create many MedicationLogs.
     * @example
     * // Create many MedicationLogs
     * const medicationLog = await prisma.medicationLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MedicationLogCreateManyArgs>(args?: SelectSubset<T, MedicationLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MedicationLogs and returns the data saved in the database.
     * @param {MedicationLogCreateManyAndReturnArgs} args - Arguments to create many MedicationLogs.
     * @example
     * // Create many MedicationLogs
     * const medicationLog = await prisma.medicationLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MedicationLogs and only return the `id`
     * const medicationLogWithIdOnly = await prisma.medicationLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MedicationLogCreateManyAndReturnArgs>(args?: SelectSubset<T, MedicationLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MedicationLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a MedicationLog.
     * @param {MedicationLogDeleteArgs} args - Arguments to delete one MedicationLog.
     * @example
     * // Delete one MedicationLog
     * const MedicationLog = await prisma.medicationLog.delete({
     *   where: {
     *     // ... filter to delete one MedicationLog
     *   }
     * })
     * 
     */
    delete<T extends MedicationLogDeleteArgs>(args: SelectSubset<T, MedicationLogDeleteArgs<ExtArgs>>): Prisma__MedicationLogClient<$Result.GetResult<Prisma.$MedicationLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one MedicationLog.
     * @param {MedicationLogUpdateArgs} args - Arguments to update one MedicationLog.
     * @example
     * // Update one MedicationLog
     * const medicationLog = await prisma.medicationLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MedicationLogUpdateArgs>(args: SelectSubset<T, MedicationLogUpdateArgs<ExtArgs>>): Prisma__MedicationLogClient<$Result.GetResult<Prisma.$MedicationLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more MedicationLogs.
     * @param {MedicationLogDeleteManyArgs} args - Arguments to filter MedicationLogs to delete.
     * @example
     * // Delete a few MedicationLogs
     * const { count } = await prisma.medicationLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MedicationLogDeleteManyArgs>(args?: SelectSubset<T, MedicationLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MedicationLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MedicationLogs
     * const medicationLog = await prisma.medicationLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MedicationLogUpdateManyArgs>(args: SelectSubset<T, MedicationLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one MedicationLog.
     * @param {MedicationLogUpsertArgs} args - Arguments to update or create a MedicationLog.
     * @example
     * // Update or create a MedicationLog
     * const medicationLog = await prisma.medicationLog.upsert({
     *   create: {
     *     // ... data to create a MedicationLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MedicationLog we want to update
     *   }
     * })
     */
    upsert<T extends MedicationLogUpsertArgs>(args: SelectSubset<T, MedicationLogUpsertArgs<ExtArgs>>): Prisma__MedicationLogClient<$Result.GetResult<Prisma.$MedicationLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of MedicationLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationLogCountArgs} args - Arguments to filter MedicationLogs to count.
     * @example
     * // Count the number of MedicationLogs
     * const count = await prisma.medicationLog.count({
     *   where: {
     *     // ... the filter for the MedicationLogs we want to count
     *   }
     * })
    **/
    count<T extends MedicationLogCountArgs>(
      args?: Subset<T, MedicationLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MedicationLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MedicationLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MedicationLogAggregateArgs>(args: Subset<T, MedicationLogAggregateArgs>): Prisma.PrismaPromise<GetMedicationLogAggregateType<T>>

    /**
     * Group by MedicationLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MedicationLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MedicationLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MedicationLogGroupByArgs['orderBy'] }
        : { orderBy?: MedicationLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MedicationLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMedicationLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MedicationLog model
   */
  readonly fields: MedicationLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MedicationLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MedicationLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MedicationLog model
   */ 
  interface MedicationLogFieldRefs {
    readonly id: FieldRef<"MedicationLog", 'String'>
    readonly patientId: FieldRef<"MedicationLog", 'String'>
    readonly contentId: FieldRef<"MedicationLog", 'String'>
    readonly takenAt: FieldRef<"MedicationLog", 'DateTime'>
    readonly scheduledTime: FieldRef<"MedicationLog", 'String'>
    readonly createdAt: FieldRef<"MedicationLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MedicationLog findUnique
   */
  export type MedicationLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationLog
     */
    select?: MedicationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationLogInclude<ExtArgs> | null
    /**
     * Filter, which MedicationLog to fetch.
     */
    where: MedicationLogWhereUniqueInput
  }

  /**
   * MedicationLog findUniqueOrThrow
   */
  export type MedicationLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationLog
     */
    select?: MedicationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationLogInclude<ExtArgs> | null
    /**
     * Filter, which MedicationLog to fetch.
     */
    where: MedicationLogWhereUniqueInput
  }

  /**
   * MedicationLog findFirst
   */
  export type MedicationLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationLog
     */
    select?: MedicationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationLogInclude<ExtArgs> | null
    /**
     * Filter, which MedicationLog to fetch.
     */
    where?: MedicationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicationLogs to fetch.
     */
    orderBy?: MedicationLogOrderByWithRelationInput | MedicationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicationLogs.
     */
    cursor?: MedicationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicationLogs.
     */
    distinct?: MedicationLogScalarFieldEnum | MedicationLogScalarFieldEnum[]
  }

  /**
   * MedicationLog findFirstOrThrow
   */
  export type MedicationLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationLog
     */
    select?: MedicationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationLogInclude<ExtArgs> | null
    /**
     * Filter, which MedicationLog to fetch.
     */
    where?: MedicationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicationLogs to fetch.
     */
    orderBy?: MedicationLogOrderByWithRelationInput | MedicationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MedicationLogs.
     */
    cursor?: MedicationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicationLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MedicationLogs.
     */
    distinct?: MedicationLogScalarFieldEnum | MedicationLogScalarFieldEnum[]
  }

  /**
   * MedicationLog findMany
   */
  export type MedicationLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationLog
     */
    select?: MedicationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationLogInclude<ExtArgs> | null
    /**
     * Filter, which MedicationLogs to fetch.
     */
    where?: MedicationLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MedicationLogs to fetch.
     */
    orderBy?: MedicationLogOrderByWithRelationInput | MedicationLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MedicationLogs.
     */
    cursor?: MedicationLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MedicationLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MedicationLogs.
     */
    skip?: number
    distinct?: MedicationLogScalarFieldEnum | MedicationLogScalarFieldEnum[]
  }

  /**
   * MedicationLog create
   */
  export type MedicationLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationLog
     */
    select?: MedicationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationLogInclude<ExtArgs> | null
    /**
     * The data needed to create a MedicationLog.
     */
    data: XOR<MedicationLogCreateInput, MedicationLogUncheckedCreateInput>
  }

  /**
   * MedicationLog createMany
   */
  export type MedicationLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MedicationLogs.
     */
    data: MedicationLogCreateManyInput | MedicationLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MedicationLog createManyAndReturn
   */
  export type MedicationLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationLog
     */
    select?: MedicationLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many MedicationLogs.
     */
    data: MedicationLogCreateManyInput | MedicationLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MedicationLog update
   */
  export type MedicationLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationLog
     */
    select?: MedicationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationLogInclude<ExtArgs> | null
    /**
     * The data needed to update a MedicationLog.
     */
    data: XOR<MedicationLogUpdateInput, MedicationLogUncheckedUpdateInput>
    /**
     * Choose, which MedicationLog to update.
     */
    where: MedicationLogWhereUniqueInput
  }

  /**
   * MedicationLog updateMany
   */
  export type MedicationLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MedicationLogs.
     */
    data: XOR<MedicationLogUpdateManyMutationInput, MedicationLogUncheckedUpdateManyInput>
    /**
     * Filter which MedicationLogs to update
     */
    where?: MedicationLogWhereInput
  }

  /**
   * MedicationLog upsert
   */
  export type MedicationLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationLog
     */
    select?: MedicationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationLogInclude<ExtArgs> | null
    /**
     * The filter to search for the MedicationLog to update in case it exists.
     */
    where: MedicationLogWhereUniqueInput
    /**
     * In case the MedicationLog found by the `where` argument doesn't exist, create a new MedicationLog with this data.
     */
    create: XOR<MedicationLogCreateInput, MedicationLogUncheckedCreateInput>
    /**
     * In case the MedicationLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MedicationLogUpdateInput, MedicationLogUncheckedUpdateInput>
  }

  /**
   * MedicationLog delete
   */
  export type MedicationLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationLog
     */
    select?: MedicationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationLogInclude<ExtArgs> | null
    /**
     * Filter which MedicationLog to delete.
     */
    where: MedicationLogWhereUniqueInput
  }

  /**
   * MedicationLog deleteMany
   */
  export type MedicationLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MedicationLogs to delete
     */
    where?: MedicationLogWhereInput
  }

  /**
   * MedicationLog without action
   */
  export type MedicationLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MedicationLog
     */
    select?: MedicationLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MedicationLogInclude<ExtArgs> | null
  }


  /**
   * Model Exam
   */

  export type AggregateExam = {
    _count: ExamCountAggregateOutputType | null
    _avg: ExamAvgAggregateOutputType | null
    _sum: ExamSumAggregateOutputType | null
    _min: ExamMinAggregateOutputType | null
    _max: ExamMaxAggregateOutputType | null
  }

  export type ExamAvgAggregateOutputType = {
    fileSize: number | null
  }

  export type ExamSumAggregateOutputType = {
    fileSize: number | null
  }

  export type ExamMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    title: string | null
    type: string | null
    date: Date | null
    status: $Enums.ExamStatus | null
    fileUrl: string | null
    fileName: string | null
    fileSize: number | null
    mimeType: string | null
    notes: string | null
    result: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExamMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    title: string | null
    type: string | null
    date: Date | null
    status: $Enums.ExamStatus | null
    fileUrl: string | null
    fileName: string | null
    fileSize: number | null
    mimeType: string | null
    notes: string | null
    result: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ExamCountAggregateOutputType = {
    id: number
    patientId: number
    title: number
    type: number
    date: number
    status: number
    fileUrl: number
    fileName: number
    fileSize: number
    mimeType: number
    notes: number
    result: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ExamAvgAggregateInputType = {
    fileSize?: true
  }

  export type ExamSumAggregateInputType = {
    fileSize?: true
  }

  export type ExamMinAggregateInputType = {
    id?: true
    patientId?: true
    title?: true
    type?: true
    date?: true
    status?: true
    fileUrl?: true
    fileName?: true
    fileSize?: true
    mimeType?: true
    notes?: true
    result?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExamMaxAggregateInputType = {
    id?: true
    patientId?: true
    title?: true
    type?: true
    date?: true
    status?: true
    fileUrl?: true
    fileName?: true
    fileSize?: true
    mimeType?: true
    notes?: true
    result?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ExamCountAggregateInputType = {
    id?: true
    patientId?: true
    title?: true
    type?: true
    date?: true
    status?: true
    fileUrl?: true
    fileName?: true
    fileSize?: true
    mimeType?: true
    notes?: true
    result?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ExamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exam to aggregate.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Exams
    **/
    _count?: true | ExamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExamMaxAggregateInputType
  }

  export type GetExamAggregateType<T extends ExamAggregateArgs> = {
        [P in keyof T & keyof AggregateExam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExam[P]>
      : GetScalarType<T[P], AggregateExam[P]>
  }




  export type ExamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExamWhereInput
    orderBy?: ExamOrderByWithAggregationInput | ExamOrderByWithAggregationInput[]
    by: ExamScalarFieldEnum[] | ExamScalarFieldEnum
    having?: ExamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExamCountAggregateInputType | true
    _avg?: ExamAvgAggregateInputType
    _sum?: ExamSumAggregateInputType
    _min?: ExamMinAggregateInputType
    _max?: ExamMaxAggregateInputType
  }

  export type ExamGroupByOutputType = {
    id: string
    patientId: string
    title: string
    type: string
    date: Date
    status: $Enums.ExamStatus
    fileUrl: string | null
    fileName: string | null
    fileSize: number | null
    mimeType: string | null
    notes: string | null
    result: string | null
    createdAt: Date
    updatedAt: Date
    _count: ExamCountAggregateOutputType | null
    _avg: ExamAvgAggregateOutputType | null
    _sum: ExamSumAggregateOutputType | null
    _min: ExamMinAggregateOutputType | null
    _max: ExamMaxAggregateOutputType | null
  }

  type GetExamGroupByPayload<T extends ExamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExamGroupByOutputType[P]>
            : GetScalarType<T[P], ExamGroupByOutputType[P]>
        }
      >
    >


  export type ExamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    title?: boolean
    type?: boolean
    date?: boolean
    status?: boolean
    fileUrl?: boolean
    fileName?: boolean
    fileSize?: boolean
    mimeType?: boolean
    notes?: boolean
    result?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exam"]>

  export type ExamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    title?: boolean
    type?: boolean
    date?: boolean
    status?: boolean
    fileUrl?: boolean
    fileName?: boolean
    fileSize?: boolean
    mimeType?: boolean
    notes?: boolean
    result?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["exam"]>

  export type ExamSelectScalar = {
    id?: boolean
    patientId?: boolean
    title?: boolean
    type?: boolean
    date?: boolean
    status?: boolean
    fileUrl?: boolean
    fileName?: boolean
    fileSize?: boolean
    mimeType?: boolean
    notes?: boolean
    result?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ExamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }
  export type ExamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }

  export type $ExamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Exam"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      title: string
      type: string
      date: Date
      status: $Enums.ExamStatus
      fileUrl: string | null
      fileName: string | null
      fileSize: number | null
      mimeType: string | null
      notes: string | null
      result: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["exam"]>
    composites: {}
  }

  type ExamGetPayload<S extends boolean | null | undefined | ExamDefaultArgs> = $Result.GetResult<Prisma.$ExamPayload, S>

  type ExamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExamFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExamCountAggregateInputType | true
    }

  export interface ExamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Exam'], meta: { name: 'Exam' } }
    /**
     * Find zero or one Exam that matches the filter.
     * @param {ExamFindUniqueArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExamFindUniqueArgs>(args: SelectSubset<T, ExamFindUniqueArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Exam that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExamFindUniqueOrThrowArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExamFindUniqueOrThrowArgs>(args: SelectSubset<T, ExamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Exam that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamFindFirstArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExamFindFirstArgs>(args?: SelectSubset<T, ExamFindFirstArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Exam that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamFindFirstOrThrowArgs} args - Arguments to find a Exam
     * @example
     * // Get one Exam
     * const exam = await prisma.exam.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExamFindFirstOrThrowArgs>(args?: SelectSubset<T, ExamFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Exams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Exams
     * const exams = await prisma.exam.findMany()
     * 
     * // Get first 10 Exams
     * const exams = await prisma.exam.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const examWithIdOnly = await prisma.exam.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExamFindManyArgs>(args?: SelectSubset<T, ExamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Exam.
     * @param {ExamCreateArgs} args - Arguments to create a Exam.
     * @example
     * // Create one Exam
     * const Exam = await prisma.exam.create({
     *   data: {
     *     // ... data to create a Exam
     *   }
     * })
     * 
     */
    create<T extends ExamCreateArgs>(args: SelectSubset<T, ExamCreateArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Exams.
     * @param {ExamCreateManyArgs} args - Arguments to create many Exams.
     * @example
     * // Create many Exams
     * const exam = await prisma.exam.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExamCreateManyArgs>(args?: SelectSubset<T, ExamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Exams and returns the data saved in the database.
     * @param {ExamCreateManyAndReturnArgs} args - Arguments to create many Exams.
     * @example
     * // Create many Exams
     * const exam = await prisma.exam.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Exams and only return the `id`
     * const examWithIdOnly = await prisma.exam.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExamCreateManyAndReturnArgs>(args?: SelectSubset<T, ExamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Exam.
     * @param {ExamDeleteArgs} args - Arguments to delete one Exam.
     * @example
     * // Delete one Exam
     * const Exam = await prisma.exam.delete({
     *   where: {
     *     // ... filter to delete one Exam
     *   }
     * })
     * 
     */
    delete<T extends ExamDeleteArgs>(args: SelectSubset<T, ExamDeleteArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Exam.
     * @param {ExamUpdateArgs} args - Arguments to update one Exam.
     * @example
     * // Update one Exam
     * const exam = await prisma.exam.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExamUpdateArgs>(args: SelectSubset<T, ExamUpdateArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Exams.
     * @param {ExamDeleteManyArgs} args - Arguments to filter Exams to delete.
     * @example
     * // Delete a few Exams
     * const { count } = await prisma.exam.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExamDeleteManyArgs>(args?: SelectSubset<T, ExamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Exams
     * const exam = await prisma.exam.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExamUpdateManyArgs>(args: SelectSubset<T, ExamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Exam.
     * @param {ExamUpsertArgs} args - Arguments to update or create a Exam.
     * @example
     * // Update or create a Exam
     * const exam = await prisma.exam.upsert({
     *   create: {
     *     // ... data to create a Exam
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Exam we want to update
     *   }
     * })
     */
    upsert<T extends ExamUpsertArgs>(args: SelectSubset<T, ExamUpsertArgs<ExtArgs>>): Prisma__ExamClient<$Result.GetResult<Prisma.$ExamPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Exams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamCountArgs} args - Arguments to filter Exams to count.
     * @example
     * // Count the number of Exams
     * const count = await prisma.exam.count({
     *   where: {
     *     // ... the filter for the Exams we want to count
     *   }
     * })
    **/
    count<T extends ExamCountArgs>(
      args?: Subset<T, ExamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Exam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExamAggregateArgs>(args: Subset<T, ExamAggregateArgs>): Prisma.PrismaPromise<GetExamAggregateType<T>>

    /**
     * Group by Exam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExamGroupByArgs['orderBy'] }
        : { orderBy?: ExamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Exam model
   */
  readonly fields: ExamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Exam.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Exam model
   */ 
  interface ExamFieldRefs {
    readonly id: FieldRef<"Exam", 'String'>
    readonly patientId: FieldRef<"Exam", 'String'>
    readonly title: FieldRef<"Exam", 'String'>
    readonly type: FieldRef<"Exam", 'String'>
    readonly date: FieldRef<"Exam", 'DateTime'>
    readonly status: FieldRef<"Exam", 'ExamStatus'>
    readonly fileUrl: FieldRef<"Exam", 'String'>
    readonly fileName: FieldRef<"Exam", 'String'>
    readonly fileSize: FieldRef<"Exam", 'Int'>
    readonly mimeType: FieldRef<"Exam", 'String'>
    readonly notes: FieldRef<"Exam", 'String'>
    readonly result: FieldRef<"Exam", 'String'>
    readonly createdAt: FieldRef<"Exam", 'DateTime'>
    readonly updatedAt: FieldRef<"Exam", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Exam findUnique
   */
  export type ExamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam findUniqueOrThrow
   */
  export type ExamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam findFirst
   */
  export type ExamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exams.
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exams.
     */
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Exam findFirstOrThrow
   */
  export type ExamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exam to fetch.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Exams.
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Exams.
     */
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Exam findMany
   */
  export type ExamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter, which Exams to fetch.
     */
    where?: ExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Exams to fetch.
     */
    orderBy?: ExamOrderByWithRelationInput | ExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Exams.
     */
    cursor?: ExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Exams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Exams.
     */
    skip?: number
    distinct?: ExamScalarFieldEnum | ExamScalarFieldEnum[]
  }

  /**
   * Exam create
   */
  export type ExamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * The data needed to create a Exam.
     */
    data: XOR<ExamCreateInput, ExamUncheckedCreateInput>
  }

  /**
   * Exam createMany
   */
  export type ExamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Exams.
     */
    data: ExamCreateManyInput | ExamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Exam createManyAndReturn
   */
  export type ExamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Exams.
     */
    data: ExamCreateManyInput | ExamCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Exam update
   */
  export type ExamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * The data needed to update a Exam.
     */
    data: XOR<ExamUpdateInput, ExamUncheckedUpdateInput>
    /**
     * Choose, which Exam to update.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam updateMany
   */
  export type ExamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Exams.
     */
    data: XOR<ExamUpdateManyMutationInput, ExamUncheckedUpdateManyInput>
    /**
     * Filter which Exams to update
     */
    where?: ExamWhereInput
  }

  /**
   * Exam upsert
   */
  export type ExamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * The filter to search for the Exam to update in case it exists.
     */
    where: ExamWhereUniqueInput
    /**
     * In case the Exam found by the `where` argument doesn't exist, create a new Exam with this data.
     */
    create: XOR<ExamCreateInput, ExamUncheckedCreateInput>
    /**
     * In case the Exam was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExamUpdateInput, ExamUncheckedUpdateInput>
  }

  /**
   * Exam delete
   */
  export type ExamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
    /**
     * Filter which Exam to delete.
     */
    where: ExamWhereUniqueInput
  }

  /**
   * Exam deleteMany
   */
  export type ExamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Exams to delete
     */
    where?: ExamWhereInput
  }

  /**
   * Exam without action
   */
  export type ExamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Exam
     */
    select?: ExamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExamInclude<ExtArgs> | null
  }


  /**
   * Model SystemContentTemplate
   */

  export type AggregateSystemContentTemplate = {
    _count: SystemContentTemplateCountAggregateOutputType | null
    _avg: SystemContentTemplateAvgAggregateOutputType | null
    _sum: SystemContentTemplateSumAggregateOutputType | null
    _min: SystemContentTemplateMinAggregateOutputType | null
    _max: SystemContentTemplateMaxAggregateOutputType | null
  }

  export type SystemContentTemplateAvgAggregateOutputType = {
    validFromDay: number | null
    validUntilDay: number | null
    sortOrder: number | null
  }

  export type SystemContentTemplateSumAggregateOutputType = {
    validFromDay: number | null
    validUntilDay: number | null
    sortOrder: number | null
  }

  export type SystemContentTemplateMinAggregateOutputType = {
    id: string | null
    type: $Enums.ContentType | null
    category: $Enums.ContentCategory | null
    title: string | null
    description: string | null
    validFromDay: number | null
    validUntilDay: number | null
    sortOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemContentTemplateMaxAggregateOutputType = {
    id: string | null
    type: $Enums.ContentType | null
    category: $Enums.ContentCategory | null
    title: string | null
    description: string | null
    validFromDay: number | null
    validUntilDay: number | null
    sortOrder: number | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemContentTemplateCountAggregateOutputType = {
    id: number
    type: number
    category: number
    title: number
    description: number
    validFromDay: number
    validUntilDay: number
    sortOrder: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SystemContentTemplateAvgAggregateInputType = {
    validFromDay?: true
    validUntilDay?: true
    sortOrder?: true
  }

  export type SystemContentTemplateSumAggregateInputType = {
    validFromDay?: true
    validUntilDay?: true
    sortOrder?: true
  }

  export type SystemContentTemplateMinAggregateInputType = {
    id?: true
    type?: true
    category?: true
    title?: true
    description?: true
    validFromDay?: true
    validUntilDay?: true
    sortOrder?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemContentTemplateMaxAggregateInputType = {
    id?: true
    type?: true
    category?: true
    title?: true
    description?: true
    validFromDay?: true
    validUntilDay?: true
    sortOrder?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemContentTemplateCountAggregateInputType = {
    id?: true
    type?: true
    category?: true
    title?: true
    description?: true
    validFromDay?: true
    validUntilDay?: true
    sortOrder?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SystemContentTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemContentTemplate to aggregate.
     */
    where?: SystemContentTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemContentTemplates to fetch.
     */
    orderBy?: SystemContentTemplateOrderByWithRelationInput | SystemContentTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemContentTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemContentTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemContentTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemContentTemplates
    **/
    _count?: true | SystemContentTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SystemContentTemplateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SystemContentTemplateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemContentTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemContentTemplateMaxAggregateInputType
  }

  export type GetSystemContentTemplateAggregateType<T extends SystemContentTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemContentTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemContentTemplate[P]>
      : GetScalarType<T[P], AggregateSystemContentTemplate[P]>
  }




  export type SystemContentTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemContentTemplateWhereInput
    orderBy?: SystemContentTemplateOrderByWithAggregationInput | SystemContentTemplateOrderByWithAggregationInput[]
    by: SystemContentTemplateScalarFieldEnum[] | SystemContentTemplateScalarFieldEnum
    having?: SystemContentTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemContentTemplateCountAggregateInputType | true
    _avg?: SystemContentTemplateAvgAggregateInputType
    _sum?: SystemContentTemplateSumAggregateInputType
    _min?: SystemContentTemplateMinAggregateInputType
    _max?: SystemContentTemplateMaxAggregateInputType
  }

  export type SystemContentTemplateGroupByOutputType = {
    id: string
    type: $Enums.ContentType
    category: $Enums.ContentCategory
    title: string
    description: string | null
    validFromDay: number | null
    validUntilDay: number | null
    sortOrder: number
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: SystemContentTemplateCountAggregateOutputType | null
    _avg: SystemContentTemplateAvgAggregateOutputType | null
    _sum: SystemContentTemplateSumAggregateOutputType | null
    _min: SystemContentTemplateMinAggregateOutputType | null
    _max: SystemContentTemplateMaxAggregateOutputType | null
  }

  type GetSystemContentTemplateGroupByPayload<T extends SystemContentTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemContentTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemContentTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemContentTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], SystemContentTemplateGroupByOutputType[P]>
        }
      >
    >


  export type SystemContentTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    category?: boolean
    title?: boolean
    description?: boolean
    validFromDay?: boolean
    validUntilDay?: boolean
    sortOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemContentTemplate"]>

  export type SystemContentTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    category?: boolean
    title?: boolean
    description?: boolean
    validFromDay?: boolean
    validUntilDay?: boolean
    sortOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemContentTemplate"]>

  export type SystemContentTemplateSelectScalar = {
    id?: boolean
    type?: boolean
    category?: boolean
    title?: boolean
    description?: boolean
    validFromDay?: boolean
    validUntilDay?: boolean
    sortOrder?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $SystemContentTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemContentTemplate"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.ContentType
      category: $Enums.ContentCategory
      title: string
      description: string | null
      validFromDay: number | null
      validUntilDay: number | null
      sortOrder: number
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["systemContentTemplate"]>
    composites: {}
  }

  type SystemContentTemplateGetPayload<S extends boolean | null | undefined | SystemContentTemplateDefaultArgs> = $Result.GetResult<Prisma.$SystemContentTemplatePayload, S>

  type SystemContentTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SystemContentTemplateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SystemContentTemplateCountAggregateInputType | true
    }

  export interface SystemContentTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemContentTemplate'], meta: { name: 'SystemContentTemplate' } }
    /**
     * Find zero or one SystemContentTemplate that matches the filter.
     * @param {SystemContentTemplateFindUniqueArgs} args - Arguments to find a SystemContentTemplate
     * @example
     * // Get one SystemContentTemplate
     * const systemContentTemplate = await prisma.systemContentTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemContentTemplateFindUniqueArgs>(args: SelectSubset<T, SystemContentTemplateFindUniqueArgs<ExtArgs>>): Prisma__SystemContentTemplateClient<$Result.GetResult<Prisma.$SystemContentTemplatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SystemContentTemplate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SystemContentTemplateFindUniqueOrThrowArgs} args - Arguments to find a SystemContentTemplate
     * @example
     * // Get one SystemContentTemplate
     * const systemContentTemplate = await prisma.systemContentTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemContentTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemContentTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemContentTemplateClient<$Result.GetResult<Prisma.$SystemContentTemplatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SystemContentTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemContentTemplateFindFirstArgs} args - Arguments to find a SystemContentTemplate
     * @example
     * // Get one SystemContentTemplate
     * const systemContentTemplate = await prisma.systemContentTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemContentTemplateFindFirstArgs>(args?: SelectSubset<T, SystemContentTemplateFindFirstArgs<ExtArgs>>): Prisma__SystemContentTemplateClient<$Result.GetResult<Prisma.$SystemContentTemplatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SystemContentTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemContentTemplateFindFirstOrThrowArgs} args - Arguments to find a SystemContentTemplate
     * @example
     * // Get one SystemContentTemplate
     * const systemContentTemplate = await prisma.systemContentTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemContentTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemContentTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemContentTemplateClient<$Result.GetResult<Prisma.$SystemContentTemplatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SystemContentTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemContentTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemContentTemplates
     * const systemContentTemplates = await prisma.systemContentTemplate.findMany()
     * 
     * // Get first 10 SystemContentTemplates
     * const systemContentTemplates = await prisma.systemContentTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemContentTemplateWithIdOnly = await prisma.systemContentTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemContentTemplateFindManyArgs>(args?: SelectSubset<T, SystemContentTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemContentTemplatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SystemContentTemplate.
     * @param {SystemContentTemplateCreateArgs} args - Arguments to create a SystemContentTemplate.
     * @example
     * // Create one SystemContentTemplate
     * const SystemContentTemplate = await prisma.systemContentTemplate.create({
     *   data: {
     *     // ... data to create a SystemContentTemplate
     *   }
     * })
     * 
     */
    create<T extends SystemContentTemplateCreateArgs>(args: SelectSubset<T, SystemContentTemplateCreateArgs<ExtArgs>>): Prisma__SystemContentTemplateClient<$Result.GetResult<Prisma.$SystemContentTemplatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SystemContentTemplates.
     * @param {SystemContentTemplateCreateManyArgs} args - Arguments to create many SystemContentTemplates.
     * @example
     * // Create many SystemContentTemplates
     * const systemContentTemplate = await prisma.systemContentTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemContentTemplateCreateManyArgs>(args?: SelectSubset<T, SystemContentTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemContentTemplates and returns the data saved in the database.
     * @param {SystemContentTemplateCreateManyAndReturnArgs} args - Arguments to create many SystemContentTemplates.
     * @example
     * // Create many SystemContentTemplates
     * const systemContentTemplate = await prisma.systemContentTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemContentTemplates and only return the `id`
     * const systemContentTemplateWithIdOnly = await prisma.systemContentTemplate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemContentTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemContentTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemContentTemplatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a SystemContentTemplate.
     * @param {SystemContentTemplateDeleteArgs} args - Arguments to delete one SystemContentTemplate.
     * @example
     * // Delete one SystemContentTemplate
     * const SystemContentTemplate = await prisma.systemContentTemplate.delete({
     *   where: {
     *     // ... filter to delete one SystemContentTemplate
     *   }
     * })
     * 
     */
    delete<T extends SystemContentTemplateDeleteArgs>(args: SelectSubset<T, SystemContentTemplateDeleteArgs<ExtArgs>>): Prisma__SystemContentTemplateClient<$Result.GetResult<Prisma.$SystemContentTemplatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SystemContentTemplate.
     * @param {SystemContentTemplateUpdateArgs} args - Arguments to update one SystemContentTemplate.
     * @example
     * // Update one SystemContentTemplate
     * const systemContentTemplate = await prisma.systemContentTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemContentTemplateUpdateArgs>(args: SelectSubset<T, SystemContentTemplateUpdateArgs<ExtArgs>>): Prisma__SystemContentTemplateClient<$Result.GetResult<Prisma.$SystemContentTemplatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SystemContentTemplates.
     * @param {SystemContentTemplateDeleteManyArgs} args - Arguments to filter SystemContentTemplates to delete.
     * @example
     * // Delete a few SystemContentTemplates
     * const { count } = await prisma.systemContentTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemContentTemplateDeleteManyArgs>(args?: SelectSubset<T, SystemContentTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemContentTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemContentTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemContentTemplates
     * const systemContentTemplate = await prisma.systemContentTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemContentTemplateUpdateManyArgs>(args: SelectSubset<T, SystemContentTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SystemContentTemplate.
     * @param {SystemContentTemplateUpsertArgs} args - Arguments to update or create a SystemContentTemplate.
     * @example
     * // Update or create a SystemContentTemplate
     * const systemContentTemplate = await prisma.systemContentTemplate.upsert({
     *   create: {
     *     // ... data to create a SystemContentTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemContentTemplate we want to update
     *   }
     * })
     */
    upsert<T extends SystemContentTemplateUpsertArgs>(args: SelectSubset<T, SystemContentTemplateUpsertArgs<ExtArgs>>): Prisma__SystemContentTemplateClient<$Result.GetResult<Prisma.$SystemContentTemplatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SystemContentTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemContentTemplateCountArgs} args - Arguments to filter SystemContentTemplates to count.
     * @example
     * // Count the number of SystemContentTemplates
     * const count = await prisma.systemContentTemplate.count({
     *   where: {
     *     // ... the filter for the SystemContentTemplates we want to count
     *   }
     * })
    **/
    count<T extends SystemContentTemplateCountArgs>(
      args?: Subset<T, SystemContentTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemContentTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemContentTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemContentTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemContentTemplateAggregateArgs>(args: Subset<T, SystemContentTemplateAggregateArgs>): Prisma.PrismaPromise<GetSystemContentTemplateAggregateType<T>>

    /**
     * Group by SystemContentTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemContentTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemContentTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemContentTemplateGroupByArgs['orderBy'] }
        : { orderBy?: SystemContentTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemContentTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemContentTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemContentTemplate model
   */
  readonly fields: SystemContentTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemContentTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemContentTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemContentTemplate model
   */ 
  interface SystemContentTemplateFieldRefs {
    readonly id: FieldRef<"SystemContentTemplate", 'String'>
    readonly type: FieldRef<"SystemContentTemplate", 'ContentType'>
    readonly category: FieldRef<"SystemContentTemplate", 'ContentCategory'>
    readonly title: FieldRef<"SystemContentTemplate", 'String'>
    readonly description: FieldRef<"SystemContentTemplate", 'String'>
    readonly validFromDay: FieldRef<"SystemContentTemplate", 'Int'>
    readonly validUntilDay: FieldRef<"SystemContentTemplate", 'Int'>
    readonly sortOrder: FieldRef<"SystemContentTemplate", 'Int'>
    readonly isActive: FieldRef<"SystemContentTemplate", 'Boolean'>
    readonly createdAt: FieldRef<"SystemContentTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"SystemContentTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemContentTemplate findUnique
   */
  export type SystemContentTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemContentTemplate
     */
    select?: SystemContentTemplateSelect<ExtArgs> | null
    /**
     * Filter, which SystemContentTemplate to fetch.
     */
    where: SystemContentTemplateWhereUniqueInput
  }

  /**
   * SystemContentTemplate findUniqueOrThrow
   */
  export type SystemContentTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemContentTemplate
     */
    select?: SystemContentTemplateSelect<ExtArgs> | null
    /**
     * Filter, which SystemContentTemplate to fetch.
     */
    where: SystemContentTemplateWhereUniqueInput
  }

  /**
   * SystemContentTemplate findFirst
   */
  export type SystemContentTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemContentTemplate
     */
    select?: SystemContentTemplateSelect<ExtArgs> | null
    /**
     * Filter, which SystemContentTemplate to fetch.
     */
    where?: SystemContentTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemContentTemplates to fetch.
     */
    orderBy?: SystemContentTemplateOrderByWithRelationInput | SystemContentTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemContentTemplates.
     */
    cursor?: SystemContentTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemContentTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemContentTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemContentTemplates.
     */
    distinct?: SystemContentTemplateScalarFieldEnum | SystemContentTemplateScalarFieldEnum[]
  }

  /**
   * SystemContentTemplate findFirstOrThrow
   */
  export type SystemContentTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemContentTemplate
     */
    select?: SystemContentTemplateSelect<ExtArgs> | null
    /**
     * Filter, which SystemContentTemplate to fetch.
     */
    where?: SystemContentTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemContentTemplates to fetch.
     */
    orderBy?: SystemContentTemplateOrderByWithRelationInput | SystemContentTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemContentTemplates.
     */
    cursor?: SystemContentTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemContentTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemContentTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemContentTemplates.
     */
    distinct?: SystemContentTemplateScalarFieldEnum | SystemContentTemplateScalarFieldEnum[]
  }

  /**
   * SystemContentTemplate findMany
   */
  export type SystemContentTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemContentTemplate
     */
    select?: SystemContentTemplateSelect<ExtArgs> | null
    /**
     * Filter, which SystemContentTemplates to fetch.
     */
    where?: SystemContentTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemContentTemplates to fetch.
     */
    orderBy?: SystemContentTemplateOrderByWithRelationInput | SystemContentTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemContentTemplates.
     */
    cursor?: SystemContentTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemContentTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemContentTemplates.
     */
    skip?: number
    distinct?: SystemContentTemplateScalarFieldEnum | SystemContentTemplateScalarFieldEnum[]
  }

  /**
   * SystemContentTemplate create
   */
  export type SystemContentTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemContentTemplate
     */
    select?: SystemContentTemplateSelect<ExtArgs> | null
    /**
     * The data needed to create a SystemContentTemplate.
     */
    data: XOR<SystemContentTemplateCreateInput, SystemContentTemplateUncheckedCreateInput>
  }

  /**
   * SystemContentTemplate createMany
   */
  export type SystemContentTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemContentTemplates.
     */
    data: SystemContentTemplateCreateManyInput | SystemContentTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemContentTemplate createManyAndReturn
   */
  export type SystemContentTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemContentTemplate
     */
    select?: SystemContentTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many SystemContentTemplates.
     */
    data: SystemContentTemplateCreateManyInput | SystemContentTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemContentTemplate update
   */
  export type SystemContentTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemContentTemplate
     */
    select?: SystemContentTemplateSelect<ExtArgs> | null
    /**
     * The data needed to update a SystemContentTemplate.
     */
    data: XOR<SystemContentTemplateUpdateInput, SystemContentTemplateUncheckedUpdateInput>
    /**
     * Choose, which SystemContentTemplate to update.
     */
    where: SystemContentTemplateWhereUniqueInput
  }

  /**
   * SystemContentTemplate updateMany
   */
  export type SystemContentTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemContentTemplates.
     */
    data: XOR<SystemContentTemplateUpdateManyMutationInput, SystemContentTemplateUncheckedUpdateManyInput>
    /**
     * Filter which SystemContentTemplates to update
     */
    where?: SystemContentTemplateWhereInput
  }

  /**
   * SystemContentTemplate upsert
   */
  export type SystemContentTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemContentTemplate
     */
    select?: SystemContentTemplateSelect<ExtArgs> | null
    /**
     * The filter to search for the SystemContentTemplate to update in case it exists.
     */
    where: SystemContentTemplateWhereUniqueInput
    /**
     * In case the SystemContentTemplate found by the `where` argument doesn't exist, create a new SystemContentTemplate with this data.
     */
    create: XOR<SystemContentTemplateCreateInput, SystemContentTemplateUncheckedCreateInput>
    /**
     * In case the SystemContentTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemContentTemplateUpdateInput, SystemContentTemplateUncheckedUpdateInput>
  }

  /**
   * SystemContentTemplate delete
   */
  export type SystemContentTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemContentTemplate
     */
    select?: SystemContentTemplateSelect<ExtArgs> | null
    /**
     * Filter which SystemContentTemplate to delete.
     */
    where: SystemContentTemplateWhereUniqueInput
  }

  /**
   * SystemContentTemplate deleteMany
   */
  export type SystemContentTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemContentTemplates to delete
     */
    where?: SystemContentTemplateWhereInput
  }

  /**
   * SystemContentTemplate without action
   */
  export type SystemContentTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemContentTemplate
     */
    select?: SystemContentTemplateSelect<ExtArgs> | null
  }


  /**
   * Model ClinicContent
   */

  export type AggregateClinicContent = {
    _count: ClinicContentCountAggregateOutputType | null
    _avg: ClinicContentAvgAggregateOutputType | null
    _sum: ClinicContentSumAggregateOutputType | null
    _min: ClinicContentMinAggregateOutputType | null
    _max: ClinicContentMaxAggregateOutputType | null
  }

  export type ClinicContentAvgAggregateOutputType = {
    validFromDay: number | null
    validUntilDay: number | null
    sortOrder: number | null
  }

  export type ClinicContentSumAggregateOutputType = {
    validFromDay: number | null
    validUntilDay: number | null
    sortOrder: number | null
  }

  export type ClinicContentMinAggregateOutputType = {
    id: string | null
    clinicId: string | null
    templateId: string | null
    type: $Enums.ContentType | null
    category: $Enums.ContentCategory | null
    title: string | null
    description: string | null
    validFromDay: number | null
    validUntilDay: number | null
    sortOrder: number | null
    isActive: boolean | null
    isCustom: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClinicContentMaxAggregateOutputType = {
    id: string | null
    clinicId: string | null
    templateId: string | null
    type: $Enums.ContentType | null
    category: $Enums.ContentCategory | null
    title: string | null
    description: string | null
    validFromDay: number | null
    validUntilDay: number | null
    sortOrder: number | null
    isActive: boolean | null
    isCustom: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ClinicContentCountAggregateOutputType = {
    id: number
    clinicId: number
    templateId: number
    type: number
    category: number
    title: number
    description: number
    validFromDay: number
    validUntilDay: number
    sortOrder: number
    isActive: number
    isCustom: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ClinicContentAvgAggregateInputType = {
    validFromDay?: true
    validUntilDay?: true
    sortOrder?: true
  }

  export type ClinicContentSumAggregateInputType = {
    validFromDay?: true
    validUntilDay?: true
    sortOrder?: true
  }

  export type ClinicContentMinAggregateInputType = {
    id?: true
    clinicId?: true
    templateId?: true
    type?: true
    category?: true
    title?: true
    description?: true
    validFromDay?: true
    validUntilDay?: true
    sortOrder?: true
    isActive?: true
    isCustom?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClinicContentMaxAggregateInputType = {
    id?: true
    clinicId?: true
    templateId?: true
    type?: true
    category?: true
    title?: true
    description?: true
    validFromDay?: true
    validUntilDay?: true
    sortOrder?: true
    isActive?: true
    isCustom?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ClinicContentCountAggregateInputType = {
    id?: true
    clinicId?: true
    templateId?: true
    type?: true
    category?: true
    title?: true
    description?: true
    validFromDay?: true
    validUntilDay?: true
    sortOrder?: true
    isActive?: true
    isCustom?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ClinicContentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClinicContent to aggregate.
     */
    where?: ClinicContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicContents to fetch.
     */
    orderBy?: ClinicContentOrderByWithRelationInput | ClinicContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClinicContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ClinicContents
    **/
    _count?: true | ClinicContentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClinicContentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClinicContentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClinicContentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClinicContentMaxAggregateInputType
  }

  export type GetClinicContentAggregateType<T extends ClinicContentAggregateArgs> = {
        [P in keyof T & keyof AggregateClinicContent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClinicContent[P]>
      : GetScalarType<T[P], AggregateClinicContent[P]>
  }




  export type ClinicContentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClinicContentWhereInput
    orderBy?: ClinicContentOrderByWithAggregationInput | ClinicContentOrderByWithAggregationInput[]
    by: ClinicContentScalarFieldEnum[] | ClinicContentScalarFieldEnum
    having?: ClinicContentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClinicContentCountAggregateInputType | true
    _avg?: ClinicContentAvgAggregateInputType
    _sum?: ClinicContentSumAggregateInputType
    _min?: ClinicContentMinAggregateInputType
    _max?: ClinicContentMaxAggregateInputType
  }

  export type ClinicContentGroupByOutputType = {
    id: string
    clinicId: string
    templateId: string | null
    type: $Enums.ContentType
    category: $Enums.ContentCategory
    title: string
    description: string | null
    validFromDay: number | null
    validUntilDay: number | null
    sortOrder: number
    isActive: boolean
    isCustom: boolean
    createdAt: Date
    updatedAt: Date
    _count: ClinicContentCountAggregateOutputType | null
    _avg: ClinicContentAvgAggregateOutputType | null
    _sum: ClinicContentSumAggregateOutputType | null
    _min: ClinicContentMinAggregateOutputType | null
    _max: ClinicContentMaxAggregateOutputType | null
  }

  type GetClinicContentGroupByPayload<T extends ClinicContentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClinicContentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClinicContentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClinicContentGroupByOutputType[P]>
            : GetScalarType<T[P], ClinicContentGroupByOutputType[P]>
        }
      >
    >


  export type ClinicContentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    templateId?: boolean
    type?: boolean
    category?: boolean
    title?: boolean
    description?: boolean
    validFromDay?: boolean
    validUntilDay?: boolean
    sortOrder?: boolean
    isActive?: boolean
    isCustom?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    patientAdjustments?: boolean | ClinicContent$patientAdjustmentsArgs<ExtArgs>
    _count?: boolean | ClinicContentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clinicContent"]>

  export type ClinicContentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    templateId?: boolean
    type?: boolean
    category?: boolean
    title?: boolean
    description?: boolean
    validFromDay?: boolean
    validUntilDay?: boolean
    sortOrder?: boolean
    isActive?: boolean
    isCustom?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["clinicContent"]>

  export type ClinicContentSelectScalar = {
    id?: boolean
    clinicId?: boolean
    templateId?: boolean
    type?: boolean
    category?: boolean
    title?: boolean
    description?: boolean
    validFromDay?: boolean
    validUntilDay?: boolean
    sortOrder?: boolean
    isActive?: boolean
    isCustom?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ClinicContentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
    patientAdjustments?: boolean | ClinicContent$patientAdjustmentsArgs<ExtArgs>
    _count?: boolean | ClinicContentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClinicContentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | ClinicDefaultArgs<ExtArgs>
  }

  export type $ClinicContentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ClinicContent"
    objects: {
      clinic: Prisma.$ClinicPayload<ExtArgs>
      patientAdjustments: Prisma.$PatientContentAdjustmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clinicId: string
      templateId: string | null
      type: $Enums.ContentType
      category: $Enums.ContentCategory
      title: string
      description: string | null
      validFromDay: number | null
      validUntilDay: number | null
      sortOrder: number
      isActive: boolean
      isCustom: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["clinicContent"]>
    composites: {}
  }

  type ClinicContentGetPayload<S extends boolean | null | undefined | ClinicContentDefaultArgs> = $Result.GetResult<Prisma.$ClinicContentPayload, S>

  type ClinicContentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ClinicContentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ClinicContentCountAggregateInputType | true
    }

  export interface ClinicContentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ClinicContent'], meta: { name: 'ClinicContent' } }
    /**
     * Find zero or one ClinicContent that matches the filter.
     * @param {ClinicContentFindUniqueArgs} args - Arguments to find a ClinicContent
     * @example
     * // Get one ClinicContent
     * const clinicContent = await prisma.clinicContent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClinicContentFindUniqueArgs>(args: SelectSubset<T, ClinicContentFindUniqueArgs<ExtArgs>>): Prisma__ClinicContentClient<$Result.GetResult<Prisma.$ClinicContentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ClinicContent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ClinicContentFindUniqueOrThrowArgs} args - Arguments to find a ClinicContent
     * @example
     * // Get one ClinicContent
     * const clinicContent = await prisma.clinicContent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClinicContentFindUniqueOrThrowArgs>(args: SelectSubset<T, ClinicContentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClinicContentClient<$Result.GetResult<Prisma.$ClinicContentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ClinicContent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicContentFindFirstArgs} args - Arguments to find a ClinicContent
     * @example
     * // Get one ClinicContent
     * const clinicContent = await prisma.clinicContent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClinicContentFindFirstArgs>(args?: SelectSubset<T, ClinicContentFindFirstArgs<ExtArgs>>): Prisma__ClinicContentClient<$Result.GetResult<Prisma.$ClinicContentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ClinicContent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicContentFindFirstOrThrowArgs} args - Arguments to find a ClinicContent
     * @example
     * // Get one ClinicContent
     * const clinicContent = await prisma.clinicContent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClinicContentFindFirstOrThrowArgs>(args?: SelectSubset<T, ClinicContentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClinicContentClient<$Result.GetResult<Prisma.$ClinicContentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ClinicContents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicContentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ClinicContents
     * const clinicContents = await prisma.clinicContent.findMany()
     * 
     * // Get first 10 ClinicContents
     * const clinicContents = await prisma.clinicContent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const clinicContentWithIdOnly = await prisma.clinicContent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClinicContentFindManyArgs>(args?: SelectSubset<T, ClinicContentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicContentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ClinicContent.
     * @param {ClinicContentCreateArgs} args - Arguments to create a ClinicContent.
     * @example
     * // Create one ClinicContent
     * const ClinicContent = await prisma.clinicContent.create({
     *   data: {
     *     // ... data to create a ClinicContent
     *   }
     * })
     * 
     */
    create<T extends ClinicContentCreateArgs>(args: SelectSubset<T, ClinicContentCreateArgs<ExtArgs>>): Prisma__ClinicContentClient<$Result.GetResult<Prisma.$ClinicContentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ClinicContents.
     * @param {ClinicContentCreateManyArgs} args - Arguments to create many ClinicContents.
     * @example
     * // Create many ClinicContents
     * const clinicContent = await prisma.clinicContent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClinicContentCreateManyArgs>(args?: SelectSubset<T, ClinicContentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ClinicContents and returns the data saved in the database.
     * @param {ClinicContentCreateManyAndReturnArgs} args - Arguments to create many ClinicContents.
     * @example
     * // Create many ClinicContents
     * const clinicContent = await prisma.clinicContent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ClinicContents and only return the `id`
     * const clinicContentWithIdOnly = await prisma.clinicContent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClinicContentCreateManyAndReturnArgs>(args?: SelectSubset<T, ClinicContentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClinicContentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ClinicContent.
     * @param {ClinicContentDeleteArgs} args - Arguments to delete one ClinicContent.
     * @example
     * // Delete one ClinicContent
     * const ClinicContent = await prisma.clinicContent.delete({
     *   where: {
     *     // ... filter to delete one ClinicContent
     *   }
     * })
     * 
     */
    delete<T extends ClinicContentDeleteArgs>(args: SelectSubset<T, ClinicContentDeleteArgs<ExtArgs>>): Prisma__ClinicContentClient<$Result.GetResult<Prisma.$ClinicContentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ClinicContent.
     * @param {ClinicContentUpdateArgs} args - Arguments to update one ClinicContent.
     * @example
     * // Update one ClinicContent
     * const clinicContent = await prisma.clinicContent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClinicContentUpdateArgs>(args: SelectSubset<T, ClinicContentUpdateArgs<ExtArgs>>): Prisma__ClinicContentClient<$Result.GetResult<Prisma.$ClinicContentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ClinicContents.
     * @param {ClinicContentDeleteManyArgs} args - Arguments to filter ClinicContents to delete.
     * @example
     * // Delete a few ClinicContents
     * const { count } = await prisma.clinicContent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClinicContentDeleteManyArgs>(args?: SelectSubset<T, ClinicContentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ClinicContents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicContentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ClinicContents
     * const clinicContent = await prisma.clinicContent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClinicContentUpdateManyArgs>(args: SelectSubset<T, ClinicContentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ClinicContent.
     * @param {ClinicContentUpsertArgs} args - Arguments to update or create a ClinicContent.
     * @example
     * // Update or create a ClinicContent
     * const clinicContent = await prisma.clinicContent.upsert({
     *   create: {
     *     // ... data to create a ClinicContent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ClinicContent we want to update
     *   }
     * })
     */
    upsert<T extends ClinicContentUpsertArgs>(args: SelectSubset<T, ClinicContentUpsertArgs<ExtArgs>>): Prisma__ClinicContentClient<$Result.GetResult<Prisma.$ClinicContentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ClinicContents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicContentCountArgs} args - Arguments to filter ClinicContents to count.
     * @example
     * // Count the number of ClinicContents
     * const count = await prisma.clinicContent.count({
     *   where: {
     *     // ... the filter for the ClinicContents we want to count
     *   }
     * })
    **/
    count<T extends ClinicContentCountArgs>(
      args?: Subset<T, ClinicContentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClinicContentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ClinicContent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicContentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClinicContentAggregateArgs>(args: Subset<T, ClinicContentAggregateArgs>): Prisma.PrismaPromise<GetClinicContentAggregateType<T>>

    /**
     * Group by ClinicContent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClinicContentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClinicContentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClinicContentGroupByArgs['orderBy'] }
        : { orderBy?: ClinicContentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClinicContentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClinicContentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ClinicContent model
   */
  readonly fields: ClinicContentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ClinicContent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClinicContentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clinic<T extends ClinicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ClinicDefaultArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    patientAdjustments<T extends ClinicContent$patientAdjustmentsArgs<ExtArgs> = {}>(args?: Subset<T, ClinicContent$patientAdjustmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientContentAdjustmentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ClinicContent model
   */ 
  interface ClinicContentFieldRefs {
    readonly id: FieldRef<"ClinicContent", 'String'>
    readonly clinicId: FieldRef<"ClinicContent", 'String'>
    readonly templateId: FieldRef<"ClinicContent", 'String'>
    readonly type: FieldRef<"ClinicContent", 'ContentType'>
    readonly category: FieldRef<"ClinicContent", 'ContentCategory'>
    readonly title: FieldRef<"ClinicContent", 'String'>
    readonly description: FieldRef<"ClinicContent", 'String'>
    readonly validFromDay: FieldRef<"ClinicContent", 'Int'>
    readonly validUntilDay: FieldRef<"ClinicContent", 'Int'>
    readonly sortOrder: FieldRef<"ClinicContent", 'Int'>
    readonly isActive: FieldRef<"ClinicContent", 'Boolean'>
    readonly isCustom: FieldRef<"ClinicContent", 'Boolean'>
    readonly createdAt: FieldRef<"ClinicContent", 'DateTime'>
    readonly updatedAt: FieldRef<"ClinicContent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ClinicContent findUnique
   */
  export type ClinicContentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicContent
     */
    select?: ClinicContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicContentInclude<ExtArgs> | null
    /**
     * Filter, which ClinicContent to fetch.
     */
    where: ClinicContentWhereUniqueInput
  }

  /**
   * ClinicContent findUniqueOrThrow
   */
  export type ClinicContentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicContent
     */
    select?: ClinicContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicContentInclude<ExtArgs> | null
    /**
     * Filter, which ClinicContent to fetch.
     */
    where: ClinicContentWhereUniqueInput
  }

  /**
   * ClinicContent findFirst
   */
  export type ClinicContentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicContent
     */
    select?: ClinicContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicContentInclude<ExtArgs> | null
    /**
     * Filter, which ClinicContent to fetch.
     */
    where?: ClinicContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicContents to fetch.
     */
    orderBy?: ClinicContentOrderByWithRelationInput | ClinicContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClinicContents.
     */
    cursor?: ClinicContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClinicContents.
     */
    distinct?: ClinicContentScalarFieldEnum | ClinicContentScalarFieldEnum[]
  }

  /**
   * ClinicContent findFirstOrThrow
   */
  export type ClinicContentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicContent
     */
    select?: ClinicContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicContentInclude<ExtArgs> | null
    /**
     * Filter, which ClinicContent to fetch.
     */
    where?: ClinicContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicContents to fetch.
     */
    orderBy?: ClinicContentOrderByWithRelationInput | ClinicContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ClinicContents.
     */
    cursor?: ClinicContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicContents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ClinicContents.
     */
    distinct?: ClinicContentScalarFieldEnum | ClinicContentScalarFieldEnum[]
  }

  /**
   * ClinicContent findMany
   */
  export type ClinicContentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicContent
     */
    select?: ClinicContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicContentInclude<ExtArgs> | null
    /**
     * Filter, which ClinicContents to fetch.
     */
    where?: ClinicContentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ClinicContents to fetch.
     */
    orderBy?: ClinicContentOrderByWithRelationInput | ClinicContentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ClinicContents.
     */
    cursor?: ClinicContentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ClinicContents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ClinicContents.
     */
    skip?: number
    distinct?: ClinicContentScalarFieldEnum | ClinicContentScalarFieldEnum[]
  }

  /**
   * ClinicContent create
   */
  export type ClinicContentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicContent
     */
    select?: ClinicContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicContentInclude<ExtArgs> | null
    /**
     * The data needed to create a ClinicContent.
     */
    data: XOR<ClinicContentCreateInput, ClinicContentUncheckedCreateInput>
  }

  /**
   * ClinicContent createMany
   */
  export type ClinicContentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ClinicContents.
     */
    data: ClinicContentCreateManyInput | ClinicContentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ClinicContent createManyAndReturn
   */
  export type ClinicContentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicContent
     */
    select?: ClinicContentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ClinicContents.
     */
    data: ClinicContentCreateManyInput | ClinicContentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicContentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ClinicContent update
   */
  export type ClinicContentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicContent
     */
    select?: ClinicContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicContentInclude<ExtArgs> | null
    /**
     * The data needed to update a ClinicContent.
     */
    data: XOR<ClinicContentUpdateInput, ClinicContentUncheckedUpdateInput>
    /**
     * Choose, which ClinicContent to update.
     */
    where: ClinicContentWhereUniqueInput
  }

  /**
   * ClinicContent updateMany
   */
  export type ClinicContentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ClinicContents.
     */
    data: XOR<ClinicContentUpdateManyMutationInput, ClinicContentUncheckedUpdateManyInput>
    /**
     * Filter which ClinicContents to update
     */
    where?: ClinicContentWhereInput
  }

  /**
   * ClinicContent upsert
   */
  export type ClinicContentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicContent
     */
    select?: ClinicContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicContentInclude<ExtArgs> | null
    /**
     * The filter to search for the ClinicContent to update in case it exists.
     */
    where: ClinicContentWhereUniqueInput
    /**
     * In case the ClinicContent found by the `where` argument doesn't exist, create a new ClinicContent with this data.
     */
    create: XOR<ClinicContentCreateInput, ClinicContentUncheckedCreateInput>
    /**
     * In case the ClinicContent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClinicContentUpdateInput, ClinicContentUncheckedUpdateInput>
  }

  /**
   * ClinicContent delete
   */
  export type ClinicContentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicContent
     */
    select?: ClinicContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicContentInclude<ExtArgs> | null
    /**
     * Filter which ClinicContent to delete.
     */
    where: ClinicContentWhereUniqueInput
  }

  /**
   * ClinicContent deleteMany
   */
  export type ClinicContentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ClinicContents to delete
     */
    where?: ClinicContentWhereInput
  }

  /**
   * ClinicContent.patientAdjustments
   */
  export type ClinicContent$patientAdjustmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientContentAdjustment
     */
    select?: PatientContentAdjustmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientContentAdjustmentInclude<ExtArgs> | null
    where?: PatientContentAdjustmentWhereInput
    orderBy?: PatientContentAdjustmentOrderByWithRelationInput | PatientContentAdjustmentOrderByWithRelationInput[]
    cursor?: PatientContentAdjustmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatientContentAdjustmentScalarFieldEnum | PatientContentAdjustmentScalarFieldEnum[]
  }

  /**
   * ClinicContent without action
   */
  export type ClinicContentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicContent
     */
    select?: ClinicContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicContentInclude<ExtArgs> | null
  }


  /**
   * Model PatientContentAdjustment
   */

  export type AggregatePatientContentAdjustment = {
    _count: PatientContentAdjustmentCountAggregateOutputType | null
    _avg: PatientContentAdjustmentAvgAggregateOutputType | null
    _sum: PatientContentAdjustmentSumAggregateOutputType | null
    _min: PatientContentAdjustmentMinAggregateOutputType | null
    _max: PatientContentAdjustmentMaxAggregateOutputType | null
  }

  export type PatientContentAdjustmentAvgAggregateOutputType = {
    validFromDay: number | null
    validUntilDay: number | null
  }

  export type PatientContentAdjustmentSumAggregateOutputType = {
    validFromDay: number | null
    validUntilDay: number | null
  }

  export type PatientContentAdjustmentMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    baseContentId: string | null
    adjustmentType: $Enums.AdjustmentType | null
    contentType: $Enums.ContentType | null
    category: $Enums.ContentCategory | null
    title: string | null
    description: string | null
    validFromDay: number | null
    validUntilDay: number | null
    reason: string | null
    isActive: boolean | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type PatientContentAdjustmentMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    baseContentId: string | null
    adjustmentType: $Enums.AdjustmentType | null
    contentType: $Enums.ContentType | null
    category: $Enums.ContentCategory | null
    title: string | null
    description: string | null
    validFromDay: number | null
    validUntilDay: number | null
    reason: string | null
    isActive: boolean | null
    createdBy: string | null
    createdAt: Date | null
  }

  export type PatientContentAdjustmentCountAggregateOutputType = {
    id: number
    patientId: number
    baseContentId: number
    adjustmentType: number
    contentType: number
    category: number
    title: number
    description: number
    validFromDay: number
    validUntilDay: number
    reason: number
    isActive: number
    createdBy: number
    createdAt: number
    _all: number
  }


  export type PatientContentAdjustmentAvgAggregateInputType = {
    validFromDay?: true
    validUntilDay?: true
  }

  export type PatientContentAdjustmentSumAggregateInputType = {
    validFromDay?: true
    validUntilDay?: true
  }

  export type PatientContentAdjustmentMinAggregateInputType = {
    id?: true
    patientId?: true
    baseContentId?: true
    adjustmentType?: true
    contentType?: true
    category?: true
    title?: true
    description?: true
    validFromDay?: true
    validUntilDay?: true
    reason?: true
    isActive?: true
    createdBy?: true
    createdAt?: true
  }

  export type PatientContentAdjustmentMaxAggregateInputType = {
    id?: true
    patientId?: true
    baseContentId?: true
    adjustmentType?: true
    contentType?: true
    category?: true
    title?: true
    description?: true
    validFromDay?: true
    validUntilDay?: true
    reason?: true
    isActive?: true
    createdBy?: true
    createdAt?: true
  }

  export type PatientContentAdjustmentCountAggregateInputType = {
    id?: true
    patientId?: true
    baseContentId?: true
    adjustmentType?: true
    contentType?: true
    category?: true
    title?: true
    description?: true
    validFromDay?: true
    validUntilDay?: true
    reason?: true
    isActive?: true
    createdBy?: true
    createdAt?: true
    _all?: true
  }

  export type PatientContentAdjustmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PatientContentAdjustment to aggregate.
     */
    where?: PatientContentAdjustmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientContentAdjustments to fetch.
     */
    orderBy?: PatientContentAdjustmentOrderByWithRelationInput | PatientContentAdjustmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatientContentAdjustmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientContentAdjustments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientContentAdjustments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PatientContentAdjustments
    **/
    _count?: true | PatientContentAdjustmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PatientContentAdjustmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PatientContentAdjustmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatientContentAdjustmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatientContentAdjustmentMaxAggregateInputType
  }

  export type GetPatientContentAdjustmentAggregateType<T extends PatientContentAdjustmentAggregateArgs> = {
        [P in keyof T & keyof AggregatePatientContentAdjustment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatientContentAdjustment[P]>
      : GetScalarType<T[P], AggregatePatientContentAdjustment[P]>
  }




  export type PatientContentAdjustmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientContentAdjustmentWhereInput
    orderBy?: PatientContentAdjustmentOrderByWithAggregationInput | PatientContentAdjustmentOrderByWithAggregationInput[]
    by: PatientContentAdjustmentScalarFieldEnum[] | PatientContentAdjustmentScalarFieldEnum
    having?: PatientContentAdjustmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatientContentAdjustmentCountAggregateInputType | true
    _avg?: PatientContentAdjustmentAvgAggregateInputType
    _sum?: PatientContentAdjustmentSumAggregateInputType
    _min?: PatientContentAdjustmentMinAggregateInputType
    _max?: PatientContentAdjustmentMaxAggregateInputType
  }

  export type PatientContentAdjustmentGroupByOutputType = {
    id: string
    patientId: string
    baseContentId: string | null
    adjustmentType: $Enums.AdjustmentType
    contentType: $Enums.ContentType | null
    category: $Enums.ContentCategory | null
    title: string | null
    description: string | null
    validFromDay: number | null
    validUntilDay: number | null
    reason: string | null
    isActive: boolean
    createdBy: string | null
    createdAt: Date
    _count: PatientContentAdjustmentCountAggregateOutputType | null
    _avg: PatientContentAdjustmentAvgAggregateOutputType | null
    _sum: PatientContentAdjustmentSumAggregateOutputType | null
    _min: PatientContentAdjustmentMinAggregateOutputType | null
    _max: PatientContentAdjustmentMaxAggregateOutputType | null
  }

  type GetPatientContentAdjustmentGroupByPayload<T extends PatientContentAdjustmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatientContentAdjustmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatientContentAdjustmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatientContentAdjustmentGroupByOutputType[P]>
            : GetScalarType<T[P], PatientContentAdjustmentGroupByOutputType[P]>
        }
      >
    >


  export type PatientContentAdjustmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    baseContentId?: boolean
    adjustmentType?: boolean
    contentType?: boolean
    category?: boolean
    title?: boolean
    description?: boolean
    validFromDay?: boolean
    validUntilDay?: boolean
    reason?: boolean
    isActive?: boolean
    createdBy?: boolean
    createdAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    baseContent?: boolean | PatientContentAdjustment$baseContentArgs<ExtArgs>
  }, ExtArgs["result"]["patientContentAdjustment"]>

  export type PatientContentAdjustmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    baseContentId?: boolean
    adjustmentType?: boolean
    contentType?: boolean
    category?: boolean
    title?: boolean
    description?: boolean
    validFromDay?: boolean
    validUntilDay?: boolean
    reason?: boolean
    isActive?: boolean
    createdBy?: boolean
    createdAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    baseContent?: boolean | PatientContentAdjustment$baseContentArgs<ExtArgs>
  }, ExtArgs["result"]["patientContentAdjustment"]>

  export type PatientContentAdjustmentSelectScalar = {
    id?: boolean
    patientId?: boolean
    baseContentId?: boolean
    adjustmentType?: boolean
    contentType?: boolean
    category?: boolean
    title?: boolean
    description?: boolean
    validFromDay?: boolean
    validUntilDay?: boolean
    reason?: boolean
    isActive?: boolean
    createdBy?: boolean
    createdAt?: boolean
  }

  export type PatientContentAdjustmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    baseContent?: boolean | PatientContentAdjustment$baseContentArgs<ExtArgs>
  }
  export type PatientContentAdjustmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    baseContent?: boolean | PatientContentAdjustment$baseContentArgs<ExtArgs>
  }

  export type $PatientContentAdjustmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PatientContentAdjustment"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      baseContent: Prisma.$ClinicContentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      baseContentId: string | null
      adjustmentType: $Enums.AdjustmentType
      contentType: $Enums.ContentType | null
      category: $Enums.ContentCategory | null
      title: string | null
      description: string | null
      validFromDay: number | null
      validUntilDay: number | null
      reason: string | null
      isActive: boolean
      createdBy: string | null
      createdAt: Date
    }, ExtArgs["result"]["patientContentAdjustment"]>
    composites: {}
  }

  type PatientContentAdjustmentGetPayload<S extends boolean | null | undefined | PatientContentAdjustmentDefaultArgs> = $Result.GetResult<Prisma.$PatientContentAdjustmentPayload, S>

  type PatientContentAdjustmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PatientContentAdjustmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PatientContentAdjustmentCountAggregateInputType | true
    }

  export interface PatientContentAdjustmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PatientContentAdjustment'], meta: { name: 'PatientContentAdjustment' } }
    /**
     * Find zero or one PatientContentAdjustment that matches the filter.
     * @param {PatientContentAdjustmentFindUniqueArgs} args - Arguments to find a PatientContentAdjustment
     * @example
     * // Get one PatientContentAdjustment
     * const patientContentAdjustment = await prisma.patientContentAdjustment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PatientContentAdjustmentFindUniqueArgs>(args: SelectSubset<T, PatientContentAdjustmentFindUniqueArgs<ExtArgs>>): Prisma__PatientContentAdjustmentClient<$Result.GetResult<Prisma.$PatientContentAdjustmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PatientContentAdjustment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PatientContentAdjustmentFindUniqueOrThrowArgs} args - Arguments to find a PatientContentAdjustment
     * @example
     * // Get one PatientContentAdjustment
     * const patientContentAdjustment = await prisma.patientContentAdjustment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PatientContentAdjustmentFindUniqueOrThrowArgs>(args: SelectSubset<T, PatientContentAdjustmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PatientContentAdjustmentClient<$Result.GetResult<Prisma.$PatientContentAdjustmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PatientContentAdjustment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientContentAdjustmentFindFirstArgs} args - Arguments to find a PatientContentAdjustment
     * @example
     * // Get one PatientContentAdjustment
     * const patientContentAdjustment = await prisma.patientContentAdjustment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PatientContentAdjustmentFindFirstArgs>(args?: SelectSubset<T, PatientContentAdjustmentFindFirstArgs<ExtArgs>>): Prisma__PatientContentAdjustmentClient<$Result.GetResult<Prisma.$PatientContentAdjustmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PatientContentAdjustment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientContentAdjustmentFindFirstOrThrowArgs} args - Arguments to find a PatientContentAdjustment
     * @example
     * // Get one PatientContentAdjustment
     * const patientContentAdjustment = await prisma.patientContentAdjustment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PatientContentAdjustmentFindFirstOrThrowArgs>(args?: SelectSubset<T, PatientContentAdjustmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PatientContentAdjustmentClient<$Result.GetResult<Prisma.$PatientContentAdjustmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PatientContentAdjustments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientContentAdjustmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PatientContentAdjustments
     * const patientContentAdjustments = await prisma.patientContentAdjustment.findMany()
     * 
     * // Get first 10 PatientContentAdjustments
     * const patientContentAdjustments = await prisma.patientContentAdjustment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patientContentAdjustmentWithIdOnly = await prisma.patientContentAdjustment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PatientContentAdjustmentFindManyArgs>(args?: SelectSubset<T, PatientContentAdjustmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientContentAdjustmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PatientContentAdjustment.
     * @param {PatientContentAdjustmentCreateArgs} args - Arguments to create a PatientContentAdjustment.
     * @example
     * // Create one PatientContentAdjustment
     * const PatientContentAdjustment = await prisma.patientContentAdjustment.create({
     *   data: {
     *     // ... data to create a PatientContentAdjustment
     *   }
     * })
     * 
     */
    create<T extends PatientContentAdjustmentCreateArgs>(args: SelectSubset<T, PatientContentAdjustmentCreateArgs<ExtArgs>>): Prisma__PatientContentAdjustmentClient<$Result.GetResult<Prisma.$PatientContentAdjustmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PatientContentAdjustments.
     * @param {PatientContentAdjustmentCreateManyArgs} args - Arguments to create many PatientContentAdjustments.
     * @example
     * // Create many PatientContentAdjustments
     * const patientContentAdjustment = await prisma.patientContentAdjustment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PatientContentAdjustmentCreateManyArgs>(args?: SelectSubset<T, PatientContentAdjustmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PatientContentAdjustments and returns the data saved in the database.
     * @param {PatientContentAdjustmentCreateManyAndReturnArgs} args - Arguments to create many PatientContentAdjustments.
     * @example
     * // Create many PatientContentAdjustments
     * const patientContentAdjustment = await prisma.patientContentAdjustment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PatientContentAdjustments and only return the `id`
     * const patientContentAdjustmentWithIdOnly = await prisma.patientContentAdjustment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PatientContentAdjustmentCreateManyAndReturnArgs>(args?: SelectSubset<T, PatientContentAdjustmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientContentAdjustmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PatientContentAdjustment.
     * @param {PatientContentAdjustmentDeleteArgs} args - Arguments to delete one PatientContentAdjustment.
     * @example
     * // Delete one PatientContentAdjustment
     * const PatientContentAdjustment = await prisma.patientContentAdjustment.delete({
     *   where: {
     *     // ... filter to delete one PatientContentAdjustment
     *   }
     * })
     * 
     */
    delete<T extends PatientContentAdjustmentDeleteArgs>(args: SelectSubset<T, PatientContentAdjustmentDeleteArgs<ExtArgs>>): Prisma__PatientContentAdjustmentClient<$Result.GetResult<Prisma.$PatientContentAdjustmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PatientContentAdjustment.
     * @param {PatientContentAdjustmentUpdateArgs} args - Arguments to update one PatientContentAdjustment.
     * @example
     * // Update one PatientContentAdjustment
     * const patientContentAdjustment = await prisma.patientContentAdjustment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PatientContentAdjustmentUpdateArgs>(args: SelectSubset<T, PatientContentAdjustmentUpdateArgs<ExtArgs>>): Prisma__PatientContentAdjustmentClient<$Result.GetResult<Prisma.$PatientContentAdjustmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PatientContentAdjustments.
     * @param {PatientContentAdjustmentDeleteManyArgs} args - Arguments to filter PatientContentAdjustments to delete.
     * @example
     * // Delete a few PatientContentAdjustments
     * const { count } = await prisma.patientContentAdjustment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PatientContentAdjustmentDeleteManyArgs>(args?: SelectSubset<T, PatientContentAdjustmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PatientContentAdjustments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientContentAdjustmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PatientContentAdjustments
     * const patientContentAdjustment = await prisma.patientContentAdjustment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PatientContentAdjustmentUpdateManyArgs>(args: SelectSubset<T, PatientContentAdjustmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PatientContentAdjustment.
     * @param {PatientContentAdjustmentUpsertArgs} args - Arguments to update or create a PatientContentAdjustment.
     * @example
     * // Update or create a PatientContentAdjustment
     * const patientContentAdjustment = await prisma.patientContentAdjustment.upsert({
     *   create: {
     *     // ... data to create a PatientContentAdjustment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PatientContentAdjustment we want to update
     *   }
     * })
     */
    upsert<T extends PatientContentAdjustmentUpsertArgs>(args: SelectSubset<T, PatientContentAdjustmentUpsertArgs<ExtArgs>>): Prisma__PatientContentAdjustmentClient<$Result.GetResult<Prisma.$PatientContentAdjustmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PatientContentAdjustments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientContentAdjustmentCountArgs} args - Arguments to filter PatientContentAdjustments to count.
     * @example
     * // Count the number of PatientContentAdjustments
     * const count = await prisma.patientContentAdjustment.count({
     *   where: {
     *     // ... the filter for the PatientContentAdjustments we want to count
     *   }
     * })
    **/
    count<T extends PatientContentAdjustmentCountArgs>(
      args?: Subset<T, PatientContentAdjustmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatientContentAdjustmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PatientContentAdjustment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientContentAdjustmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatientContentAdjustmentAggregateArgs>(args: Subset<T, PatientContentAdjustmentAggregateArgs>): Prisma.PrismaPromise<GetPatientContentAdjustmentAggregateType<T>>

    /**
     * Group by PatientContentAdjustment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientContentAdjustmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatientContentAdjustmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatientContentAdjustmentGroupByArgs['orderBy'] }
        : { orderBy?: PatientContentAdjustmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatientContentAdjustmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatientContentAdjustmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PatientContentAdjustment model
   */
  readonly fields: PatientContentAdjustmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PatientContentAdjustment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatientContentAdjustmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    baseContent<T extends PatientContentAdjustment$baseContentArgs<ExtArgs> = {}>(args?: Subset<T, PatientContentAdjustment$baseContentArgs<ExtArgs>>): Prisma__ClinicContentClient<$Result.GetResult<Prisma.$ClinicContentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PatientContentAdjustment model
   */ 
  interface PatientContentAdjustmentFieldRefs {
    readonly id: FieldRef<"PatientContentAdjustment", 'String'>
    readonly patientId: FieldRef<"PatientContentAdjustment", 'String'>
    readonly baseContentId: FieldRef<"PatientContentAdjustment", 'String'>
    readonly adjustmentType: FieldRef<"PatientContentAdjustment", 'AdjustmentType'>
    readonly contentType: FieldRef<"PatientContentAdjustment", 'ContentType'>
    readonly category: FieldRef<"PatientContentAdjustment", 'ContentCategory'>
    readonly title: FieldRef<"PatientContentAdjustment", 'String'>
    readonly description: FieldRef<"PatientContentAdjustment", 'String'>
    readonly validFromDay: FieldRef<"PatientContentAdjustment", 'Int'>
    readonly validUntilDay: FieldRef<"PatientContentAdjustment", 'Int'>
    readonly reason: FieldRef<"PatientContentAdjustment", 'String'>
    readonly isActive: FieldRef<"PatientContentAdjustment", 'Boolean'>
    readonly createdBy: FieldRef<"PatientContentAdjustment", 'String'>
    readonly createdAt: FieldRef<"PatientContentAdjustment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PatientContentAdjustment findUnique
   */
  export type PatientContentAdjustmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientContentAdjustment
     */
    select?: PatientContentAdjustmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientContentAdjustmentInclude<ExtArgs> | null
    /**
     * Filter, which PatientContentAdjustment to fetch.
     */
    where: PatientContentAdjustmentWhereUniqueInput
  }

  /**
   * PatientContentAdjustment findUniqueOrThrow
   */
  export type PatientContentAdjustmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientContentAdjustment
     */
    select?: PatientContentAdjustmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientContentAdjustmentInclude<ExtArgs> | null
    /**
     * Filter, which PatientContentAdjustment to fetch.
     */
    where: PatientContentAdjustmentWhereUniqueInput
  }

  /**
   * PatientContentAdjustment findFirst
   */
  export type PatientContentAdjustmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientContentAdjustment
     */
    select?: PatientContentAdjustmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientContentAdjustmentInclude<ExtArgs> | null
    /**
     * Filter, which PatientContentAdjustment to fetch.
     */
    where?: PatientContentAdjustmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientContentAdjustments to fetch.
     */
    orderBy?: PatientContentAdjustmentOrderByWithRelationInput | PatientContentAdjustmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PatientContentAdjustments.
     */
    cursor?: PatientContentAdjustmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientContentAdjustments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientContentAdjustments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PatientContentAdjustments.
     */
    distinct?: PatientContentAdjustmentScalarFieldEnum | PatientContentAdjustmentScalarFieldEnum[]
  }

  /**
   * PatientContentAdjustment findFirstOrThrow
   */
  export type PatientContentAdjustmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientContentAdjustment
     */
    select?: PatientContentAdjustmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientContentAdjustmentInclude<ExtArgs> | null
    /**
     * Filter, which PatientContentAdjustment to fetch.
     */
    where?: PatientContentAdjustmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientContentAdjustments to fetch.
     */
    orderBy?: PatientContentAdjustmentOrderByWithRelationInput | PatientContentAdjustmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PatientContentAdjustments.
     */
    cursor?: PatientContentAdjustmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientContentAdjustments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientContentAdjustments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PatientContentAdjustments.
     */
    distinct?: PatientContentAdjustmentScalarFieldEnum | PatientContentAdjustmentScalarFieldEnum[]
  }

  /**
   * PatientContentAdjustment findMany
   */
  export type PatientContentAdjustmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientContentAdjustment
     */
    select?: PatientContentAdjustmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientContentAdjustmentInclude<ExtArgs> | null
    /**
     * Filter, which PatientContentAdjustments to fetch.
     */
    where?: PatientContentAdjustmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientContentAdjustments to fetch.
     */
    orderBy?: PatientContentAdjustmentOrderByWithRelationInput | PatientContentAdjustmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PatientContentAdjustments.
     */
    cursor?: PatientContentAdjustmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientContentAdjustments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientContentAdjustments.
     */
    skip?: number
    distinct?: PatientContentAdjustmentScalarFieldEnum | PatientContentAdjustmentScalarFieldEnum[]
  }

  /**
   * PatientContentAdjustment create
   */
  export type PatientContentAdjustmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientContentAdjustment
     */
    select?: PatientContentAdjustmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientContentAdjustmentInclude<ExtArgs> | null
    /**
     * The data needed to create a PatientContentAdjustment.
     */
    data: XOR<PatientContentAdjustmentCreateInput, PatientContentAdjustmentUncheckedCreateInput>
  }

  /**
   * PatientContentAdjustment createMany
   */
  export type PatientContentAdjustmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PatientContentAdjustments.
     */
    data: PatientContentAdjustmentCreateManyInput | PatientContentAdjustmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PatientContentAdjustment createManyAndReturn
   */
  export type PatientContentAdjustmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientContentAdjustment
     */
    select?: PatientContentAdjustmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PatientContentAdjustments.
     */
    data: PatientContentAdjustmentCreateManyInput | PatientContentAdjustmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientContentAdjustmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PatientContentAdjustment update
   */
  export type PatientContentAdjustmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientContentAdjustment
     */
    select?: PatientContentAdjustmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientContentAdjustmentInclude<ExtArgs> | null
    /**
     * The data needed to update a PatientContentAdjustment.
     */
    data: XOR<PatientContentAdjustmentUpdateInput, PatientContentAdjustmentUncheckedUpdateInput>
    /**
     * Choose, which PatientContentAdjustment to update.
     */
    where: PatientContentAdjustmentWhereUniqueInput
  }

  /**
   * PatientContentAdjustment updateMany
   */
  export type PatientContentAdjustmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PatientContentAdjustments.
     */
    data: XOR<PatientContentAdjustmentUpdateManyMutationInput, PatientContentAdjustmentUncheckedUpdateManyInput>
    /**
     * Filter which PatientContentAdjustments to update
     */
    where?: PatientContentAdjustmentWhereInput
  }

  /**
   * PatientContentAdjustment upsert
   */
  export type PatientContentAdjustmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientContentAdjustment
     */
    select?: PatientContentAdjustmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientContentAdjustmentInclude<ExtArgs> | null
    /**
     * The filter to search for the PatientContentAdjustment to update in case it exists.
     */
    where: PatientContentAdjustmentWhereUniqueInput
    /**
     * In case the PatientContentAdjustment found by the `where` argument doesn't exist, create a new PatientContentAdjustment with this data.
     */
    create: XOR<PatientContentAdjustmentCreateInput, PatientContentAdjustmentUncheckedCreateInput>
    /**
     * In case the PatientContentAdjustment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatientContentAdjustmentUpdateInput, PatientContentAdjustmentUncheckedUpdateInput>
  }

  /**
   * PatientContentAdjustment delete
   */
  export type PatientContentAdjustmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientContentAdjustment
     */
    select?: PatientContentAdjustmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientContentAdjustmentInclude<ExtArgs> | null
    /**
     * Filter which PatientContentAdjustment to delete.
     */
    where: PatientContentAdjustmentWhereUniqueInput
  }

  /**
   * PatientContentAdjustment deleteMany
   */
  export type PatientContentAdjustmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PatientContentAdjustments to delete
     */
    where?: PatientContentAdjustmentWhereInput
  }

  /**
   * PatientContentAdjustment.baseContent
   */
  export type PatientContentAdjustment$baseContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClinicContent
     */
    select?: ClinicContentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicContentInclude<ExtArgs> | null
    where?: ClinicContentWhereInput
  }

  /**
   * PatientContentAdjustment without action
   */
  export type PatientContentAdjustmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientContentAdjustment
     */
    select?: PatientContentAdjustmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientContentAdjustmentInclude<ExtArgs> | null
  }


  /**
   * Model TrainingProtocol
   */

  export type AggregateTrainingProtocol = {
    _count: TrainingProtocolCountAggregateOutputType | null
    _avg: TrainingProtocolAvgAggregateOutputType | null
    _sum: TrainingProtocolSumAggregateOutputType | null
    _min: TrainingProtocolMinAggregateOutputType | null
    _max: TrainingProtocolMaxAggregateOutputType | null
  }

  export type TrainingProtocolAvgAggregateOutputType = {
    totalWeeks: number | null
  }

  export type TrainingProtocolSumAggregateOutputType = {
    totalWeeks: number | null
  }

  export type TrainingProtocolMinAggregateOutputType = {
    id: string | null
    clinicId: string | null
    name: string | null
    surgeryType: string | null
    description: string | null
    totalWeeks: number | null
    isDefault: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingProtocolMaxAggregateOutputType = {
    id: string | null
    clinicId: string | null
    name: string | null
    surgeryType: string | null
    description: string | null
    totalWeeks: number | null
    isDefault: boolean | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingProtocolCountAggregateOutputType = {
    id: number
    clinicId: number
    name: number
    surgeryType: number
    description: number
    totalWeeks: number
    isDefault: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TrainingProtocolAvgAggregateInputType = {
    totalWeeks?: true
  }

  export type TrainingProtocolSumAggregateInputType = {
    totalWeeks?: true
  }

  export type TrainingProtocolMinAggregateInputType = {
    id?: true
    clinicId?: true
    name?: true
    surgeryType?: true
    description?: true
    totalWeeks?: true
    isDefault?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingProtocolMaxAggregateInputType = {
    id?: true
    clinicId?: true
    name?: true
    surgeryType?: true
    description?: true
    totalWeeks?: true
    isDefault?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingProtocolCountAggregateInputType = {
    id?: true
    clinicId?: true
    name?: true
    surgeryType?: true
    description?: true
    totalWeeks?: true
    isDefault?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TrainingProtocolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingProtocol to aggregate.
     */
    where?: TrainingProtocolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingProtocols to fetch.
     */
    orderBy?: TrainingProtocolOrderByWithRelationInput | TrainingProtocolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainingProtocolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingProtocols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingProtocols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrainingProtocols
    **/
    _count?: true | TrainingProtocolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrainingProtocolAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrainingProtocolSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainingProtocolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainingProtocolMaxAggregateInputType
  }

  export type GetTrainingProtocolAggregateType<T extends TrainingProtocolAggregateArgs> = {
        [P in keyof T & keyof AggregateTrainingProtocol]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrainingProtocol[P]>
      : GetScalarType<T[P], AggregateTrainingProtocol[P]>
  }




  export type TrainingProtocolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingProtocolWhereInput
    orderBy?: TrainingProtocolOrderByWithAggregationInput | TrainingProtocolOrderByWithAggregationInput[]
    by: TrainingProtocolScalarFieldEnum[] | TrainingProtocolScalarFieldEnum
    having?: TrainingProtocolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainingProtocolCountAggregateInputType | true
    _avg?: TrainingProtocolAvgAggregateInputType
    _sum?: TrainingProtocolSumAggregateInputType
    _min?: TrainingProtocolMinAggregateInputType
    _max?: TrainingProtocolMaxAggregateInputType
  }

  export type TrainingProtocolGroupByOutputType = {
    id: string
    clinicId: string | null
    name: string
    surgeryType: string | null
    description: string | null
    totalWeeks: number
    isDefault: boolean
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: TrainingProtocolCountAggregateOutputType | null
    _avg: TrainingProtocolAvgAggregateOutputType | null
    _sum: TrainingProtocolSumAggregateOutputType | null
    _min: TrainingProtocolMinAggregateOutputType | null
    _max: TrainingProtocolMaxAggregateOutputType | null
  }

  type GetTrainingProtocolGroupByPayload<T extends TrainingProtocolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrainingProtocolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainingProtocolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainingProtocolGroupByOutputType[P]>
            : GetScalarType<T[P], TrainingProtocolGroupByOutputType[P]>
        }
      >
    >


  export type TrainingProtocolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    name?: boolean
    surgeryType?: boolean
    description?: boolean
    totalWeeks?: boolean
    isDefault?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinic?: boolean | TrainingProtocol$clinicArgs<ExtArgs>
    weeks?: boolean | TrainingProtocol$weeksArgs<ExtArgs>
    _count?: boolean | TrainingProtocolCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingProtocol"]>

  export type TrainingProtocolSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clinicId?: boolean
    name?: boolean
    surgeryType?: boolean
    description?: boolean
    totalWeeks?: boolean
    isDefault?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    clinic?: boolean | TrainingProtocol$clinicArgs<ExtArgs>
  }, ExtArgs["result"]["trainingProtocol"]>

  export type TrainingProtocolSelectScalar = {
    id?: boolean
    clinicId?: boolean
    name?: boolean
    surgeryType?: boolean
    description?: boolean
    totalWeeks?: boolean
    isDefault?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TrainingProtocolInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | TrainingProtocol$clinicArgs<ExtArgs>
    weeks?: boolean | TrainingProtocol$weeksArgs<ExtArgs>
    _count?: boolean | TrainingProtocolCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TrainingProtocolIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    clinic?: boolean | TrainingProtocol$clinicArgs<ExtArgs>
  }

  export type $TrainingProtocolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrainingProtocol"
    objects: {
      clinic: Prisma.$ClinicPayload<ExtArgs> | null
      weeks: Prisma.$TrainingWeekPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clinicId: string | null
      name: string
      surgeryType: string | null
      description: string | null
      totalWeeks: number
      isDefault: boolean
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["trainingProtocol"]>
    composites: {}
  }

  type TrainingProtocolGetPayload<S extends boolean | null | undefined | TrainingProtocolDefaultArgs> = $Result.GetResult<Prisma.$TrainingProtocolPayload, S>

  type TrainingProtocolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TrainingProtocolFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TrainingProtocolCountAggregateInputType | true
    }

  export interface TrainingProtocolDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrainingProtocol'], meta: { name: 'TrainingProtocol' } }
    /**
     * Find zero or one TrainingProtocol that matches the filter.
     * @param {TrainingProtocolFindUniqueArgs} args - Arguments to find a TrainingProtocol
     * @example
     * // Get one TrainingProtocol
     * const trainingProtocol = await prisma.trainingProtocol.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrainingProtocolFindUniqueArgs>(args: SelectSubset<T, TrainingProtocolFindUniqueArgs<ExtArgs>>): Prisma__TrainingProtocolClient<$Result.GetResult<Prisma.$TrainingProtocolPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TrainingProtocol that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TrainingProtocolFindUniqueOrThrowArgs} args - Arguments to find a TrainingProtocol
     * @example
     * // Get one TrainingProtocol
     * const trainingProtocol = await prisma.trainingProtocol.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrainingProtocolFindUniqueOrThrowArgs>(args: SelectSubset<T, TrainingProtocolFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrainingProtocolClient<$Result.GetResult<Prisma.$TrainingProtocolPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TrainingProtocol that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingProtocolFindFirstArgs} args - Arguments to find a TrainingProtocol
     * @example
     * // Get one TrainingProtocol
     * const trainingProtocol = await prisma.trainingProtocol.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrainingProtocolFindFirstArgs>(args?: SelectSubset<T, TrainingProtocolFindFirstArgs<ExtArgs>>): Prisma__TrainingProtocolClient<$Result.GetResult<Prisma.$TrainingProtocolPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TrainingProtocol that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingProtocolFindFirstOrThrowArgs} args - Arguments to find a TrainingProtocol
     * @example
     * // Get one TrainingProtocol
     * const trainingProtocol = await prisma.trainingProtocol.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrainingProtocolFindFirstOrThrowArgs>(args?: SelectSubset<T, TrainingProtocolFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrainingProtocolClient<$Result.GetResult<Prisma.$TrainingProtocolPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TrainingProtocols that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingProtocolFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrainingProtocols
     * const trainingProtocols = await prisma.trainingProtocol.findMany()
     * 
     * // Get first 10 TrainingProtocols
     * const trainingProtocols = await prisma.trainingProtocol.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainingProtocolWithIdOnly = await prisma.trainingProtocol.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrainingProtocolFindManyArgs>(args?: SelectSubset<T, TrainingProtocolFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingProtocolPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TrainingProtocol.
     * @param {TrainingProtocolCreateArgs} args - Arguments to create a TrainingProtocol.
     * @example
     * // Create one TrainingProtocol
     * const TrainingProtocol = await prisma.trainingProtocol.create({
     *   data: {
     *     // ... data to create a TrainingProtocol
     *   }
     * })
     * 
     */
    create<T extends TrainingProtocolCreateArgs>(args: SelectSubset<T, TrainingProtocolCreateArgs<ExtArgs>>): Prisma__TrainingProtocolClient<$Result.GetResult<Prisma.$TrainingProtocolPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TrainingProtocols.
     * @param {TrainingProtocolCreateManyArgs} args - Arguments to create many TrainingProtocols.
     * @example
     * // Create many TrainingProtocols
     * const trainingProtocol = await prisma.trainingProtocol.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrainingProtocolCreateManyArgs>(args?: SelectSubset<T, TrainingProtocolCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrainingProtocols and returns the data saved in the database.
     * @param {TrainingProtocolCreateManyAndReturnArgs} args - Arguments to create many TrainingProtocols.
     * @example
     * // Create many TrainingProtocols
     * const trainingProtocol = await prisma.trainingProtocol.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrainingProtocols and only return the `id`
     * const trainingProtocolWithIdOnly = await prisma.trainingProtocol.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrainingProtocolCreateManyAndReturnArgs>(args?: SelectSubset<T, TrainingProtocolCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingProtocolPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TrainingProtocol.
     * @param {TrainingProtocolDeleteArgs} args - Arguments to delete one TrainingProtocol.
     * @example
     * // Delete one TrainingProtocol
     * const TrainingProtocol = await prisma.trainingProtocol.delete({
     *   where: {
     *     // ... filter to delete one TrainingProtocol
     *   }
     * })
     * 
     */
    delete<T extends TrainingProtocolDeleteArgs>(args: SelectSubset<T, TrainingProtocolDeleteArgs<ExtArgs>>): Prisma__TrainingProtocolClient<$Result.GetResult<Prisma.$TrainingProtocolPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TrainingProtocol.
     * @param {TrainingProtocolUpdateArgs} args - Arguments to update one TrainingProtocol.
     * @example
     * // Update one TrainingProtocol
     * const trainingProtocol = await prisma.trainingProtocol.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrainingProtocolUpdateArgs>(args: SelectSubset<T, TrainingProtocolUpdateArgs<ExtArgs>>): Prisma__TrainingProtocolClient<$Result.GetResult<Prisma.$TrainingProtocolPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TrainingProtocols.
     * @param {TrainingProtocolDeleteManyArgs} args - Arguments to filter TrainingProtocols to delete.
     * @example
     * // Delete a few TrainingProtocols
     * const { count } = await prisma.trainingProtocol.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrainingProtocolDeleteManyArgs>(args?: SelectSubset<T, TrainingProtocolDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingProtocols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingProtocolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrainingProtocols
     * const trainingProtocol = await prisma.trainingProtocol.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrainingProtocolUpdateManyArgs>(args: SelectSubset<T, TrainingProtocolUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TrainingProtocol.
     * @param {TrainingProtocolUpsertArgs} args - Arguments to update or create a TrainingProtocol.
     * @example
     * // Update or create a TrainingProtocol
     * const trainingProtocol = await prisma.trainingProtocol.upsert({
     *   create: {
     *     // ... data to create a TrainingProtocol
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrainingProtocol we want to update
     *   }
     * })
     */
    upsert<T extends TrainingProtocolUpsertArgs>(args: SelectSubset<T, TrainingProtocolUpsertArgs<ExtArgs>>): Prisma__TrainingProtocolClient<$Result.GetResult<Prisma.$TrainingProtocolPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TrainingProtocols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingProtocolCountArgs} args - Arguments to filter TrainingProtocols to count.
     * @example
     * // Count the number of TrainingProtocols
     * const count = await prisma.trainingProtocol.count({
     *   where: {
     *     // ... the filter for the TrainingProtocols we want to count
     *   }
     * })
    **/
    count<T extends TrainingProtocolCountArgs>(
      args?: Subset<T, TrainingProtocolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainingProtocolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrainingProtocol.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingProtocolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainingProtocolAggregateArgs>(args: Subset<T, TrainingProtocolAggregateArgs>): Prisma.PrismaPromise<GetTrainingProtocolAggregateType<T>>

    /**
     * Group by TrainingProtocol.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingProtocolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainingProtocolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainingProtocolGroupByArgs['orderBy'] }
        : { orderBy?: TrainingProtocolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainingProtocolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainingProtocolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrainingProtocol model
   */
  readonly fields: TrainingProtocolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrainingProtocol.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrainingProtocolClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    clinic<T extends TrainingProtocol$clinicArgs<ExtArgs> = {}>(args?: Subset<T, TrainingProtocol$clinicArgs<ExtArgs>>): Prisma__ClinicClient<$Result.GetResult<Prisma.$ClinicPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    weeks<T extends TrainingProtocol$weeksArgs<ExtArgs> = {}>(args?: Subset<T, TrainingProtocol$weeksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingWeekPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrainingProtocol model
   */ 
  interface TrainingProtocolFieldRefs {
    readonly id: FieldRef<"TrainingProtocol", 'String'>
    readonly clinicId: FieldRef<"TrainingProtocol", 'String'>
    readonly name: FieldRef<"TrainingProtocol", 'String'>
    readonly surgeryType: FieldRef<"TrainingProtocol", 'String'>
    readonly description: FieldRef<"TrainingProtocol", 'String'>
    readonly totalWeeks: FieldRef<"TrainingProtocol", 'Int'>
    readonly isDefault: FieldRef<"TrainingProtocol", 'Boolean'>
    readonly isActive: FieldRef<"TrainingProtocol", 'Boolean'>
    readonly createdAt: FieldRef<"TrainingProtocol", 'DateTime'>
    readonly updatedAt: FieldRef<"TrainingProtocol", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TrainingProtocol findUnique
   */
  export type TrainingProtocolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingProtocol
     */
    select?: TrainingProtocolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingProtocolInclude<ExtArgs> | null
    /**
     * Filter, which TrainingProtocol to fetch.
     */
    where: TrainingProtocolWhereUniqueInput
  }

  /**
   * TrainingProtocol findUniqueOrThrow
   */
  export type TrainingProtocolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingProtocol
     */
    select?: TrainingProtocolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingProtocolInclude<ExtArgs> | null
    /**
     * Filter, which TrainingProtocol to fetch.
     */
    where: TrainingProtocolWhereUniqueInput
  }

  /**
   * TrainingProtocol findFirst
   */
  export type TrainingProtocolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingProtocol
     */
    select?: TrainingProtocolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingProtocolInclude<ExtArgs> | null
    /**
     * Filter, which TrainingProtocol to fetch.
     */
    where?: TrainingProtocolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingProtocols to fetch.
     */
    orderBy?: TrainingProtocolOrderByWithRelationInput | TrainingProtocolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingProtocols.
     */
    cursor?: TrainingProtocolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingProtocols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingProtocols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingProtocols.
     */
    distinct?: TrainingProtocolScalarFieldEnum | TrainingProtocolScalarFieldEnum[]
  }

  /**
   * TrainingProtocol findFirstOrThrow
   */
  export type TrainingProtocolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingProtocol
     */
    select?: TrainingProtocolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingProtocolInclude<ExtArgs> | null
    /**
     * Filter, which TrainingProtocol to fetch.
     */
    where?: TrainingProtocolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingProtocols to fetch.
     */
    orderBy?: TrainingProtocolOrderByWithRelationInput | TrainingProtocolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingProtocols.
     */
    cursor?: TrainingProtocolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingProtocols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingProtocols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingProtocols.
     */
    distinct?: TrainingProtocolScalarFieldEnum | TrainingProtocolScalarFieldEnum[]
  }

  /**
   * TrainingProtocol findMany
   */
  export type TrainingProtocolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingProtocol
     */
    select?: TrainingProtocolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingProtocolInclude<ExtArgs> | null
    /**
     * Filter, which TrainingProtocols to fetch.
     */
    where?: TrainingProtocolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingProtocols to fetch.
     */
    orderBy?: TrainingProtocolOrderByWithRelationInput | TrainingProtocolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrainingProtocols.
     */
    cursor?: TrainingProtocolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingProtocols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingProtocols.
     */
    skip?: number
    distinct?: TrainingProtocolScalarFieldEnum | TrainingProtocolScalarFieldEnum[]
  }

  /**
   * TrainingProtocol create
   */
  export type TrainingProtocolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingProtocol
     */
    select?: TrainingProtocolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingProtocolInclude<ExtArgs> | null
    /**
     * The data needed to create a TrainingProtocol.
     */
    data: XOR<TrainingProtocolCreateInput, TrainingProtocolUncheckedCreateInput>
  }

  /**
   * TrainingProtocol createMany
   */
  export type TrainingProtocolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrainingProtocols.
     */
    data: TrainingProtocolCreateManyInput | TrainingProtocolCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrainingProtocol createManyAndReturn
   */
  export type TrainingProtocolCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingProtocol
     */
    select?: TrainingProtocolSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TrainingProtocols.
     */
    data: TrainingProtocolCreateManyInput | TrainingProtocolCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingProtocolIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainingProtocol update
   */
  export type TrainingProtocolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingProtocol
     */
    select?: TrainingProtocolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingProtocolInclude<ExtArgs> | null
    /**
     * The data needed to update a TrainingProtocol.
     */
    data: XOR<TrainingProtocolUpdateInput, TrainingProtocolUncheckedUpdateInput>
    /**
     * Choose, which TrainingProtocol to update.
     */
    where: TrainingProtocolWhereUniqueInput
  }

  /**
   * TrainingProtocol updateMany
   */
  export type TrainingProtocolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrainingProtocols.
     */
    data: XOR<TrainingProtocolUpdateManyMutationInput, TrainingProtocolUncheckedUpdateManyInput>
    /**
     * Filter which TrainingProtocols to update
     */
    where?: TrainingProtocolWhereInput
  }

  /**
   * TrainingProtocol upsert
   */
  export type TrainingProtocolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingProtocol
     */
    select?: TrainingProtocolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingProtocolInclude<ExtArgs> | null
    /**
     * The filter to search for the TrainingProtocol to update in case it exists.
     */
    where: TrainingProtocolWhereUniqueInput
    /**
     * In case the TrainingProtocol found by the `where` argument doesn't exist, create a new TrainingProtocol with this data.
     */
    create: XOR<TrainingProtocolCreateInput, TrainingProtocolUncheckedCreateInput>
    /**
     * In case the TrainingProtocol was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainingProtocolUpdateInput, TrainingProtocolUncheckedUpdateInput>
  }

  /**
   * TrainingProtocol delete
   */
  export type TrainingProtocolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingProtocol
     */
    select?: TrainingProtocolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingProtocolInclude<ExtArgs> | null
    /**
     * Filter which TrainingProtocol to delete.
     */
    where: TrainingProtocolWhereUniqueInput
  }

  /**
   * TrainingProtocol deleteMany
   */
  export type TrainingProtocolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingProtocols to delete
     */
    where?: TrainingProtocolWhereInput
  }

  /**
   * TrainingProtocol.clinic
   */
  export type TrainingProtocol$clinicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Clinic
     */
    select?: ClinicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClinicInclude<ExtArgs> | null
    where?: ClinicWhereInput
  }

  /**
   * TrainingProtocol.weeks
   */
  export type TrainingProtocol$weeksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingWeek
     */
    select?: TrainingWeekSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingWeekInclude<ExtArgs> | null
    where?: TrainingWeekWhereInput
    orderBy?: TrainingWeekOrderByWithRelationInput | TrainingWeekOrderByWithRelationInput[]
    cursor?: TrainingWeekWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingWeekScalarFieldEnum | TrainingWeekScalarFieldEnum[]
  }

  /**
   * TrainingProtocol without action
   */
  export type TrainingProtocolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingProtocol
     */
    select?: TrainingProtocolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingProtocolInclude<ExtArgs> | null
  }


  /**
   * Model TrainingWeek
   */

  export type AggregateTrainingWeek = {
    _count: TrainingWeekCountAggregateOutputType | null
    _avg: TrainingWeekAvgAggregateOutputType | null
    _sum: TrainingWeekSumAggregateOutputType | null
    _min: TrainingWeekMinAggregateOutputType | null
    _max: TrainingWeekMaxAggregateOutputType | null
  }

  export type TrainingWeekAvgAggregateOutputType = {
    weekNumber: number | null
    maxHeartRate: number | null
    sortOrder: number | null
  }

  export type TrainingWeekSumAggregateOutputType = {
    weekNumber: number | null
    maxHeartRate: number | null
    sortOrder: number | null
  }

  export type TrainingWeekMinAggregateOutputType = {
    id: string | null
    protocolId: string | null
    weekNumber: number | null
    title: string | null
    dayRange: string | null
    objective: string | null
    maxHeartRate: number | null
    heartRateLabel: string | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingWeekMaxAggregateOutputType = {
    id: string | null
    protocolId: string | null
    weekNumber: number | null
    title: string | null
    dayRange: string | null
    objective: string | null
    maxHeartRate: number | null
    heartRateLabel: string | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingWeekCountAggregateOutputType = {
    id: number
    protocolId: number
    weekNumber: number
    title: number
    dayRange: number
    objective: number
    maxHeartRate: number
    heartRateLabel: number
    canDo: number
    avoid: number
    sortOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TrainingWeekAvgAggregateInputType = {
    weekNumber?: true
    maxHeartRate?: true
    sortOrder?: true
  }

  export type TrainingWeekSumAggregateInputType = {
    weekNumber?: true
    maxHeartRate?: true
    sortOrder?: true
  }

  export type TrainingWeekMinAggregateInputType = {
    id?: true
    protocolId?: true
    weekNumber?: true
    title?: true
    dayRange?: true
    objective?: true
    maxHeartRate?: true
    heartRateLabel?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingWeekMaxAggregateInputType = {
    id?: true
    protocolId?: true
    weekNumber?: true
    title?: true
    dayRange?: true
    objective?: true
    maxHeartRate?: true
    heartRateLabel?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingWeekCountAggregateInputType = {
    id?: true
    protocolId?: true
    weekNumber?: true
    title?: true
    dayRange?: true
    objective?: true
    maxHeartRate?: true
    heartRateLabel?: true
    canDo?: true
    avoid?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TrainingWeekAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingWeek to aggregate.
     */
    where?: TrainingWeekWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingWeeks to fetch.
     */
    orderBy?: TrainingWeekOrderByWithRelationInput | TrainingWeekOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainingWeekWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingWeeks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingWeeks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrainingWeeks
    **/
    _count?: true | TrainingWeekCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrainingWeekAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrainingWeekSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainingWeekMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainingWeekMaxAggregateInputType
  }

  export type GetTrainingWeekAggregateType<T extends TrainingWeekAggregateArgs> = {
        [P in keyof T & keyof AggregateTrainingWeek]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrainingWeek[P]>
      : GetScalarType<T[P], AggregateTrainingWeek[P]>
  }




  export type TrainingWeekGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingWeekWhereInput
    orderBy?: TrainingWeekOrderByWithAggregationInput | TrainingWeekOrderByWithAggregationInput[]
    by: TrainingWeekScalarFieldEnum[] | TrainingWeekScalarFieldEnum
    having?: TrainingWeekScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainingWeekCountAggregateInputType | true
    _avg?: TrainingWeekAvgAggregateInputType
    _sum?: TrainingWeekSumAggregateInputType
    _min?: TrainingWeekMinAggregateInputType
    _max?: TrainingWeekMaxAggregateInputType
  }

  export type TrainingWeekGroupByOutputType = {
    id: string
    protocolId: string
    weekNumber: number
    title: string
    dayRange: string
    objective: string
    maxHeartRate: number | null
    heartRateLabel: string | null
    canDo: string[]
    avoid: string[]
    sortOrder: number
    createdAt: Date
    updatedAt: Date
    _count: TrainingWeekCountAggregateOutputType | null
    _avg: TrainingWeekAvgAggregateOutputType | null
    _sum: TrainingWeekSumAggregateOutputType | null
    _min: TrainingWeekMinAggregateOutputType | null
    _max: TrainingWeekMaxAggregateOutputType | null
  }

  type GetTrainingWeekGroupByPayload<T extends TrainingWeekGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrainingWeekGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainingWeekGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainingWeekGroupByOutputType[P]>
            : GetScalarType<T[P], TrainingWeekGroupByOutputType[P]>
        }
      >
    >


  export type TrainingWeekSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    protocolId?: boolean
    weekNumber?: boolean
    title?: boolean
    dayRange?: boolean
    objective?: boolean
    maxHeartRate?: boolean
    heartRateLabel?: boolean
    canDo?: boolean
    avoid?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    protocol?: boolean | TrainingProtocolDefaultArgs<ExtArgs>
    sessions?: boolean | TrainingWeek$sessionsArgs<ExtArgs>
    progress?: boolean | TrainingWeek$progressArgs<ExtArgs>
    _count?: boolean | TrainingWeekCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingWeek"]>

  export type TrainingWeekSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    protocolId?: boolean
    weekNumber?: boolean
    title?: boolean
    dayRange?: boolean
    objective?: boolean
    maxHeartRate?: boolean
    heartRateLabel?: boolean
    canDo?: boolean
    avoid?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    protocol?: boolean | TrainingProtocolDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingWeek"]>

  export type TrainingWeekSelectScalar = {
    id?: boolean
    protocolId?: boolean
    weekNumber?: boolean
    title?: boolean
    dayRange?: boolean
    objective?: boolean
    maxHeartRate?: boolean
    heartRateLabel?: boolean
    canDo?: boolean
    avoid?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TrainingWeekInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    protocol?: boolean | TrainingProtocolDefaultArgs<ExtArgs>
    sessions?: boolean | TrainingWeek$sessionsArgs<ExtArgs>
    progress?: boolean | TrainingWeek$progressArgs<ExtArgs>
    _count?: boolean | TrainingWeekCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TrainingWeekIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    protocol?: boolean | TrainingProtocolDefaultArgs<ExtArgs>
  }

  export type $TrainingWeekPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrainingWeek"
    objects: {
      protocol: Prisma.$TrainingProtocolPayload<ExtArgs>
      sessions: Prisma.$TrainingSessionPayload<ExtArgs>[]
      progress: Prisma.$PatientTrainingProgressPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      protocolId: string
      weekNumber: number
      title: string
      dayRange: string
      objective: string
      maxHeartRate: number | null
      heartRateLabel: string | null
      canDo: string[]
      avoid: string[]
      sortOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["trainingWeek"]>
    composites: {}
  }

  type TrainingWeekGetPayload<S extends boolean | null | undefined | TrainingWeekDefaultArgs> = $Result.GetResult<Prisma.$TrainingWeekPayload, S>

  type TrainingWeekCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TrainingWeekFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TrainingWeekCountAggregateInputType | true
    }

  export interface TrainingWeekDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrainingWeek'], meta: { name: 'TrainingWeek' } }
    /**
     * Find zero or one TrainingWeek that matches the filter.
     * @param {TrainingWeekFindUniqueArgs} args - Arguments to find a TrainingWeek
     * @example
     * // Get one TrainingWeek
     * const trainingWeek = await prisma.trainingWeek.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrainingWeekFindUniqueArgs>(args: SelectSubset<T, TrainingWeekFindUniqueArgs<ExtArgs>>): Prisma__TrainingWeekClient<$Result.GetResult<Prisma.$TrainingWeekPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TrainingWeek that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TrainingWeekFindUniqueOrThrowArgs} args - Arguments to find a TrainingWeek
     * @example
     * // Get one TrainingWeek
     * const trainingWeek = await prisma.trainingWeek.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrainingWeekFindUniqueOrThrowArgs>(args: SelectSubset<T, TrainingWeekFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrainingWeekClient<$Result.GetResult<Prisma.$TrainingWeekPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TrainingWeek that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingWeekFindFirstArgs} args - Arguments to find a TrainingWeek
     * @example
     * // Get one TrainingWeek
     * const trainingWeek = await prisma.trainingWeek.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrainingWeekFindFirstArgs>(args?: SelectSubset<T, TrainingWeekFindFirstArgs<ExtArgs>>): Prisma__TrainingWeekClient<$Result.GetResult<Prisma.$TrainingWeekPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TrainingWeek that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingWeekFindFirstOrThrowArgs} args - Arguments to find a TrainingWeek
     * @example
     * // Get one TrainingWeek
     * const trainingWeek = await prisma.trainingWeek.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrainingWeekFindFirstOrThrowArgs>(args?: SelectSubset<T, TrainingWeekFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrainingWeekClient<$Result.GetResult<Prisma.$TrainingWeekPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TrainingWeeks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingWeekFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrainingWeeks
     * const trainingWeeks = await prisma.trainingWeek.findMany()
     * 
     * // Get first 10 TrainingWeeks
     * const trainingWeeks = await prisma.trainingWeek.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainingWeekWithIdOnly = await prisma.trainingWeek.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrainingWeekFindManyArgs>(args?: SelectSubset<T, TrainingWeekFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingWeekPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TrainingWeek.
     * @param {TrainingWeekCreateArgs} args - Arguments to create a TrainingWeek.
     * @example
     * // Create one TrainingWeek
     * const TrainingWeek = await prisma.trainingWeek.create({
     *   data: {
     *     // ... data to create a TrainingWeek
     *   }
     * })
     * 
     */
    create<T extends TrainingWeekCreateArgs>(args: SelectSubset<T, TrainingWeekCreateArgs<ExtArgs>>): Prisma__TrainingWeekClient<$Result.GetResult<Prisma.$TrainingWeekPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TrainingWeeks.
     * @param {TrainingWeekCreateManyArgs} args - Arguments to create many TrainingWeeks.
     * @example
     * // Create many TrainingWeeks
     * const trainingWeek = await prisma.trainingWeek.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrainingWeekCreateManyArgs>(args?: SelectSubset<T, TrainingWeekCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrainingWeeks and returns the data saved in the database.
     * @param {TrainingWeekCreateManyAndReturnArgs} args - Arguments to create many TrainingWeeks.
     * @example
     * // Create many TrainingWeeks
     * const trainingWeek = await prisma.trainingWeek.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrainingWeeks and only return the `id`
     * const trainingWeekWithIdOnly = await prisma.trainingWeek.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrainingWeekCreateManyAndReturnArgs>(args?: SelectSubset<T, TrainingWeekCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingWeekPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TrainingWeek.
     * @param {TrainingWeekDeleteArgs} args - Arguments to delete one TrainingWeek.
     * @example
     * // Delete one TrainingWeek
     * const TrainingWeek = await prisma.trainingWeek.delete({
     *   where: {
     *     // ... filter to delete one TrainingWeek
     *   }
     * })
     * 
     */
    delete<T extends TrainingWeekDeleteArgs>(args: SelectSubset<T, TrainingWeekDeleteArgs<ExtArgs>>): Prisma__TrainingWeekClient<$Result.GetResult<Prisma.$TrainingWeekPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TrainingWeek.
     * @param {TrainingWeekUpdateArgs} args - Arguments to update one TrainingWeek.
     * @example
     * // Update one TrainingWeek
     * const trainingWeek = await prisma.trainingWeek.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrainingWeekUpdateArgs>(args: SelectSubset<T, TrainingWeekUpdateArgs<ExtArgs>>): Prisma__TrainingWeekClient<$Result.GetResult<Prisma.$TrainingWeekPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TrainingWeeks.
     * @param {TrainingWeekDeleteManyArgs} args - Arguments to filter TrainingWeeks to delete.
     * @example
     * // Delete a few TrainingWeeks
     * const { count } = await prisma.trainingWeek.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrainingWeekDeleteManyArgs>(args?: SelectSubset<T, TrainingWeekDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingWeeks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingWeekUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrainingWeeks
     * const trainingWeek = await prisma.trainingWeek.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrainingWeekUpdateManyArgs>(args: SelectSubset<T, TrainingWeekUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TrainingWeek.
     * @param {TrainingWeekUpsertArgs} args - Arguments to update or create a TrainingWeek.
     * @example
     * // Update or create a TrainingWeek
     * const trainingWeek = await prisma.trainingWeek.upsert({
     *   create: {
     *     // ... data to create a TrainingWeek
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrainingWeek we want to update
     *   }
     * })
     */
    upsert<T extends TrainingWeekUpsertArgs>(args: SelectSubset<T, TrainingWeekUpsertArgs<ExtArgs>>): Prisma__TrainingWeekClient<$Result.GetResult<Prisma.$TrainingWeekPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TrainingWeeks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingWeekCountArgs} args - Arguments to filter TrainingWeeks to count.
     * @example
     * // Count the number of TrainingWeeks
     * const count = await prisma.trainingWeek.count({
     *   where: {
     *     // ... the filter for the TrainingWeeks we want to count
     *   }
     * })
    **/
    count<T extends TrainingWeekCountArgs>(
      args?: Subset<T, TrainingWeekCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainingWeekCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrainingWeek.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingWeekAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainingWeekAggregateArgs>(args: Subset<T, TrainingWeekAggregateArgs>): Prisma.PrismaPromise<GetTrainingWeekAggregateType<T>>

    /**
     * Group by TrainingWeek.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingWeekGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainingWeekGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainingWeekGroupByArgs['orderBy'] }
        : { orderBy?: TrainingWeekGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainingWeekGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainingWeekGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrainingWeek model
   */
  readonly fields: TrainingWeekFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrainingWeek.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrainingWeekClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    protocol<T extends TrainingProtocolDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrainingProtocolDefaultArgs<ExtArgs>>): Prisma__TrainingProtocolClient<$Result.GetResult<Prisma.$TrainingProtocolPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sessions<T extends TrainingWeek$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, TrainingWeek$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingSessionPayload<ExtArgs>, T, "findMany"> | Null>
    progress<T extends TrainingWeek$progressArgs<ExtArgs> = {}>(args?: Subset<T, TrainingWeek$progressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientTrainingProgressPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrainingWeek model
   */ 
  interface TrainingWeekFieldRefs {
    readonly id: FieldRef<"TrainingWeek", 'String'>
    readonly protocolId: FieldRef<"TrainingWeek", 'String'>
    readonly weekNumber: FieldRef<"TrainingWeek", 'Int'>
    readonly title: FieldRef<"TrainingWeek", 'String'>
    readonly dayRange: FieldRef<"TrainingWeek", 'String'>
    readonly objective: FieldRef<"TrainingWeek", 'String'>
    readonly maxHeartRate: FieldRef<"TrainingWeek", 'Int'>
    readonly heartRateLabel: FieldRef<"TrainingWeek", 'String'>
    readonly canDo: FieldRef<"TrainingWeek", 'String[]'>
    readonly avoid: FieldRef<"TrainingWeek", 'String[]'>
    readonly sortOrder: FieldRef<"TrainingWeek", 'Int'>
    readonly createdAt: FieldRef<"TrainingWeek", 'DateTime'>
    readonly updatedAt: FieldRef<"TrainingWeek", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TrainingWeek findUnique
   */
  export type TrainingWeekFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingWeek
     */
    select?: TrainingWeekSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingWeekInclude<ExtArgs> | null
    /**
     * Filter, which TrainingWeek to fetch.
     */
    where: TrainingWeekWhereUniqueInput
  }

  /**
   * TrainingWeek findUniqueOrThrow
   */
  export type TrainingWeekFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingWeek
     */
    select?: TrainingWeekSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingWeekInclude<ExtArgs> | null
    /**
     * Filter, which TrainingWeek to fetch.
     */
    where: TrainingWeekWhereUniqueInput
  }

  /**
   * TrainingWeek findFirst
   */
  export type TrainingWeekFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingWeek
     */
    select?: TrainingWeekSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingWeekInclude<ExtArgs> | null
    /**
     * Filter, which TrainingWeek to fetch.
     */
    where?: TrainingWeekWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingWeeks to fetch.
     */
    orderBy?: TrainingWeekOrderByWithRelationInput | TrainingWeekOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingWeeks.
     */
    cursor?: TrainingWeekWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingWeeks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingWeeks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingWeeks.
     */
    distinct?: TrainingWeekScalarFieldEnum | TrainingWeekScalarFieldEnum[]
  }

  /**
   * TrainingWeek findFirstOrThrow
   */
  export type TrainingWeekFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingWeek
     */
    select?: TrainingWeekSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingWeekInclude<ExtArgs> | null
    /**
     * Filter, which TrainingWeek to fetch.
     */
    where?: TrainingWeekWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingWeeks to fetch.
     */
    orderBy?: TrainingWeekOrderByWithRelationInput | TrainingWeekOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingWeeks.
     */
    cursor?: TrainingWeekWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingWeeks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingWeeks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingWeeks.
     */
    distinct?: TrainingWeekScalarFieldEnum | TrainingWeekScalarFieldEnum[]
  }

  /**
   * TrainingWeek findMany
   */
  export type TrainingWeekFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingWeek
     */
    select?: TrainingWeekSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingWeekInclude<ExtArgs> | null
    /**
     * Filter, which TrainingWeeks to fetch.
     */
    where?: TrainingWeekWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingWeeks to fetch.
     */
    orderBy?: TrainingWeekOrderByWithRelationInput | TrainingWeekOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrainingWeeks.
     */
    cursor?: TrainingWeekWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingWeeks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingWeeks.
     */
    skip?: number
    distinct?: TrainingWeekScalarFieldEnum | TrainingWeekScalarFieldEnum[]
  }

  /**
   * TrainingWeek create
   */
  export type TrainingWeekCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingWeek
     */
    select?: TrainingWeekSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingWeekInclude<ExtArgs> | null
    /**
     * The data needed to create a TrainingWeek.
     */
    data: XOR<TrainingWeekCreateInput, TrainingWeekUncheckedCreateInput>
  }

  /**
   * TrainingWeek createMany
   */
  export type TrainingWeekCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrainingWeeks.
     */
    data: TrainingWeekCreateManyInput | TrainingWeekCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrainingWeek createManyAndReturn
   */
  export type TrainingWeekCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingWeek
     */
    select?: TrainingWeekSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TrainingWeeks.
     */
    data: TrainingWeekCreateManyInput | TrainingWeekCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingWeekIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainingWeek update
   */
  export type TrainingWeekUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingWeek
     */
    select?: TrainingWeekSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingWeekInclude<ExtArgs> | null
    /**
     * The data needed to update a TrainingWeek.
     */
    data: XOR<TrainingWeekUpdateInput, TrainingWeekUncheckedUpdateInput>
    /**
     * Choose, which TrainingWeek to update.
     */
    where: TrainingWeekWhereUniqueInput
  }

  /**
   * TrainingWeek updateMany
   */
  export type TrainingWeekUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrainingWeeks.
     */
    data: XOR<TrainingWeekUpdateManyMutationInput, TrainingWeekUncheckedUpdateManyInput>
    /**
     * Filter which TrainingWeeks to update
     */
    where?: TrainingWeekWhereInput
  }

  /**
   * TrainingWeek upsert
   */
  export type TrainingWeekUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingWeek
     */
    select?: TrainingWeekSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingWeekInclude<ExtArgs> | null
    /**
     * The filter to search for the TrainingWeek to update in case it exists.
     */
    where: TrainingWeekWhereUniqueInput
    /**
     * In case the TrainingWeek found by the `where` argument doesn't exist, create a new TrainingWeek with this data.
     */
    create: XOR<TrainingWeekCreateInput, TrainingWeekUncheckedCreateInput>
    /**
     * In case the TrainingWeek was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainingWeekUpdateInput, TrainingWeekUncheckedUpdateInput>
  }

  /**
   * TrainingWeek delete
   */
  export type TrainingWeekDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingWeek
     */
    select?: TrainingWeekSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingWeekInclude<ExtArgs> | null
    /**
     * Filter which TrainingWeek to delete.
     */
    where: TrainingWeekWhereUniqueInput
  }

  /**
   * TrainingWeek deleteMany
   */
  export type TrainingWeekDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingWeeks to delete
     */
    where?: TrainingWeekWhereInput
  }

  /**
   * TrainingWeek.sessions
   */
  export type TrainingWeek$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSession
     */
    select?: TrainingSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSessionInclude<ExtArgs> | null
    where?: TrainingSessionWhereInput
    orderBy?: TrainingSessionOrderByWithRelationInput | TrainingSessionOrderByWithRelationInput[]
    cursor?: TrainingSessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrainingSessionScalarFieldEnum | TrainingSessionScalarFieldEnum[]
  }

  /**
   * TrainingWeek.progress
   */
  export type TrainingWeek$progressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientTrainingProgress
     */
    select?: PatientTrainingProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientTrainingProgressInclude<ExtArgs> | null
    where?: PatientTrainingProgressWhereInput
    orderBy?: PatientTrainingProgressOrderByWithRelationInput | PatientTrainingProgressOrderByWithRelationInput[]
    cursor?: PatientTrainingProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatientTrainingProgressScalarFieldEnum | PatientTrainingProgressScalarFieldEnum[]
  }

  /**
   * TrainingWeek without action
   */
  export type TrainingWeekDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingWeek
     */
    select?: TrainingWeekSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingWeekInclude<ExtArgs> | null
  }


  /**
   * Model TrainingSession
   */

  export type AggregateTrainingSession = {
    _count: TrainingSessionCountAggregateOutputType | null
    _avg: TrainingSessionAvgAggregateOutputType | null
    _sum: TrainingSessionSumAggregateOutputType | null
    _min: TrainingSessionMinAggregateOutputType | null
    _max: TrainingSessionMaxAggregateOutputType | null
  }

  export type TrainingSessionAvgAggregateOutputType = {
    sessionNumber: number | null
    duration: number | null
    sortOrder: number | null
  }

  export type TrainingSessionSumAggregateOutputType = {
    sessionNumber: number | null
    duration: number | null
    sortOrder: number | null
  }

  export type TrainingSessionMinAggregateOutputType = {
    id: string | null
    weekId: string | null
    sessionNumber: number | null
    name: string | null
    description: string | null
    duration: number | null
    intensity: string | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingSessionMaxAggregateOutputType = {
    id: string | null
    weekId: string | null
    sessionNumber: number | null
    name: string | null
    description: string | null
    duration: number | null
    intensity: string | null
    sortOrder: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TrainingSessionCountAggregateOutputType = {
    id: number
    weekId: number
    sessionNumber: number
    name: number
    description: number
    duration: number
    intensity: number
    sortOrder: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TrainingSessionAvgAggregateInputType = {
    sessionNumber?: true
    duration?: true
    sortOrder?: true
  }

  export type TrainingSessionSumAggregateInputType = {
    sessionNumber?: true
    duration?: true
    sortOrder?: true
  }

  export type TrainingSessionMinAggregateInputType = {
    id?: true
    weekId?: true
    sessionNumber?: true
    name?: true
    description?: true
    duration?: true
    intensity?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingSessionMaxAggregateInputType = {
    id?: true
    weekId?: true
    sessionNumber?: true
    name?: true
    description?: true
    duration?: true
    intensity?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TrainingSessionCountAggregateInputType = {
    id?: true
    weekId?: true
    sessionNumber?: true
    name?: true
    description?: true
    duration?: true
    intensity?: true
    sortOrder?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TrainingSessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingSession to aggregate.
     */
    where?: TrainingSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingSessions to fetch.
     */
    orderBy?: TrainingSessionOrderByWithRelationInput | TrainingSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrainingSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrainingSessions
    **/
    _count?: true | TrainingSessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrainingSessionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrainingSessionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrainingSessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrainingSessionMaxAggregateInputType
  }

  export type GetTrainingSessionAggregateType<T extends TrainingSessionAggregateArgs> = {
        [P in keyof T & keyof AggregateTrainingSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrainingSession[P]>
      : GetScalarType<T[P], AggregateTrainingSession[P]>
  }




  export type TrainingSessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrainingSessionWhereInput
    orderBy?: TrainingSessionOrderByWithAggregationInput | TrainingSessionOrderByWithAggregationInput[]
    by: TrainingSessionScalarFieldEnum[] | TrainingSessionScalarFieldEnum
    having?: TrainingSessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrainingSessionCountAggregateInputType | true
    _avg?: TrainingSessionAvgAggregateInputType
    _sum?: TrainingSessionSumAggregateInputType
    _min?: TrainingSessionMinAggregateInputType
    _max?: TrainingSessionMaxAggregateInputType
  }

  export type TrainingSessionGroupByOutputType = {
    id: string
    weekId: string
    sessionNumber: number
    name: string
    description: string | null
    duration: number | null
    intensity: string | null
    sortOrder: number
    createdAt: Date
    updatedAt: Date
    _count: TrainingSessionCountAggregateOutputType | null
    _avg: TrainingSessionAvgAggregateOutputType | null
    _sum: TrainingSessionSumAggregateOutputType | null
    _min: TrainingSessionMinAggregateOutputType | null
    _max: TrainingSessionMaxAggregateOutputType | null
  }

  type GetTrainingSessionGroupByPayload<T extends TrainingSessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrainingSessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrainingSessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrainingSessionGroupByOutputType[P]>
            : GetScalarType<T[P], TrainingSessionGroupByOutputType[P]>
        }
      >
    >


  export type TrainingSessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    weekId?: boolean
    sessionNumber?: boolean
    name?: boolean
    description?: boolean
    duration?: boolean
    intensity?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    week?: boolean | TrainingWeekDefaultArgs<ExtArgs>
    completions?: boolean | TrainingSession$completionsArgs<ExtArgs>
    _count?: boolean | TrainingSessionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingSession"]>

  export type TrainingSessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    weekId?: boolean
    sessionNumber?: boolean
    name?: boolean
    description?: boolean
    duration?: boolean
    intensity?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    week?: boolean | TrainingWeekDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trainingSession"]>

  export type TrainingSessionSelectScalar = {
    id?: boolean
    weekId?: boolean
    sessionNumber?: boolean
    name?: boolean
    description?: boolean
    duration?: boolean
    intensity?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TrainingSessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    week?: boolean | TrainingWeekDefaultArgs<ExtArgs>
    completions?: boolean | TrainingSession$completionsArgs<ExtArgs>
    _count?: boolean | TrainingSessionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TrainingSessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    week?: boolean | TrainingWeekDefaultArgs<ExtArgs>
  }

  export type $TrainingSessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrainingSession"
    objects: {
      week: Prisma.$TrainingWeekPayload<ExtArgs>
      completions: Prisma.$PatientSessionCompletionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      weekId: string
      sessionNumber: number
      name: string
      description: string | null
      duration: number | null
      intensity: string | null
      sortOrder: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["trainingSession"]>
    composites: {}
  }

  type TrainingSessionGetPayload<S extends boolean | null | undefined | TrainingSessionDefaultArgs> = $Result.GetResult<Prisma.$TrainingSessionPayload, S>

  type TrainingSessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TrainingSessionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TrainingSessionCountAggregateInputType | true
    }

  export interface TrainingSessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrainingSession'], meta: { name: 'TrainingSession' } }
    /**
     * Find zero or one TrainingSession that matches the filter.
     * @param {TrainingSessionFindUniqueArgs} args - Arguments to find a TrainingSession
     * @example
     * // Get one TrainingSession
     * const trainingSession = await prisma.trainingSession.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrainingSessionFindUniqueArgs>(args: SelectSubset<T, TrainingSessionFindUniqueArgs<ExtArgs>>): Prisma__TrainingSessionClient<$Result.GetResult<Prisma.$TrainingSessionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TrainingSession that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TrainingSessionFindUniqueOrThrowArgs} args - Arguments to find a TrainingSession
     * @example
     * // Get one TrainingSession
     * const trainingSession = await prisma.trainingSession.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrainingSessionFindUniqueOrThrowArgs>(args: SelectSubset<T, TrainingSessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrainingSessionClient<$Result.GetResult<Prisma.$TrainingSessionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TrainingSession that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingSessionFindFirstArgs} args - Arguments to find a TrainingSession
     * @example
     * // Get one TrainingSession
     * const trainingSession = await prisma.trainingSession.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrainingSessionFindFirstArgs>(args?: SelectSubset<T, TrainingSessionFindFirstArgs<ExtArgs>>): Prisma__TrainingSessionClient<$Result.GetResult<Prisma.$TrainingSessionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TrainingSession that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingSessionFindFirstOrThrowArgs} args - Arguments to find a TrainingSession
     * @example
     * // Get one TrainingSession
     * const trainingSession = await prisma.trainingSession.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrainingSessionFindFirstOrThrowArgs>(args?: SelectSubset<T, TrainingSessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrainingSessionClient<$Result.GetResult<Prisma.$TrainingSessionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TrainingSessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingSessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrainingSessions
     * const trainingSessions = await prisma.trainingSession.findMany()
     * 
     * // Get first 10 TrainingSessions
     * const trainingSessions = await prisma.trainingSession.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trainingSessionWithIdOnly = await prisma.trainingSession.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrainingSessionFindManyArgs>(args?: SelectSubset<T, TrainingSessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingSessionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TrainingSession.
     * @param {TrainingSessionCreateArgs} args - Arguments to create a TrainingSession.
     * @example
     * // Create one TrainingSession
     * const TrainingSession = await prisma.trainingSession.create({
     *   data: {
     *     // ... data to create a TrainingSession
     *   }
     * })
     * 
     */
    create<T extends TrainingSessionCreateArgs>(args: SelectSubset<T, TrainingSessionCreateArgs<ExtArgs>>): Prisma__TrainingSessionClient<$Result.GetResult<Prisma.$TrainingSessionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TrainingSessions.
     * @param {TrainingSessionCreateManyArgs} args - Arguments to create many TrainingSessions.
     * @example
     * // Create many TrainingSessions
     * const trainingSession = await prisma.trainingSession.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrainingSessionCreateManyArgs>(args?: SelectSubset<T, TrainingSessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrainingSessions and returns the data saved in the database.
     * @param {TrainingSessionCreateManyAndReturnArgs} args - Arguments to create many TrainingSessions.
     * @example
     * // Create many TrainingSessions
     * const trainingSession = await prisma.trainingSession.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrainingSessions and only return the `id`
     * const trainingSessionWithIdOnly = await prisma.trainingSession.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrainingSessionCreateManyAndReturnArgs>(args?: SelectSubset<T, TrainingSessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrainingSessionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TrainingSession.
     * @param {TrainingSessionDeleteArgs} args - Arguments to delete one TrainingSession.
     * @example
     * // Delete one TrainingSession
     * const TrainingSession = await prisma.trainingSession.delete({
     *   where: {
     *     // ... filter to delete one TrainingSession
     *   }
     * })
     * 
     */
    delete<T extends TrainingSessionDeleteArgs>(args: SelectSubset<T, TrainingSessionDeleteArgs<ExtArgs>>): Prisma__TrainingSessionClient<$Result.GetResult<Prisma.$TrainingSessionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TrainingSession.
     * @param {TrainingSessionUpdateArgs} args - Arguments to update one TrainingSession.
     * @example
     * // Update one TrainingSession
     * const trainingSession = await prisma.trainingSession.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrainingSessionUpdateArgs>(args: SelectSubset<T, TrainingSessionUpdateArgs<ExtArgs>>): Prisma__TrainingSessionClient<$Result.GetResult<Prisma.$TrainingSessionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TrainingSessions.
     * @param {TrainingSessionDeleteManyArgs} args - Arguments to filter TrainingSessions to delete.
     * @example
     * // Delete a few TrainingSessions
     * const { count } = await prisma.trainingSession.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrainingSessionDeleteManyArgs>(args?: SelectSubset<T, TrainingSessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrainingSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingSessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrainingSessions
     * const trainingSession = await prisma.trainingSession.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrainingSessionUpdateManyArgs>(args: SelectSubset<T, TrainingSessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TrainingSession.
     * @param {TrainingSessionUpsertArgs} args - Arguments to update or create a TrainingSession.
     * @example
     * // Update or create a TrainingSession
     * const trainingSession = await prisma.trainingSession.upsert({
     *   create: {
     *     // ... data to create a TrainingSession
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrainingSession we want to update
     *   }
     * })
     */
    upsert<T extends TrainingSessionUpsertArgs>(args: SelectSubset<T, TrainingSessionUpsertArgs<ExtArgs>>): Prisma__TrainingSessionClient<$Result.GetResult<Prisma.$TrainingSessionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TrainingSessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingSessionCountArgs} args - Arguments to filter TrainingSessions to count.
     * @example
     * // Count the number of TrainingSessions
     * const count = await prisma.trainingSession.count({
     *   where: {
     *     // ... the filter for the TrainingSessions we want to count
     *   }
     * })
    **/
    count<T extends TrainingSessionCountArgs>(
      args?: Subset<T, TrainingSessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrainingSessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrainingSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingSessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrainingSessionAggregateArgs>(args: Subset<T, TrainingSessionAggregateArgs>): Prisma.PrismaPromise<GetTrainingSessionAggregateType<T>>

    /**
     * Group by TrainingSession.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrainingSessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrainingSessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrainingSessionGroupByArgs['orderBy'] }
        : { orderBy?: TrainingSessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrainingSessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrainingSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrainingSession model
   */
  readonly fields: TrainingSessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrainingSession.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrainingSessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    week<T extends TrainingWeekDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrainingWeekDefaultArgs<ExtArgs>>): Prisma__TrainingWeekClient<$Result.GetResult<Prisma.$TrainingWeekPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    completions<T extends TrainingSession$completionsArgs<ExtArgs> = {}>(args?: Subset<T, TrainingSession$completionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientSessionCompletionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrainingSession model
   */ 
  interface TrainingSessionFieldRefs {
    readonly id: FieldRef<"TrainingSession", 'String'>
    readonly weekId: FieldRef<"TrainingSession", 'String'>
    readonly sessionNumber: FieldRef<"TrainingSession", 'Int'>
    readonly name: FieldRef<"TrainingSession", 'String'>
    readonly description: FieldRef<"TrainingSession", 'String'>
    readonly duration: FieldRef<"TrainingSession", 'Int'>
    readonly intensity: FieldRef<"TrainingSession", 'String'>
    readonly sortOrder: FieldRef<"TrainingSession", 'Int'>
    readonly createdAt: FieldRef<"TrainingSession", 'DateTime'>
    readonly updatedAt: FieldRef<"TrainingSession", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TrainingSession findUnique
   */
  export type TrainingSessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSession
     */
    select?: TrainingSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSessionInclude<ExtArgs> | null
    /**
     * Filter, which TrainingSession to fetch.
     */
    where: TrainingSessionWhereUniqueInput
  }

  /**
   * TrainingSession findUniqueOrThrow
   */
  export type TrainingSessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSession
     */
    select?: TrainingSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSessionInclude<ExtArgs> | null
    /**
     * Filter, which TrainingSession to fetch.
     */
    where: TrainingSessionWhereUniqueInput
  }

  /**
   * TrainingSession findFirst
   */
  export type TrainingSessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSession
     */
    select?: TrainingSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSessionInclude<ExtArgs> | null
    /**
     * Filter, which TrainingSession to fetch.
     */
    where?: TrainingSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingSessions to fetch.
     */
    orderBy?: TrainingSessionOrderByWithRelationInput | TrainingSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingSessions.
     */
    cursor?: TrainingSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingSessions.
     */
    distinct?: TrainingSessionScalarFieldEnum | TrainingSessionScalarFieldEnum[]
  }

  /**
   * TrainingSession findFirstOrThrow
   */
  export type TrainingSessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSession
     */
    select?: TrainingSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSessionInclude<ExtArgs> | null
    /**
     * Filter, which TrainingSession to fetch.
     */
    where?: TrainingSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingSessions to fetch.
     */
    orderBy?: TrainingSessionOrderByWithRelationInput | TrainingSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrainingSessions.
     */
    cursor?: TrainingSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingSessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrainingSessions.
     */
    distinct?: TrainingSessionScalarFieldEnum | TrainingSessionScalarFieldEnum[]
  }

  /**
   * TrainingSession findMany
   */
  export type TrainingSessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSession
     */
    select?: TrainingSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSessionInclude<ExtArgs> | null
    /**
     * Filter, which TrainingSessions to fetch.
     */
    where?: TrainingSessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrainingSessions to fetch.
     */
    orderBy?: TrainingSessionOrderByWithRelationInput | TrainingSessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrainingSessions.
     */
    cursor?: TrainingSessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TrainingSessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrainingSessions.
     */
    skip?: number
    distinct?: TrainingSessionScalarFieldEnum | TrainingSessionScalarFieldEnum[]
  }

  /**
   * TrainingSession create
   */
  export type TrainingSessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSession
     */
    select?: TrainingSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSessionInclude<ExtArgs> | null
    /**
     * The data needed to create a TrainingSession.
     */
    data: XOR<TrainingSessionCreateInput, TrainingSessionUncheckedCreateInput>
  }

  /**
   * TrainingSession createMany
   */
  export type TrainingSessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrainingSessions.
     */
    data: TrainingSessionCreateManyInput | TrainingSessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrainingSession createManyAndReturn
   */
  export type TrainingSessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSession
     */
    select?: TrainingSessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TrainingSessions.
     */
    data: TrainingSessionCreateManyInput | TrainingSessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrainingSession update
   */
  export type TrainingSessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSession
     */
    select?: TrainingSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSessionInclude<ExtArgs> | null
    /**
     * The data needed to update a TrainingSession.
     */
    data: XOR<TrainingSessionUpdateInput, TrainingSessionUncheckedUpdateInput>
    /**
     * Choose, which TrainingSession to update.
     */
    where: TrainingSessionWhereUniqueInput
  }

  /**
   * TrainingSession updateMany
   */
  export type TrainingSessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrainingSessions.
     */
    data: XOR<TrainingSessionUpdateManyMutationInput, TrainingSessionUncheckedUpdateManyInput>
    /**
     * Filter which TrainingSessions to update
     */
    where?: TrainingSessionWhereInput
  }

  /**
   * TrainingSession upsert
   */
  export type TrainingSessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSession
     */
    select?: TrainingSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSessionInclude<ExtArgs> | null
    /**
     * The filter to search for the TrainingSession to update in case it exists.
     */
    where: TrainingSessionWhereUniqueInput
    /**
     * In case the TrainingSession found by the `where` argument doesn't exist, create a new TrainingSession with this data.
     */
    create: XOR<TrainingSessionCreateInput, TrainingSessionUncheckedCreateInput>
    /**
     * In case the TrainingSession was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrainingSessionUpdateInput, TrainingSessionUncheckedUpdateInput>
  }

  /**
   * TrainingSession delete
   */
  export type TrainingSessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSession
     */
    select?: TrainingSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSessionInclude<ExtArgs> | null
    /**
     * Filter which TrainingSession to delete.
     */
    where: TrainingSessionWhereUniqueInput
  }

  /**
   * TrainingSession deleteMany
   */
  export type TrainingSessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrainingSessions to delete
     */
    where?: TrainingSessionWhereInput
  }

  /**
   * TrainingSession.completions
   */
  export type TrainingSession$completionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientSessionCompletion
     */
    select?: PatientSessionCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientSessionCompletionInclude<ExtArgs> | null
    where?: PatientSessionCompletionWhereInput
    orderBy?: PatientSessionCompletionOrderByWithRelationInput | PatientSessionCompletionOrderByWithRelationInput[]
    cursor?: PatientSessionCompletionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PatientSessionCompletionScalarFieldEnum | PatientSessionCompletionScalarFieldEnum[]
  }

  /**
   * TrainingSession without action
   */
  export type TrainingSessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrainingSession
     */
    select?: TrainingSessionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrainingSessionInclude<ExtArgs> | null
  }


  /**
   * Model PatientTrainingProgress
   */

  export type AggregatePatientTrainingProgress = {
    _count: PatientTrainingProgressCountAggregateOutputType | null
    _min: PatientTrainingProgressMinAggregateOutputType | null
    _max: PatientTrainingProgressMaxAggregateOutputType | null
  }

  export type PatientTrainingProgressMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    weekId: string | null
    status: $Enums.TrainingWeekStatus | null
    startedAt: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PatientTrainingProgressMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    weekId: string | null
    status: $Enums.TrainingWeekStatus | null
    startedAt: Date | null
    completedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PatientTrainingProgressCountAggregateOutputType = {
    id: number
    patientId: number
    weekId: number
    status: number
    startedAt: number
    completedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PatientTrainingProgressMinAggregateInputType = {
    id?: true
    patientId?: true
    weekId?: true
    status?: true
    startedAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PatientTrainingProgressMaxAggregateInputType = {
    id?: true
    patientId?: true
    weekId?: true
    status?: true
    startedAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PatientTrainingProgressCountAggregateInputType = {
    id?: true
    patientId?: true
    weekId?: true
    status?: true
    startedAt?: true
    completedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PatientTrainingProgressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PatientTrainingProgress to aggregate.
     */
    where?: PatientTrainingProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientTrainingProgresses to fetch.
     */
    orderBy?: PatientTrainingProgressOrderByWithRelationInput | PatientTrainingProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatientTrainingProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientTrainingProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientTrainingProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PatientTrainingProgresses
    **/
    _count?: true | PatientTrainingProgressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatientTrainingProgressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatientTrainingProgressMaxAggregateInputType
  }

  export type GetPatientTrainingProgressAggregateType<T extends PatientTrainingProgressAggregateArgs> = {
        [P in keyof T & keyof AggregatePatientTrainingProgress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatientTrainingProgress[P]>
      : GetScalarType<T[P], AggregatePatientTrainingProgress[P]>
  }




  export type PatientTrainingProgressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientTrainingProgressWhereInput
    orderBy?: PatientTrainingProgressOrderByWithAggregationInput | PatientTrainingProgressOrderByWithAggregationInput[]
    by: PatientTrainingProgressScalarFieldEnum[] | PatientTrainingProgressScalarFieldEnum
    having?: PatientTrainingProgressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatientTrainingProgressCountAggregateInputType | true
    _min?: PatientTrainingProgressMinAggregateInputType
    _max?: PatientTrainingProgressMaxAggregateInputType
  }

  export type PatientTrainingProgressGroupByOutputType = {
    id: string
    patientId: string
    weekId: string
    status: $Enums.TrainingWeekStatus
    startedAt: Date | null
    completedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: PatientTrainingProgressCountAggregateOutputType | null
    _min: PatientTrainingProgressMinAggregateOutputType | null
    _max: PatientTrainingProgressMaxAggregateOutputType | null
  }

  type GetPatientTrainingProgressGroupByPayload<T extends PatientTrainingProgressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatientTrainingProgressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatientTrainingProgressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatientTrainingProgressGroupByOutputType[P]>
            : GetScalarType<T[P], PatientTrainingProgressGroupByOutputType[P]>
        }
      >
    >


  export type PatientTrainingProgressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    weekId?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    week?: boolean | TrainingWeekDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patientTrainingProgress"]>

  export type PatientTrainingProgressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    weekId?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    week?: boolean | TrainingWeekDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patientTrainingProgress"]>

  export type PatientTrainingProgressSelectScalar = {
    id?: boolean
    patientId?: boolean
    weekId?: boolean
    status?: boolean
    startedAt?: boolean
    completedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PatientTrainingProgressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    week?: boolean | TrainingWeekDefaultArgs<ExtArgs>
  }
  export type PatientTrainingProgressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    week?: boolean | TrainingWeekDefaultArgs<ExtArgs>
  }

  export type $PatientTrainingProgressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PatientTrainingProgress"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      week: Prisma.$TrainingWeekPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      weekId: string
      status: $Enums.TrainingWeekStatus
      startedAt: Date | null
      completedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["patientTrainingProgress"]>
    composites: {}
  }

  type PatientTrainingProgressGetPayload<S extends boolean | null | undefined | PatientTrainingProgressDefaultArgs> = $Result.GetResult<Prisma.$PatientTrainingProgressPayload, S>

  type PatientTrainingProgressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PatientTrainingProgressFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PatientTrainingProgressCountAggregateInputType | true
    }

  export interface PatientTrainingProgressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PatientTrainingProgress'], meta: { name: 'PatientTrainingProgress' } }
    /**
     * Find zero or one PatientTrainingProgress that matches the filter.
     * @param {PatientTrainingProgressFindUniqueArgs} args - Arguments to find a PatientTrainingProgress
     * @example
     * // Get one PatientTrainingProgress
     * const patientTrainingProgress = await prisma.patientTrainingProgress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PatientTrainingProgressFindUniqueArgs>(args: SelectSubset<T, PatientTrainingProgressFindUniqueArgs<ExtArgs>>): Prisma__PatientTrainingProgressClient<$Result.GetResult<Prisma.$PatientTrainingProgressPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PatientTrainingProgress that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PatientTrainingProgressFindUniqueOrThrowArgs} args - Arguments to find a PatientTrainingProgress
     * @example
     * // Get one PatientTrainingProgress
     * const patientTrainingProgress = await prisma.patientTrainingProgress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PatientTrainingProgressFindUniqueOrThrowArgs>(args: SelectSubset<T, PatientTrainingProgressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PatientTrainingProgressClient<$Result.GetResult<Prisma.$PatientTrainingProgressPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PatientTrainingProgress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientTrainingProgressFindFirstArgs} args - Arguments to find a PatientTrainingProgress
     * @example
     * // Get one PatientTrainingProgress
     * const patientTrainingProgress = await prisma.patientTrainingProgress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PatientTrainingProgressFindFirstArgs>(args?: SelectSubset<T, PatientTrainingProgressFindFirstArgs<ExtArgs>>): Prisma__PatientTrainingProgressClient<$Result.GetResult<Prisma.$PatientTrainingProgressPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PatientTrainingProgress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientTrainingProgressFindFirstOrThrowArgs} args - Arguments to find a PatientTrainingProgress
     * @example
     * // Get one PatientTrainingProgress
     * const patientTrainingProgress = await prisma.patientTrainingProgress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PatientTrainingProgressFindFirstOrThrowArgs>(args?: SelectSubset<T, PatientTrainingProgressFindFirstOrThrowArgs<ExtArgs>>): Prisma__PatientTrainingProgressClient<$Result.GetResult<Prisma.$PatientTrainingProgressPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PatientTrainingProgresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientTrainingProgressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PatientTrainingProgresses
     * const patientTrainingProgresses = await prisma.patientTrainingProgress.findMany()
     * 
     * // Get first 10 PatientTrainingProgresses
     * const patientTrainingProgresses = await prisma.patientTrainingProgress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patientTrainingProgressWithIdOnly = await prisma.patientTrainingProgress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PatientTrainingProgressFindManyArgs>(args?: SelectSubset<T, PatientTrainingProgressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientTrainingProgressPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PatientTrainingProgress.
     * @param {PatientTrainingProgressCreateArgs} args - Arguments to create a PatientTrainingProgress.
     * @example
     * // Create one PatientTrainingProgress
     * const PatientTrainingProgress = await prisma.patientTrainingProgress.create({
     *   data: {
     *     // ... data to create a PatientTrainingProgress
     *   }
     * })
     * 
     */
    create<T extends PatientTrainingProgressCreateArgs>(args: SelectSubset<T, PatientTrainingProgressCreateArgs<ExtArgs>>): Prisma__PatientTrainingProgressClient<$Result.GetResult<Prisma.$PatientTrainingProgressPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PatientTrainingProgresses.
     * @param {PatientTrainingProgressCreateManyArgs} args - Arguments to create many PatientTrainingProgresses.
     * @example
     * // Create many PatientTrainingProgresses
     * const patientTrainingProgress = await prisma.patientTrainingProgress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PatientTrainingProgressCreateManyArgs>(args?: SelectSubset<T, PatientTrainingProgressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PatientTrainingProgresses and returns the data saved in the database.
     * @param {PatientTrainingProgressCreateManyAndReturnArgs} args - Arguments to create many PatientTrainingProgresses.
     * @example
     * // Create many PatientTrainingProgresses
     * const patientTrainingProgress = await prisma.patientTrainingProgress.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PatientTrainingProgresses and only return the `id`
     * const patientTrainingProgressWithIdOnly = await prisma.patientTrainingProgress.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PatientTrainingProgressCreateManyAndReturnArgs>(args?: SelectSubset<T, PatientTrainingProgressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientTrainingProgressPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PatientTrainingProgress.
     * @param {PatientTrainingProgressDeleteArgs} args - Arguments to delete one PatientTrainingProgress.
     * @example
     * // Delete one PatientTrainingProgress
     * const PatientTrainingProgress = await prisma.patientTrainingProgress.delete({
     *   where: {
     *     // ... filter to delete one PatientTrainingProgress
     *   }
     * })
     * 
     */
    delete<T extends PatientTrainingProgressDeleteArgs>(args: SelectSubset<T, PatientTrainingProgressDeleteArgs<ExtArgs>>): Prisma__PatientTrainingProgressClient<$Result.GetResult<Prisma.$PatientTrainingProgressPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PatientTrainingProgress.
     * @param {PatientTrainingProgressUpdateArgs} args - Arguments to update one PatientTrainingProgress.
     * @example
     * // Update one PatientTrainingProgress
     * const patientTrainingProgress = await prisma.patientTrainingProgress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PatientTrainingProgressUpdateArgs>(args: SelectSubset<T, PatientTrainingProgressUpdateArgs<ExtArgs>>): Prisma__PatientTrainingProgressClient<$Result.GetResult<Prisma.$PatientTrainingProgressPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PatientTrainingProgresses.
     * @param {PatientTrainingProgressDeleteManyArgs} args - Arguments to filter PatientTrainingProgresses to delete.
     * @example
     * // Delete a few PatientTrainingProgresses
     * const { count } = await prisma.patientTrainingProgress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PatientTrainingProgressDeleteManyArgs>(args?: SelectSubset<T, PatientTrainingProgressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PatientTrainingProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientTrainingProgressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PatientTrainingProgresses
     * const patientTrainingProgress = await prisma.patientTrainingProgress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PatientTrainingProgressUpdateManyArgs>(args: SelectSubset<T, PatientTrainingProgressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PatientTrainingProgress.
     * @param {PatientTrainingProgressUpsertArgs} args - Arguments to update or create a PatientTrainingProgress.
     * @example
     * // Update or create a PatientTrainingProgress
     * const patientTrainingProgress = await prisma.patientTrainingProgress.upsert({
     *   create: {
     *     // ... data to create a PatientTrainingProgress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PatientTrainingProgress we want to update
     *   }
     * })
     */
    upsert<T extends PatientTrainingProgressUpsertArgs>(args: SelectSubset<T, PatientTrainingProgressUpsertArgs<ExtArgs>>): Prisma__PatientTrainingProgressClient<$Result.GetResult<Prisma.$PatientTrainingProgressPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PatientTrainingProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientTrainingProgressCountArgs} args - Arguments to filter PatientTrainingProgresses to count.
     * @example
     * // Count the number of PatientTrainingProgresses
     * const count = await prisma.patientTrainingProgress.count({
     *   where: {
     *     // ... the filter for the PatientTrainingProgresses we want to count
     *   }
     * })
    **/
    count<T extends PatientTrainingProgressCountArgs>(
      args?: Subset<T, PatientTrainingProgressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatientTrainingProgressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PatientTrainingProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientTrainingProgressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatientTrainingProgressAggregateArgs>(args: Subset<T, PatientTrainingProgressAggregateArgs>): Prisma.PrismaPromise<GetPatientTrainingProgressAggregateType<T>>

    /**
     * Group by PatientTrainingProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientTrainingProgressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatientTrainingProgressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatientTrainingProgressGroupByArgs['orderBy'] }
        : { orderBy?: PatientTrainingProgressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatientTrainingProgressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatientTrainingProgressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PatientTrainingProgress model
   */
  readonly fields: PatientTrainingProgressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PatientTrainingProgress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatientTrainingProgressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    week<T extends TrainingWeekDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrainingWeekDefaultArgs<ExtArgs>>): Prisma__TrainingWeekClient<$Result.GetResult<Prisma.$TrainingWeekPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PatientTrainingProgress model
   */ 
  interface PatientTrainingProgressFieldRefs {
    readonly id: FieldRef<"PatientTrainingProgress", 'String'>
    readonly patientId: FieldRef<"PatientTrainingProgress", 'String'>
    readonly weekId: FieldRef<"PatientTrainingProgress", 'String'>
    readonly status: FieldRef<"PatientTrainingProgress", 'TrainingWeekStatus'>
    readonly startedAt: FieldRef<"PatientTrainingProgress", 'DateTime'>
    readonly completedAt: FieldRef<"PatientTrainingProgress", 'DateTime'>
    readonly createdAt: FieldRef<"PatientTrainingProgress", 'DateTime'>
    readonly updatedAt: FieldRef<"PatientTrainingProgress", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PatientTrainingProgress findUnique
   */
  export type PatientTrainingProgressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientTrainingProgress
     */
    select?: PatientTrainingProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientTrainingProgressInclude<ExtArgs> | null
    /**
     * Filter, which PatientTrainingProgress to fetch.
     */
    where: PatientTrainingProgressWhereUniqueInput
  }

  /**
   * PatientTrainingProgress findUniqueOrThrow
   */
  export type PatientTrainingProgressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientTrainingProgress
     */
    select?: PatientTrainingProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientTrainingProgressInclude<ExtArgs> | null
    /**
     * Filter, which PatientTrainingProgress to fetch.
     */
    where: PatientTrainingProgressWhereUniqueInput
  }

  /**
   * PatientTrainingProgress findFirst
   */
  export type PatientTrainingProgressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientTrainingProgress
     */
    select?: PatientTrainingProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientTrainingProgressInclude<ExtArgs> | null
    /**
     * Filter, which PatientTrainingProgress to fetch.
     */
    where?: PatientTrainingProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientTrainingProgresses to fetch.
     */
    orderBy?: PatientTrainingProgressOrderByWithRelationInput | PatientTrainingProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PatientTrainingProgresses.
     */
    cursor?: PatientTrainingProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientTrainingProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientTrainingProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PatientTrainingProgresses.
     */
    distinct?: PatientTrainingProgressScalarFieldEnum | PatientTrainingProgressScalarFieldEnum[]
  }

  /**
   * PatientTrainingProgress findFirstOrThrow
   */
  export type PatientTrainingProgressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientTrainingProgress
     */
    select?: PatientTrainingProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientTrainingProgressInclude<ExtArgs> | null
    /**
     * Filter, which PatientTrainingProgress to fetch.
     */
    where?: PatientTrainingProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientTrainingProgresses to fetch.
     */
    orderBy?: PatientTrainingProgressOrderByWithRelationInput | PatientTrainingProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PatientTrainingProgresses.
     */
    cursor?: PatientTrainingProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientTrainingProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientTrainingProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PatientTrainingProgresses.
     */
    distinct?: PatientTrainingProgressScalarFieldEnum | PatientTrainingProgressScalarFieldEnum[]
  }

  /**
   * PatientTrainingProgress findMany
   */
  export type PatientTrainingProgressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientTrainingProgress
     */
    select?: PatientTrainingProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientTrainingProgressInclude<ExtArgs> | null
    /**
     * Filter, which PatientTrainingProgresses to fetch.
     */
    where?: PatientTrainingProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientTrainingProgresses to fetch.
     */
    orderBy?: PatientTrainingProgressOrderByWithRelationInput | PatientTrainingProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PatientTrainingProgresses.
     */
    cursor?: PatientTrainingProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientTrainingProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientTrainingProgresses.
     */
    skip?: number
    distinct?: PatientTrainingProgressScalarFieldEnum | PatientTrainingProgressScalarFieldEnum[]
  }

  /**
   * PatientTrainingProgress create
   */
  export type PatientTrainingProgressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientTrainingProgress
     */
    select?: PatientTrainingProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientTrainingProgressInclude<ExtArgs> | null
    /**
     * The data needed to create a PatientTrainingProgress.
     */
    data: XOR<PatientTrainingProgressCreateInput, PatientTrainingProgressUncheckedCreateInput>
  }

  /**
   * PatientTrainingProgress createMany
   */
  export type PatientTrainingProgressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PatientTrainingProgresses.
     */
    data: PatientTrainingProgressCreateManyInput | PatientTrainingProgressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PatientTrainingProgress createManyAndReturn
   */
  export type PatientTrainingProgressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientTrainingProgress
     */
    select?: PatientTrainingProgressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PatientTrainingProgresses.
     */
    data: PatientTrainingProgressCreateManyInput | PatientTrainingProgressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientTrainingProgressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PatientTrainingProgress update
   */
  export type PatientTrainingProgressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientTrainingProgress
     */
    select?: PatientTrainingProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientTrainingProgressInclude<ExtArgs> | null
    /**
     * The data needed to update a PatientTrainingProgress.
     */
    data: XOR<PatientTrainingProgressUpdateInput, PatientTrainingProgressUncheckedUpdateInput>
    /**
     * Choose, which PatientTrainingProgress to update.
     */
    where: PatientTrainingProgressWhereUniqueInput
  }

  /**
   * PatientTrainingProgress updateMany
   */
  export type PatientTrainingProgressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PatientTrainingProgresses.
     */
    data: XOR<PatientTrainingProgressUpdateManyMutationInput, PatientTrainingProgressUncheckedUpdateManyInput>
    /**
     * Filter which PatientTrainingProgresses to update
     */
    where?: PatientTrainingProgressWhereInput
  }

  /**
   * PatientTrainingProgress upsert
   */
  export type PatientTrainingProgressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientTrainingProgress
     */
    select?: PatientTrainingProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientTrainingProgressInclude<ExtArgs> | null
    /**
     * The filter to search for the PatientTrainingProgress to update in case it exists.
     */
    where: PatientTrainingProgressWhereUniqueInput
    /**
     * In case the PatientTrainingProgress found by the `where` argument doesn't exist, create a new PatientTrainingProgress with this data.
     */
    create: XOR<PatientTrainingProgressCreateInput, PatientTrainingProgressUncheckedCreateInput>
    /**
     * In case the PatientTrainingProgress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatientTrainingProgressUpdateInput, PatientTrainingProgressUncheckedUpdateInput>
  }

  /**
   * PatientTrainingProgress delete
   */
  export type PatientTrainingProgressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientTrainingProgress
     */
    select?: PatientTrainingProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientTrainingProgressInclude<ExtArgs> | null
    /**
     * Filter which PatientTrainingProgress to delete.
     */
    where: PatientTrainingProgressWhereUniqueInput
  }

  /**
   * PatientTrainingProgress deleteMany
   */
  export type PatientTrainingProgressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PatientTrainingProgresses to delete
     */
    where?: PatientTrainingProgressWhereInput
  }

  /**
   * PatientTrainingProgress without action
   */
  export type PatientTrainingProgressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientTrainingProgress
     */
    select?: PatientTrainingProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientTrainingProgressInclude<ExtArgs> | null
  }


  /**
   * Model PatientSessionCompletion
   */

  export type AggregatePatientSessionCompletion = {
    _count: PatientSessionCompletionCountAggregateOutputType | null
    _min: PatientSessionCompletionMinAggregateOutputType | null
    _max: PatientSessionCompletionMaxAggregateOutputType | null
  }

  export type PatientSessionCompletionMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    sessionId: string | null
    completedAt: Date | null
    notes: string | null
  }

  export type PatientSessionCompletionMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    sessionId: string | null
    completedAt: Date | null
    notes: string | null
  }

  export type PatientSessionCompletionCountAggregateOutputType = {
    id: number
    patientId: number
    sessionId: number
    completedAt: number
    notes: number
    _all: number
  }


  export type PatientSessionCompletionMinAggregateInputType = {
    id?: true
    patientId?: true
    sessionId?: true
    completedAt?: true
    notes?: true
  }

  export type PatientSessionCompletionMaxAggregateInputType = {
    id?: true
    patientId?: true
    sessionId?: true
    completedAt?: true
    notes?: true
  }

  export type PatientSessionCompletionCountAggregateInputType = {
    id?: true
    patientId?: true
    sessionId?: true
    completedAt?: true
    notes?: true
    _all?: true
  }

  export type PatientSessionCompletionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PatientSessionCompletion to aggregate.
     */
    where?: PatientSessionCompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientSessionCompletions to fetch.
     */
    orderBy?: PatientSessionCompletionOrderByWithRelationInput | PatientSessionCompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PatientSessionCompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientSessionCompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientSessionCompletions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PatientSessionCompletions
    **/
    _count?: true | PatientSessionCompletionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PatientSessionCompletionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PatientSessionCompletionMaxAggregateInputType
  }

  export type GetPatientSessionCompletionAggregateType<T extends PatientSessionCompletionAggregateArgs> = {
        [P in keyof T & keyof AggregatePatientSessionCompletion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePatientSessionCompletion[P]>
      : GetScalarType<T[P], AggregatePatientSessionCompletion[P]>
  }




  export type PatientSessionCompletionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PatientSessionCompletionWhereInput
    orderBy?: PatientSessionCompletionOrderByWithAggregationInput | PatientSessionCompletionOrderByWithAggregationInput[]
    by: PatientSessionCompletionScalarFieldEnum[] | PatientSessionCompletionScalarFieldEnum
    having?: PatientSessionCompletionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PatientSessionCompletionCountAggregateInputType | true
    _min?: PatientSessionCompletionMinAggregateInputType
    _max?: PatientSessionCompletionMaxAggregateInputType
  }

  export type PatientSessionCompletionGroupByOutputType = {
    id: string
    patientId: string
    sessionId: string
    completedAt: Date
    notes: string | null
    _count: PatientSessionCompletionCountAggregateOutputType | null
    _min: PatientSessionCompletionMinAggregateOutputType | null
    _max: PatientSessionCompletionMaxAggregateOutputType | null
  }

  type GetPatientSessionCompletionGroupByPayload<T extends PatientSessionCompletionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PatientSessionCompletionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PatientSessionCompletionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PatientSessionCompletionGroupByOutputType[P]>
            : GetScalarType<T[P], PatientSessionCompletionGroupByOutputType[P]>
        }
      >
    >


  export type PatientSessionCompletionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    sessionId?: boolean
    completedAt?: boolean
    notes?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    session?: boolean | TrainingSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patientSessionCompletion"]>

  export type PatientSessionCompletionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    sessionId?: boolean
    completedAt?: boolean
    notes?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    session?: boolean | TrainingSessionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["patientSessionCompletion"]>

  export type PatientSessionCompletionSelectScalar = {
    id?: boolean
    patientId?: boolean
    sessionId?: boolean
    completedAt?: boolean
    notes?: boolean
  }

  export type PatientSessionCompletionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    session?: boolean | TrainingSessionDefaultArgs<ExtArgs>
  }
  export type PatientSessionCompletionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    session?: boolean | TrainingSessionDefaultArgs<ExtArgs>
  }

  export type $PatientSessionCompletionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PatientSessionCompletion"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      session: Prisma.$TrainingSessionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      sessionId: string
      completedAt: Date
      notes: string | null
    }, ExtArgs["result"]["patientSessionCompletion"]>
    composites: {}
  }

  type PatientSessionCompletionGetPayload<S extends boolean | null | undefined | PatientSessionCompletionDefaultArgs> = $Result.GetResult<Prisma.$PatientSessionCompletionPayload, S>

  type PatientSessionCompletionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PatientSessionCompletionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PatientSessionCompletionCountAggregateInputType | true
    }

  export interface PatientSessionCompletionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PatientSessionCompletion'], meta: { name: 'PatientSessionCompletion' } }
    /**
     * Find zero or one PatientSessionCompletion that matches the filter.
     * @param {PatientSessionCompletionFindUniqueArgs} args - Arguments to find a PatientSessionCompletion
     * @example
     * // Get one PatientSessionCompletion
     * const patientSessionCompletion = await prisma.patientSessionCompletion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PatientSessionCompletionFindUniqueArgs>(args: SelectSubset<T, PatientSessionCompletionFindUniqueArgs<ExtArgs>>): Prisma__PatientSessionCompletionClient<$Result.GetResult<Prisma.$PatientSessionCompletionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PatientSessionCompletion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PatientSessionCompletionFindUniqueOrThrowArgs} args - Arguments to find a PatientSessionCompletion
     * @example
     * // Get one PatientSessionCompletion
     * const patientSessionCompletion = await prisma.patientSessionCompletion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PatientSessionCompletionFindUniqueOrThrowArgs>(args: SelectSubset<T, PatientSessionCompletionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PatientSessionCompletionClient<$Result.GetResult<Prisma.$PatientSessionCompletionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PatientSessionCompletion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientSessionCompletionFindFirstArgs} args - Arguments to find a PatientSessionCompletion
     * @example
     * // Get one PatientSessionCompletion
     * const patientSessionCompletion = await prisma.patientSessionCompletion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PatientSessionCompletionFindFirstArgs>(args?: SelectSubset<T, PatientSessionCompletionFindFirstArgs<ExtArgs>>): Prisma__PatientSessionCompletionClient<$Result.GetResult<Prisma.$PatientSessionCompletionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PatientSessionCompletion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientSessionCompletionFindFirstOrThrowArgs} args - Arguments to find a PatientSessionCompletion
     * @example
     * // Get one PatientSessionCompletion
     * const patientSessionCompletion = await prisma.patientSessionCompletion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PatientSessionCompletionFindFirstOrThrowArgs>(args?: SelectSubset<T, PatientSessionCompletionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PatientSessionCompletionClient<$Result.GetResult<Prisma.$PatientSessionCompletionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PatientSessionCompletions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientSessionCompletionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PatientSessionCompletions
     * const patientSessionCompletions = await prisma.patientSessionCompletion.findMany()
     * 
     * // Get first 10 PatientSessionCompletions
     * const patientSessionCompletions = await prisma.patientSessionCompletion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const patientSessionCompletionWithIdOnly = await prisma.patientSessionCompletion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PatientSessionCompletionFindManyArgs>(args?: SelectSubset<T, PatientSessionCompletionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientSessionCompletionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PatientSessionCompletion.
     * @param {PatientSessionCompletionCreateArgs} args - Arguments to create a PatientSessionCompletion.
     * @example
     * // Create one PatientSessionCompletion
     * const PatientSessionCompletion = await prisma.patientSessionCompletion.create({
     *   data: {
     *     // ... data to create a PatientSessionCompletion
     *   }
     * })
     * 
     */
    create<T extends PatientSessionCompletionCreateArgs>(args: SelectSubset<T, PatientSessionCompletionCreateArgs<ExtArgs>>): Prisma__PatientSessionCompletionClient<$Result.GetResult<Prisma.$PatientSessionCompletionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PatientSessionCompletions.
     * @param {PatientSessionCompletionCreateManyArgs} args - Arguments to create many PatientSessionCompletions.
     * @example
     * // Create many PatientSessionCompletions
     * const patientSessionCompletion = await prisma.patientSessionCompletion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PatientSessionCompletionCreateManyArgs>(args?: SelectSubset<T, PatientSessionCompletionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PatientSessionCompletions and returns the data saved in the database.
     * @param {PatientSessionCompletionCreateManyAndReturnArgs} args - Arguments to create many PatientSessionCompletions.
     * @example
     * // Create many PatientSessionCompletions
     * const patientSessionCompletion = await prisma.patientSessionCompletion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PatientSessionCompletions and only return the `id`
     * const patientSessionCompletionWithIdOnly = await prisma.patientSessionCompletion.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PatientSessionCompletionCreateManyAndReturnArgs>(args?: SelectSubset<T, PatientSessionCompletionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PatientSessionCompletionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PatientSessionCompletion.
     * @param {PatientSessionCompletionDeleteArgs} args - Arguments to delete one PatientSessionCompletion.
     * @example
     * // Delete one PatientSessionCompletion
     * const PatientSessionCompletion = await prisma.patientSessionCompletion.delete({
     *   where: {
     *     // ... filter to delete one PatientSessionCompletion
     *   }
     * })
     * 
     */
    delete<T extends PatientSessionCompletionDeleteArgs>(args: SelectSubset<T, PatientSessionCompletionDeleteArgs<ExtArgs>>): Prisma__PatientSessionCompletionClient<$Result.GetResult<Prisma.$PatientSessionCompletionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PatientSessionCompletion.
     * @param {PatientSessionCompletionUpdateArgs} args - Arguments to update one PatientSessionCompletion.
     * @example
     * // Update one PatientSessionCompletion
     * const patientSessionCompletion = await prisma.patientSessionCompletion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PatientSessionCompletionUpdateArgs>(args: SelectSubset<T, PatientSessionCompletionUpdateArgs<ExtArgs>>): Prisma__PatientSessionCompletionClient<$Result.GetResult<Prisma.$PatientSessionCompletionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PatientSessionCompletions.
     * @param {PatientSessionCompletionDeleteManyArgs} args - Arguments to filter PatientSessionCompletions to delete.
     * @example
     * // Delete a few PatientSessionCompletions
     * const { count } = await prisma.patientSessionCompletion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PatientSessionCompletionDeleteManyArgs>(args?: SelectSubset<T, PatientSessionCompletionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PatientSessionCompletions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientSessionCompletionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PatientSessionCompletions
     * const patientSessionCompletion = await prisma.patientSessionCompletion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PatientSessionCompletionUpdateManyArgs>(args: SelectSubset<T, PatientSessionCompletionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PatientSessionCompletion.
     * @param {PatientSessionCompletionUpsertArgs} args - Arguments to update or create a PatientSessionCompletion.
     * @example
     * // Update or create a PatientSessionCompletion
     * const patientSessionCompletion = await prisma.patientSessionCompletion.upsert({
     *   create: {
     *     // ... data to create a PatientSessionCompletion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PatientSessionCompletion we want to update
     *   }
     * })
     */
    upsert<T extends PatientSessionCompletionUpsertArgs>(args: SelectSubset<T, PatientSessionCompletionUpsertArgs<ExtArgs>>): Prisma__PatientSessionCompletionClient<$Result.GetResult<Prisma.$PatientSessionCompletionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PatientSessionCompletions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientSessionCompletionCountArgs} args - Arguments to filter PatientSessionCompletions to count.
     * @example
     * // Count the number of PatientSessionCompletions
     * const count = await prisma.patientSessionCompletion.count({
     *   where: {
     *     // ... the filter for the PatientSessionCompletions we want to count
     *   }
     * })
    **/
    count<T extends PatientSessionCompletionCountArgs>(
      args?: Subset<T, PatientSessionCompletionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PatientSessionCompletionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PatientSessionCompletion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientSessionCompletionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PatientSessionCompletionAggregateArgs>(args: Subset<T, PatientSessionCompletionAggregateArgs>): Prisma.PrismaPromise<GetPatientSessionCompletionAggregateType<T>>

    /**
     * Group by PatientSessionCompletion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PatientSessionCompletionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PatientSessionCompletionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PatientSessionCompletionGroupByArgs['orderBy'] }
        : { orderBy?: PatientSessionCompletionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PatientSessionCompletionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPatientSessionCompletionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PatientSessionCompletion model
   */
  readonly fields: PatientSessionCompletionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PatientSessionCompletion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PatientSessionCompletionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    session<T extends TrainingSessionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrainingSessionDefaultArgs<ExtArgs>>): Prisma__TrainingSessionClient<$Result.GetResult<Prisma.$TrainingSessionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PatientSessionCompletion model
   */ 
  interface PatientSessionCompletionFieldRefs {
    readonly id: FieldRef<"PatientSessionCompletion", 'String'>
    readonly patientId: FieldRef<"PatientSessionCompletion", 'String'>
    readonly sessionId: FieldRef<"PatientSessionCompletion", 'String'>
    readonly completedAt: FieldRef<"PatientSessionCompletion", 'DateTime'>
    readonly notes: FieldRef<"PatientSessionCompletion", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PatientSessionCompletion findUnique
   */
  export type PatientSessionCompletionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientSessionCompletion
     */
    select?: PatientSessionCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientSessionCompletionInclude<ExtArgs> | null
    /**
     * Filter, which PatientSessionCompletion to fetch.
     */
    where: PatientSessionCompletionWhereUniqueInput
  }

  /**
   * PatientSessionCompletion findUniqueOrThrow
   */
  export type PatientSessionCompletionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientSessionCompletion
     */
    select?: PatientSessionCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientSessionCompletionInclude<ExtArgs> | null
    /**
     * Filter, which PatientSessionCompletion to fetch.
     */
    where: PatientSessionCompletionWhereUniqueInput
  }

  /**
   * PatientSessionCompletion findFirst
   */
  export type PatientSessionCompletionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientSessionCompletion
     */
    select?: PatientSessionCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientSessionCompletionInclude<ExtArgs> | null
    /**
     * Filter, which PatientSessionCompletion to fetch.
     */
    where?: PatientSessionCompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientSessionCompletions to fetch.
     */
    orderBy?: PatientSessionCompletionOrderByWithRelationInput | PatientSessionCompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PatientSessionCompletions.
     */
    cursor?: PatientSessionCompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientSessionCompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientSessionCompletions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PatientSessionCompletions.
     */
    distinct?: PatientSessionCompletionScalarFieldEnum | PatientSessionCompletionScalarFieldEnum[]
  }

  /**
   * PatientSessionCompletion findFirstOrThrow
   */
  export type PatientSessionCompletionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientSessionCompletion
     */
    select?: PatientSessionCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientSessionCompletionInclude<ExtArgs> | null
    /**
     * Filter, which PatientSessionCompletion to fetch.
     */
    where?: PatientSessionCompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientSessionCompletions to fetch.
     */
    orderBy?: PatientSessionCompletionOrderByWithRelationInput | PatientSessionCompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PatientSessionCompletions.
     */
    cursor?: PatientSessionCompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientSessionCompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientSessionCompletions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PatientSessionCompletions.
     */
    distinct?: PatientSessionCompletionScalarFieldEnum | PatientSessionCompletionScalarFieldEnum[]
  }

  /**
   * PatientSessionCompletion findMany
   */
  export type PatientSessionCompletionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientSessionCompletion
     */
    select?: PatientSessionCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientSessionCompletionInclude<ExtArgs> | null
    /**
     * Filter, which PatientSessionCompletions to fetch.
     */
    where?: PatientSessionCompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PatientSessionCompletions to fetch.
     */
    orderBy?: PatientSessionCompletionOrderByWithRelationInput | PatientSessionCompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PatientSessionCompletions.
     */
    cursor?: PatientSessionCompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PatientSessionCompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PatientSessionCompletions.
     */
    skip?: number
    distinct?: PatientSessionCompletionScalarFieldEnum | PatientSessionCompletionScalarFieldEnum[]
  }

  /**
   * PatientSessionCompletion create
   */
  export type PatientSessionCompletionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientSessionCompletion
     */
    select?: PatientSessionCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientSessionCompletionInclude<ExtArgs> | null
    /**
     * The data needed to create a PatientSessionCompletion.
     */
    data: XOR<PatientSessionCompletionCreateInput, PatientSessionCompletionUncheckedCreateInput>
  }

  /**
   * PatientSessionCompletion createMany
   */
  export type PatientSessionCompletionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PatientSessionCompletions.
     */
    data: PatientSessionCompletionCreateManyInput | PatientSessionCompletionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PatientSessionCompletion createManyAndReturn
   */
  export type PatientSessionCompletionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientSessionCompletion
     */
    select?: PatientSessionCompletionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PatientSessionCompletions.
     */
    data: PatientSessionCompletionCreateManyInput | PatientSessionCompletionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientSessionCompletionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PatientSessionCompletion update
   */
  export type PatientSessionCompletionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientSessionCompletion
     */
    select?: PatientSessionCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientSessionCompletionInclude<ExtArgs> | null
    /**
     * The data needed to update a PatientSessionCompletion.
     */
    data: XOR<PatientSessionCompletionUpdateInput, PatientSessionCompletionUncheckedUpdateInput>
    /**
     * Choose, which PatientSessionCompletion to update.
     */
    where: PatientSessionCompletionWhereUniqueInput
  }

  /**
   * PatientSessionCompletion updateMany
   */
  export type PatientSessionCompletionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PatientSessionCompletions.
     */
    data: XOR<PatientSessionCompletionUpdateManyMutationInput, PatientSessionCompletionUncheckedUpdateManyInput>
    /**
     * Filter which PatientSessionCompletions to update
     */
    where?: PatientSessionCompletionWhereInput
  }

  /**
   * PatientSessionCompletion upsert
   */
  export type PatientSessionCompletionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientSessionCompletion
     */
    select?: PatientSessionCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientSessionCompletionInclude<ExtArgs> | null
    /**
     * The filter to search for the PatientSessionCompletion to update in case it exists.
     */
    where: PatientSessionCompletionWhereUniqueInput
    /**
     * In case the PatientSessionCompletion found by the `where` argument doesn't exist, create a new PatientSessionCompletion with this data.
     */
    create: XOR<PatientSessionCompletionCreateInput, PatientSessionCompletionUncheckedCreateInput>
    /**
     * In case the PatientSessionCompletion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PatientSessionCompletionUpdateInput, PatientSessionCompletionUncheckedUpdateInput>
  }

  /**
   * PatientSessionCompletion delete
   */
  export type PatientSessionCompletionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientSessionCompletion
     */
    select?: PatientSessionCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientSessionCompletionInclude<ExtArgs> | null
    /**
     * Filter which PatientSessionCompletion to delete.
     */
    where: PatientSessionCompletionWhereUniqueInput
  }

  /**
   * PatientSessionCompletion deleteMany
   */
  export type PatientSessionCompletionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PatientSessionCompletions to delete
     */
    where?: PatientSessionCompletionWhereInput
  }

  /**
   * PatientSessionCompletion without action
   */
  export type PatientSessionCompletionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PatientSessionCompletion
     */
    select?: PatientSessionCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PatientSessionCompletionInclude<ExtArgs> | null
  }


  /**
   * Model ChatConversation
   */

  export type AggregateChatConversation = {
    _count: ChatConversationCountAggregateOutputType | null
    _min: ChatConversationMinAggregateOutputType | null
    _max: ChatConversationMaxAggregateOutputType | null
  }

  export type ChatConversationMinAggregateOutputType = {
    id: string | null
    patientId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChatConversationMaxAggregateOutputType = {
    id: string | null
    patientId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChatConversationCountAggregateOutputType = {
    id: number
    patientId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChatConversationMinAggregateInputType = {
    id?: true
    patientId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChatConversationMaxAggregateInputType = {
    id?: true
    patientId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChatConversationCountAggregateInputType = {
    id?: true
    patientId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChatConversationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatConversation to aggregate.
     */
    where?: ChatConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatConversations to fetch.
     */
    orderBy?: ChatConversationOrderByWithRelationInput | ChatConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatConversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChatConversations
    **/
    _count?: true | ChatConversationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatConversationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatConversationMaxAggregateInputType
  }

  export type GetChatConversationAggregateType<T extends ChatConversationAggregateArgs> = {
        [P in keyof T & keyof AggregateChatConversation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatConversation[P]>
      : GetScalarType<T[P], AggregateChatConversation[P]>
  }




  export type ChatConversationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatConversationWhereInput
    orderBy?: ChatConversationOrderByWithAggregationInput | ChatConversationOrderByWithAggregationInput[]
    by: ChatConversationScalarFieldEnum[] | ChatConversationScalarFieldEnum
    having?: ChatConversationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatConversationCountAggregateInputType | true
    _min?: ChatConversationMinAggregateInputType
    _max?: ChatConversationMaxAggregateInputType
  }

  export type ChatConversationGroupByOutputType = {
    id: string
    patientId: string
    createdAt: Date
    updatedAt: Date
    _count: ChatConversationCountAggregateOutputType | null
    _min: ChatConversationMinAggregateOutputType | null
    _max: ChatConversationMaxAggregateOutputType | null
  }

  type GetChatConversationGroupByPayload<T extends ChatConversationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatConversationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatConversationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatConversationGroupByOutputType[P]>
            : GetScalarType<T[P], ChatConversationGroupByOutputType[P]>
        }
      >
    >


  export type ChatConversationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    messages?: boolean | ChatConversation$messagesArgs<ExtArgs>
    _count?: boolean | ChatConversationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatConversation"]>

  export type ChatConversationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    patientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatConversation"]>

  export type ChatConversationSelectScalar = {
    id?: boolean
    patientId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ChatConversationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
    messages?: boolean | ChatConversation$messagesArgs<ExtArgs>
    _count?: boolean | ChatConversationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChatConversationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    patient?: boolean | PatientDefaultArgs<ExtArgs>
  }

  export type $ChatConversationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChatConversation"
    objects: {
      patient: Prisma.$PatientPayload<ExtArgs>
      messages: Prisma.$ChatMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      patientId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["chatConversation"]>
    composites: {}
  }

  type ChatConversationGetPayload<S extends boolean | null | undefined | ChatConversationDefaultArgs> = $Result.GetResult<Prisma.$ChatConversationPayload, S>

  type ChatConversationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChatConversationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChatConversationCountAggregateInputType | true
    }

  export interface ChatConversationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChatConversation'], meta: { name: 'ChatConversation' } }
    /**
     * Find zero or one ChatConversation that matches the filter.
     * @param {ChatConversationFindUniqueArgs} args - Arguments to find a ChatConversation
     * @example
     * // Get one ChatConversation
     * const chatConversation = await prisma.chatConversation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatConversationFindUniqueArgs>(args: SelectSubset<T, ChatConversationFindUniqueArgs<ExtArgs>>): Prisma__ChatConversationClient<$Result.GetResult<Prisma.$ChatConversationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ChatConversation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChatConversationFindUniqueOrThrowArgs} args - Arguments to find a ChatConversation
     * @example
     * // Get one ChatConversation
     * const chatConversation = await prisma.chatConversation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatConversationFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatConversationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatConversationClient<$Result.GetResult<Prisma.$ChatConversationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ChatConversation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatConversationFindFirstArgs} args - Arguments to find a ChatConversation
     * @example
     * // Get one ChatConversation
     * const chatConversation = await prisma.chatConversation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatConversationFindFirstArgs>(args?: SelectSubset<T, ChatConversationFindFirstArgs<ExtArgs>>): Prisma__ChatConversationClient<$Result.GetResult<Prisma.$ChatConversationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ChatConversation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatConversationFindFirstOrThrowArgs} args - Arguments to find a ChatConversation
     * @example
     * // Get one ChatConversation
     * const chatConversation = await prisma.chatConversation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatConversationFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatConversationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatConversationClient<$Result.GetResult<Prisma.$ChatConversationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ChatConversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatConversationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatConversations
     * const chatConversations = await prisma.chatConversation.findMany()
     * 
     * // Get first 10 ChatConversations
     * const chatConversations = await prisma.chatConversation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatConversationWithIdOnly = await prisma.chatConversation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatConversationFindManyArgs>(args?: SelectSubset<T, ChatConversationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatConversationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ChatConversation.
     * @param {ChatConversationCreateArgs} args - Arguments to create a ChatConversation.
     * @example
     * // Create one ChatConversation
     * const ChatConversation = await prisma.chatConversation.create({
     *   data: {
     *     // ... data to create a ChatConversation
     *   }
     * })
     * 
     */
    create<T extends ChatConversationCreateArgs>(args: SelectSubset<T, ChatConversationCreateArgs<ExtArgs>>): Prisma__ChatConversationClient<$Result.GetResult<Prisma.$ChatConversationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ChatConversations.
     * @param {ChatConversationCreateManyArgs} args - Arguments to create many ChatConversations.
     * @example
     * // Create many ChatConversations
     * const chatConversation = await prisma.chatConversation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatConversationCreateManyArgs>(args?: SelectSubset<T, ChatConversationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChatConversations and returns the data saved in the database.
     * @param {ChatConversationCreateManyAndReturnArgs} args - Arguments to create many ChatConversations.
     * @example
     * // Create many ChatConversations
     * const chatConversation = await prisma.chatConversation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChatConversations and only return the `id`
     * const chatConversationWithIdOnly = await prisma.chatConversation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatConversationCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatConversationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatConversationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ChatConversation.
     * @param {ChatConversationDeleteArgs} args - Arguments to delete one ChatConversation.
     * @example
     * // Delete one ChatConversation
     * const ChatConversation = await prisma.chatConversation.delete({
     *   where: {
     *     // ... filter to delete one ChatConversation
     *   }
     * })
     * 
     */
    delete<T extends ChatConversationDeleteArgs>(args: SelectSubset<T, ChatConversationDeleteArgs<ExtArgs>>): Prisma__ChatConversationClient<$Result.GetResult<Prisma.$ChatConversationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ChatConversation.
     * @param {ChatConversationUpdateArgs} args - Arguments to update one ChatConversation.
     * @example
     * // Update one ChatConversation
     * const chatConversation = await prisma.chatConversation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatConversationUpdateArgs>(args: SelectSubset<T, ChatConversationUpdateArgs<ExtArgs>>): Prisma__ChatConversationClient<$Result.GetResult<Prisma.$ChatConversationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ChatConversations.
     * @param {ChatConversationDeleteManyArgs} args - Arguments to filter ChatConversations to delete.
     * @example
     * // Delete a few ChatConversations
     * const { count } = await prisma.chatConversation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatConversationDeleteManyArgs>(args?: SelectSubset<T, ChatConversationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatConversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatConversationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatConversations
     * const chatConversation = await prisma.chatConversation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatConversationUpdateManyArgs>(args: SelectSubset<T, ChatConversationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChatConversation.
     * @param {ChatConversationUpsertArgs} args - Arguments to update or create a ChatConversation.
     * @example
     * // Update or create a ChatConversation
     * const chatConversation = await prisma.chatConversation.upsert({
     *   create: {
     *     // ... data to create a ChatConversation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatConversation we want to update
     *   }
     * })
     */
    upsert<T extends ChatConversationUpsertArgs>(args: SelectSubset<T, ChatConversationUpsertArgs<ExtArgs>>): Prisma__ChatConversationClient<$Result.GetResult<Prisma.$ChatConversationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ChatConversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatConversationCountArgs} args - Arguments to filter ChatConversations to count.
     * @example
     * // Count the number of ChatConversations
     * const count = await prisma.chatConversation.count({
     *   where: {
     *     // ... the filter for the ChatConversations we want to count
     *   }
     * })
    **/
    count<T extends ChatConversationCountArgs>(
      args?: Subset<T, ChatConversationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatConversationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatConversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatConversationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatConversationAggregateArgs>(args: Subset<T, ChatConversationAggregateArgs>): Prisma.PrismaPromise<GetChatConversationAggregateType<T>>

    /**
     * Group by ChatConversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatConversationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatConversationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatConversationGroupByArgs['orderBy'] }
        : { orderBy?: ChatConversationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatConversationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatConversationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChatConversation model
   */
  readonly fields: ChatConversationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChatConversation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatConversationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    patient<T extends PatientDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PatientDefaultArgs<ExtArgs>>): Prisma__PatientClient<$Result.GetResult<Prisma.$PatientPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    messages<T extends ChatConversation$messagesArgs<ExtArgs> = {}>(args?: Subset<T, ChatConversation$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChatConversation model
   */ 
  interface ChatConversationFieldRefs {
    readonly id: FieldRef<"ChatConversation", 'String'>
    readonly patientId: FieldRef<"ChatConversation", 'String'>
    readonly createdAt: FieldRef<"ChatConversation", 'DateTime'>
    readonly updatedAt: FieldRef<"ChatConversation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChatConversation findUnique
   */
  export type ChatConversationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatConversation
     */
    select?: ChatConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatConversationInclude<ExtArgs> | null
    /**
     * Filter, which ChatConversation to fetch.
     */
    where: ChatConversationWhereUniqueInput
  }

  /**
   * ChatConversation findUniqueOrThrow
   */
  export type ChatConversationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatConversation
     */
    select?: ChatConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatConversationInclude<ExtArgs> | null
    /**
     * Filter, which ChatConversation to fetch.
     */
    where: ChatConversationWhereUniqueInput
  }

  /**
   * ChatConversation findFirst
   */
  export type ChatConversationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatConversation
     */
    select?: ChatConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatConversationInclude<ExtArgs> | null
    /**
     * Filter, which ChatConversation to fetch.
     */
    where?: ChatConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatConversations to fetch.
     */
    orderBy?: ChatConversationOrderByWithRelationInput | ChatConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatConversations.
     */
    cursor?: ChatConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatConversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatConversations.
     */
    distinct?: ChatConversationScalarFieldEnum | ChatConversationScalarFieldEnum[]
  }

  /**
   * ChatConversation findFirstOrThrow
   */
  export type ChatConversationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatConversation
     */
    select?: ChatConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatConversationInclude<ExtArgs> | null
    /**
     * Filter, which ChatConversation to fetch.
     */
    where?: ChatConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatConversations to fetch.
     */
    orderBy?: ChatConversationOrderByWithRelationInput | ChatConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatConversations.
     */
    cursor?: ChatConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatConversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatConversations.
     */
    distinct?: ChatConversationScalarFieldEnum | ChatConversationScalarFieldEnum[]
  }

  /**
   * ChatConversation findMany
   */
  export type ChatConversationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatConversation
     */
    select?: ChatConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatConversationInclude<ExtArgs> | null
    /**
     * Filter, which ChatConversations to fetch.
     */
    where?: ChatConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatConversations to fetch.
     */
    orderBy?: ChatConversationOrderByWithRelationInput | ChatConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChatConversations.
     */
    cursor?: ChatConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatConversations.
     */
    skip?: number
    distinct?: ChatConversationScalarFieldEnum | ChatConversationScalarFieldEnum[]
  }

  /**
   * ChatConversation create
   */
  export type ChatConversationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatConversation
     */
    select?: ChatConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatConversationInclude<ExtArgs> | null
    /**
     * The data needed to create a ChatConversation.
     */
    data: XOR<ChatConversationCreateInput, ChatConversationUncheckedCreateInput>
  }

  /**
   * ChatConversation createMany
   */
  export type ChatConversationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChatConversations.
     */
    data: ChatConversationCreateManyInput | ChatConversationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChatConversation createManyAndReturn
   */
  export type ChatConversationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatConversation
     */
    select?: ChatConversationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ChatConversations.
     */
    data: ChatConversationCreateManyInput | ChatConversationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatConversationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatConversation update
   */
  export type ChatConversationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatConversation
     */
    select?: ChatConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatConversationInclude<ExtArgs> | null
    /**
     * The data needed to update a ChatConversation.
     */
    data: XOR<ChatConversationUpdateInput, ChatConversationUncheckedUpdateInput>
    /**
     * Choose, which ChatConversation to update.
     */
    where: ChatConversationWhereUniqueInput
  }

  /**
   * ChatConversation updateMany
   */
  export type ChatConversationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChatConversations.
     */
    data: XOR<ChatConversationUpdateManyMutationInput, ChatConversationUncheckedUpdateManyInput>
    /**
     * Filter which ChatConversations to update
     */
    where?: ChatConversationWhereInput
  }

  /**
   * ChatConversation upsert
   */
  export type ChatConversationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatConversation
     */
    select?: ChatConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatConversationInclude<ExtArgs> | null
    /**
     * The filter to search for the ChatConversation to update in case it exists.
     */
    where: ChatConversationWhereUniqueInput
    /**
     * In case the ChatConversation found by the `where` argument doesn't exist, create a new ChatConversation with this data.
     */
    create: XOR<ChatConversationCreateInput, ChatConversationUncheckedCreateInput>
    /**
     * In case the ChatConversation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatConversationUpdateInput, ChatConversationUncheckedUpdateInput>
  }

  /**
   * ChatConversation delete
   */
  export type ChatConversationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatConversation
     */
    select?: ChatConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatConversationInclude<ExtArgs> | null
    /**
     * Filter which ChatConversation to delete.
     */
    where: ChatConversationWhereUniqueInput
  }

  /**
   * ChatConversation deleteMany
   */
  export type ChatConversationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatConversations to delete
     */
    where?: ChatConversationWhereInput
  }

  /**
   * ChatConversation.messages
   */
  export type ChatConversation$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    where?: ChatMessageWhereInput
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    cursor?: ChatMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatConversation without action
   */
  export type ChatConversationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatConversation
     */
    select?: ChatConversationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatConversationInclude<ExtArgs> | null
  }


  /**
   * Model ChatMessage
   */

  export type AggregateChatMessage = {
    _count: ChatMessageCountAggregateOutputType | null
    _min: ChatMessageMinAggregateOutputType | null
    _max: ChatMessageMaxAggregateOutputType | null
  }

  export type ChatMessageMinAggregateOutputType = {
    id: string | null
    conversationId: string | null
    role: string | null
    content: string | null
    createdAt: Date | null
  }

  export type ChatMessageMaxAggregateOutputType = {
    id: string | null
    conversationId: string | null
    role: string | null
    content: string | null
    createdAt: Date | null
  }

  export type ChatMessageCountAggregateOutputType = {
    id: number
    conversationId: number
    role: number
    content: number
    createdAt: number
    _all: number
  }


  export type ChatMessageMinAggregateInputType = {
    id?: true
    conversationId?: true
    role?: true
    content?: true
    createdAt?: true
  }

  export type ChatMessageMaxAggregateInputType = {
    id?: true
    conversationId?: true
    role?: true
    content?: true
    createdAt?: true
  }

  export type ChatMessageCountAggregateInputType = {
    id?: true
    conversationId?: true
    role?: true
    content?: true
    createdAt?: true
    _all?: true
  }

  export type ChatMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatMessage to aggregate.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChatMessages
    **/
    _count?: true | ChatMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChatMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChatMessageMaxAggregateInputType
  }

  export type GetChatMessageAggregateType<T extends ChatMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateChatMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChatMessage[P]>
      : GetScalarType<T[P], AggregateChatMessage[P]>
  }




  export type ChatMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChatMessageWhereInput
    orderBy?: ChatMessageOrderByWithAggregationInput | ChatMessageOrderByWithAggregationInput[]
    by: ChatMessageScalarFieldEnum[] | ChatMessageScalarFieldEnum
    having?: ChatMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChatMessageCountAggregateInputType | true
    _min?: ChatMessageMinAggregateInputType
    _max?: ChatMessageMaxAggregateInputType
  }

  export type ChatMessageGroupByOutputType = {
    id: string
    conversationId: string
    role: string
    content: string
    createdAt: Date
    _count: ChatMessageCountAggregateOutputType | null
    _min: ChatMessageMinAggregateOutputType | null
    _max: ChatMessageMaxAggregateOutputType | null
  }

  type GetChatMessageGroupByPayload<T extends ChatMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChatMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChatMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChatMessageGroupByOutputType[P]>
            : GetScalarType<T[P], ChatMessageGroupByOutputType[P]>
        }
      >
    >


  export type ChatMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    role?: boolean
    content?: boolean
    createdAt?: boolean
    conversation?: boolean | ChatConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatMessage"]>

  export type ChatMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    role?: boolean
    content?: boolean
    createdAt?: boolean
    conversation?: boolean | ChatConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["chatMessage"]>

  export type ChatMessageSelectScalar = {
    id?: boolean
    conversationId?: boolean
    role?: boolean
    content?: boolean
    createdAt?: boolean
  }

  export type ChatMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ChatConversationDefaultArgs<ExtArgs>
  }
  export type ChatMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | ChatConversationDefaultArgs<ExtArgs>
  }

  export type $ChatMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChatMessage"
    objects: {
      conversation: Prisma.$ChatConversationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conversationId: string
      role: string
      content: string
      createdAt: Date
    }, ExtArgs["result"]["chatMessage"]>
    composites: {}
  }

  type ChatMessageGetPayload<S extends boolean | null | undefined | ChatMessageDefaultArgs> = $Result.GetResult<Prisma.$ChatMessagePayload, S>

  type ChatMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChatMessageFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChatMessageCountAggregateInputType | true
    }

  export interface ChatMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChatMessage'], meta: { name: 'ChatMessage' } }
    /**
     * Find zero or one ChatMessage that matches the filter.
     * @param {ChatMessageFindUniqueArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChatMessageFindUniqueArgs>(args: SelectSubset<T, ChatMessageFindUniqueArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ChatMessage that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChatMessageFindUniqueOrThrowArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChatMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, ChatMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ChatMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindFirstArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChatMessageFindFirstArgs>(args?: SelectSubset<T, ChatMessageFindFirstArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ChatMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindFirstOrThrowArgs} args - Arguments to find a ChatMessage
     * @example
     * // Get one ChatMessage
     * const chatMessage = await prisma.chatMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChatMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, ChatMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ChatMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChatMessages
     * const chatMessages = await prisma.chatMessage.findMany()
     * 
     * // Get first 10 ChatMessages
     * const chatMessages = await prisma.chatMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chatMessageWithIdOnly = await prisma.chatMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChatMessageFindManyArgs>(args?: SelectSubset<T, ChatMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ChatMessage.
     * @param {ChatMessageCreateArgs} args - Arguments to create a ChatMessage.
     * @example
     * // Create one ChatMessage
     * const ChatMessage = await prisma.chatMessage.create({
     *   data: {
     *     // ... data to create a ChatMessage
     *   }
     * })
     * 
     */
    create<T extends ChatMessageCreateArgs>(args: SelectSubset<T, ChatMessageCreateArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ChatMessages.
     * @param {ChatMessageCreateManyArgs} args - Arguments to create many ChatMessages.
     * @example
     * // Create many ChatMessages
     * const chatMessage = await prisma.chatMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChatMessageCreateManyArgs>(args?: SelectSubset<T, ChatMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChatMessages and returns the data saved in the database.
     * @param {ChatMessageCreateManyAndReturnArgs} args - Arguments to create many ChatMessages.
     * @example
     * // Create many ChatMessages
     * const chatMessage = await prisma.chatMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChatMessages and only return the `id`
     * const chatMessageWithIdOnly = await prisma.chatMessage.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChatMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, ChatMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ChatMessage.
     * @param {ChatMessageDeleteArgs} args - Arguments to delete one ChatMessage.
     * @example
     * // Delete one ChatMessage
     * const ChatMessage = await prisma.chatMessage.delete({
     *   where: {
     *     // ... filter to delete one ChatMessage
     *   }
     * })
     * 
     */
    delete<T extends ChatMessageDeleteArgs>(args: SelectSubset<T, ChatMessageDeleteArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ChatMessage.
     * @param {ChatMessageUpdateArgs} args - Arguments to update one ChatMessage.
     * @example
     * // Update one ChatMessage
     * const chatMessage = await prisma.chatMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChatMessageUpdateArgs>(args: SelectSubset<T, ChatMessageUpdateArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ChatMessages.
     * @param {ChatMessageDeleteManyArgs} args - Arguments to filter ChatMessages to delete.
     * @example
     * // Delete a few ChatMessages
     * const { count } = await prisma.chatMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChatMessageDeleteManyArgs>(args?: SelectSubset<T, ChatMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChatMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChatMessages
     * const chatMessage = await prisma.chatMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChatMessageUpdateManyArgs>(args: SelectSubset<T, ChatMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChatMessage.
     * @param {ChatMessageUpsertArgs} args - Arguments to update or create a ChatMessage.
     * @example
     * // Update or create a ChatMessage
     * const chatMessage = await prisma.chatMessage.upsert({
     *   create: {
     *     // ... data to create a ChatMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChatMessage we want to update
     *   }
     * })
     */
    upsert<T extends ChatMessageUpsertArgs>(args: SelectSubset<T, ChatMessageUpsertArgs<ExtArgs>>): Prisma__ChatMessageClient<$Result.GetResult<Prisma.$ChatMessagePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ChatMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageCountArgs} args - Arguments to filter ChatMessages to count.
     * @example
     * // Count the number of ChatMessages
     * const count = await prisma.chatMessage.count({
     *   where: {
     *     // ... the filter for the ChatMessages we want to count
     *   }
     * })
    **/
    count<T extends ChatMessageCountArgs>(
      args?: Subset<T, ChatMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChatMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChatMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChatMessageAggregateArgs>(args: Subset<T, ChatMessageAggregateArgs>): Prisma.PrismaPromise<GetChatMessageAggregateType<T>>

    /**
     * Group by ChatMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChatMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChatMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChatMessageGroupByArgs['orderBy'] }
        : { orderBy?: ChatMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChatMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChatMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChatMessage model
   */
  readonly fields: ChatMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChatMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChatMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversation<T extends ChatConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChatConversationDefaultArgs<ExtArgs>>): Prisma__ChatConversationClient<$Result.GetResult<Prisma.$ChatConversationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChatMessage model
   */ 
  interface ChatMessageFieldRefs {
    readonly id: FieldRef<"ChatMessage", 'String'>
    readonly conversationId: FieldRef<"ChatMessage", 'String'>
    readonly role: FieldRef<"ChatMessage", 'String'>
    readonly content: FieldRef<"ChatMessage", 'String'>
    readonly createdAt: FieldRef<"ChatMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChatMessage findUnique
   */
  export type ChatMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage findUniqueOrThrow
   */
  export type ChatMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage findFirst
   */
  export type ChatMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatMessages.
     */
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage findFirstOrThrow
   */
  export type ChatMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessage to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChatMessages.
     */
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage findMany
   */
  export type ChatMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter, which ChatMessages to fetch.
     */
    where?: ChatMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChatMessages to fetch.
     */
    orderBy?: ChatMessageOrderByWithRelationInput | ChatMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChatMessages.
     */
    cursor?: ChatMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChatMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChatMessages.
     */
    skip?: number
    distinct?: ChatMessageScalarFieldEnum | ChatMessageScalarFieldEnum[]
  }

  /**
   * ChatMessage create
   */
  export type ChatMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a ChatMessage.
     */
    data: XOR<ChatMessageCreateInput, ChatMessageUncheckedCreateInput>
  }

  /**
   * ChatMessage createMany
   */
  export type ChatMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChatMessages.
     */
    data: ChatMessageCreateManyInput | ChatMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChatMessage createManyAndReturn
   */
  export type ChatMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ChatMessages.
     */
    data: ChatMessageCreateManyInput | ChatMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChatMessage update
   */
  export type ChatMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a ChatMessage.
     */
    data: XOR<ChatMessageUpdateInput, ChatMessageUncheckedUpdateInput>
    /**
     * Choose, which ChatMessage to update.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage updateMany
   */
  export type ChatMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChatMessages.
     */
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyInput>
    /**
     * Filter which ChatMessages to update
     */
    where?: ChatMessageWhereInput
  }

  /**
   * ChatMessage upsert
   */
  export type ChatMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the ChatMessage to update in case it exists.
     */
    where: ChatMessageWhereUniqueInput
    /**
     * In case the ChatMessage found by the `where` argument doesn't exist, create a new ChatMessage with this data.
     */
    create: XOR<ChatMessageCreateInput, ChatMessageUncheckedCreateInput>
    /**
     * In case the ChatMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChatMessageUpdateInput, ChatMessageUncheckedUpdateInput>
  }

  /**
   * ChatMessage delete
   */
  export type ChatMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
    /**
     * Filter which ChatMessage to delete.
     */
    where: ChatMessageWhereUniqueInput
  }

  /**
   * ChatMessage deleteMany
   */
  export type ChatMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChatMessages to delete
     */
    where?: ChatMessageWhereInput
  }

  /**
   * ChatMessage without action
   */
  export type ChatMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChatMessage
     */
    select?: ChatMessageSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChatMessageInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    passwordHash: 'passwordHash',
    name: 'name',
    role: 'role',
    clinicId: 'clinicId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const PasswordResetScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    code: 'code',
    expiresAt: 'expiresAt',
    used: 'used',
    createdAt: 'createdAt'
  };

  export type PasswordResetScalarFieldEnum = (typeof PasswordResetScalarFieldEnum)[keyof typeof PasswordResetScalarFieldEnum]


  export const ClinicScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    phone: 'phone',
    address: 'address',
    logoUrl: 'logoUrl',
    primaryColor: 'primaryColor',
    secondaryColor: 'secondaryColor',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClinicScalarFieldEnum = (typeof ClinicScalarFieldEnum)[keyof typeof ClinicScalarFieldEnum]


  export const PatientScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    clinicId: 'clinicId',
    cpf: 'cpf',
    phone: 'phone',
    birthDate: 'birthDate',
    surgeryDate: 'surgeryDate',
    surgeryType: 'surgeryType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PatientScalarFieldEnum = (typeof PatientScalarFieldEnum)[keyof typeof PatientScalarFieldEnum]


  export const AppointmentScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    title: 'title',
    description: 'description',
    date: 'date',
    time: 'time',
    type: 'type',
    status: 'status',
    location: 'location',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AppointmentScalarFieldEnum = (typeof AppointmentScalarFieldEnum)[keyof typeof AppointmentScalarFieldEnum]


  export const MedicationLogScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    contentId: 'contentId',
    takenAt: 'takenAt',
    scheduledTime: 'scheduledTime',
    createdAt: 'createdAt'
  };

  export type MedicationLogScalarFieldEnum = (typeof MedicationLogScalarFieldEnum)[keyof typeof MedicationLogScalarFieldEnum]


  export const ExamScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    title: 'title',
    type: 'type',
    date: 'date',
    status: 'status',
    fileUrl: 'fileUrl',
    fileName: 'fileName',
    fileSize: 'fileSize',
    mimeType: 'mimeType',
    notes: 'notes',
    result: 'result',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ExamScalarFieldEnum = (typeof ExamScalarFieldEnum)[keyof typeof ExamScalarFieldEnum]


  export const SystemContentTemplateScalarFieldEnum: {
    id: 'id',
    type: 'type',
    category: 'category',
    title: 'title',
    description: 'description',
    validFromDay: 'validFromDay',
    validUntilDay: 'validUntilDay',
    sortOrder: 'sortOrder',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SystemContentTemplateScalarFieldEnum = (typeof SystemContentTemplateScalarFieldEnum)[keyof typeof SystemContentTemplateScalarFieldEnum]


  export const ClinicContentScalarFieldEnum: {
    id: 'id',
    clinicId: 'clinicId',
    templateId: 'templateId',
    type: 'type',
    category: 'category',
    title: 'title',
    description: 'description',
    validFromDay: 'validFromDay',
    validUntilDay: 'validUntilDay',
    sortOrder: 'sortOrder',
    isActive: 'isActive',
    isCustom: 'isCustom',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ClinicContentScalarFieldEnum = (typeof ClinicContentScalarFieldEnum)[keyof typeof ClinicContentScalarFieldEnum]


  export const PatientContentAdjustmentScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    baseContentId: 'baseContentId',
    adjustmentType: 'adjustmentType',
    contentType: 'contentType',
    category: 'category',
    title: 'title',
    description: 'description',
    validFromDay: 'validFromDay',
    validUntilDay: 'validUntilDay',
    reason: 'reason',
    isActive: 'isActive',
    createdBy: 'createdBy',
    createdAt: 'createdAt'
  };

  export type PatientContentAdjustmentScalarFieldEnum = (typeof PatientContentAdjustmentScalarFieldEnum)[keyof typeof PatientContentAdjustmentScalarFieldEnum]


  export const TrainingProtocolScalarFieldEnum: {
    id: 'id',
    clinicId: 'clinicId',
    name: 'name',
    surgeryType: 'surgeryType',
    description: 'description',
    totalWeeks: 'totalWeeks',
    isDefault: 'isDefault',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TrainingProtocolScalarFieldEnum = (typeof TrainingProtocolScalarFieldEnum)[keyof typeof TrainingProtocolScalarFieldEnum]


  export const TrainingWeekScalarFieldEnum: {
    id: 'id',
    protocolId: 'protocolId',
    weekNumber: 'weekNumber',
    title: 'title',
    dayRange: 'dayRange',
    objective: 'objective',
    maxHeartRate: 'maxHeartRate',
    heartRateLabel: 'heartRateLabel',
    canDo: 'canDo',
    avoid: 'avoid',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TrainingWeekScalarFieldEnum = (typeof TrainingWeekScalarFieldEnum)[keyof typeof TrainingWeekScalarFieldEnum]


  export const TrainingSessionScalarFieldEnum: {
    id: 'id',
    weekId: 'weekId',
    sessionNumber: 'sessionNumber',
    name: 'name',
    description: 'description',
    duration: 'duration',
    intensity: 'intensity',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TrainingSessionScalarFieldEnum = (typeof TrainingSessionScalarFieldEnum)[keyof typeof TrainingSessionScalarFieldEnum]


  export const PatientTrainingProgressScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    weekId: 'weekId',
    status: 'status',
    startedAt: 'startedAt',
    completedAt: 'completedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PatientTrainingProgressScalarFieldEnum = (typeof PatientTrainingProgressScalarFieldEnum)[keyof typeof PatientTrainingProgressScalarFieldEnum]


  export const PatientSessionCompletionScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    sessionId: 'sessionId',
    completedAt: 'completedAt',
    notes: 'notes'
  };

  export type PatientSessionCompletionScalarFieldEnum = (typeof PatientSessionCompletionScalarFieldEnum)[keyof typeof PatientSessionCompletionScalarFieldEnum]


  export const ChatConversationScalarFieldEnum: {
    id: 'id',
    patientId: 'patientId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChatConversationScalarFieldEnum = (typeof ChatConversationScalarFieldEnum)[keyof typeof ChatConversationScalarFieldEnum]


  export const ChatMessageScalarFieldEnum: {
    id: 'id',
    conversationId: 'conversationId',
    role: 'role',
    content: 'content',
    createdAt: 'createdAt'
  };

  export type ChatMessageScalarFieldEnum = (typeof ChatMessageScalarFieldEnum)[keyof typeof ChatMessageScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'AppointmentType'
   */
  export type EnumAppointmentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppointmentType'>
    


  /**
   * Reference to a field of type 'AppointmentType[]'
   */
  export type ListEnumAppointmentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppointmentType[]'>
    


  /**
   * Reference to a field of type 'AppointmentStatus'
   */
  export type EnumAppointmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppointmentStatus'>
    


  /**
   * Reference to a field of type 'AppointmentStatus[]'
   */
  export type ListEnumAppointmentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppointmentStatus[]'>
    


  /**
   * Reference to a field of type 'ExamStatus'
   */
  export type EnumExamStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExamStatus'>
    


  /**
   * Reference to a field of type 'ExamStatus[]'
   */
  export type ListEnumExamStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExamStatus[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'ContentType'
   */
  export type EnumContentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContentType'>
    


  /**
   * Reference to a field of type 'ContentType[]'
   */
  export type ListEnumContentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContentType[]'>
    


  /**
   * Reference to a field of type 'ContentCategory'
   */
  export type EnumContentCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContentCategory'>
    


  /**
   * Reference to a field of type 'ContentCategory[]'
   */
  export type ListEnumContentCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContentCategory[]'>
    


  /**
   * Reference to a field of type 'AdjustmentType'
   */
  export type EnumAdjustmentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdjustmentType'>
    


  /**
   * Reference to a field of type 'AdjustmentType[]'
   */
  export type ListEnumAdjustmentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AdjustmentType[]'>
    


  /**
   * Reference to a field of type 'TrainingWeekStatus'
   */
  export type EnumTrainingWeekStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TrainingWeekStatus'>
    


  /**
   * Reference to a field of type 'TrainingWeekStatus[]'
   */
  export type ListEnumTrainingWeekStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TrainingWeekStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    clinicId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    clinic?: XOR<ClinicNullableRelationFilter, ClinicWhereInput> | null
    patient?: XOR<PatientNullableRelationFilter, PatientWhereInput> | null
    passwordResets?: PasswordResetListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    role?: SortOrder
    clinicId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clinic?: ClinicOrderByWithRelationInput
    patient?: PatientOrderByWithRelationInput
    passwordResets?: PasswordResetOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    passwordHash?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    clinicId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    clinic?: XOR<ClinicNullableRelationFilter, ClinicWhereInput> | null
    patient?: XOR<PatientNullableRelationFilter, PatientWhereInput> | null
    passwordResets?: PasswordResetListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    role?: SortOrder
    clinicId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    passwordHash?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    clinicId?: StringNullableWithAggregatesFilter<"User"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type PasswordResetWhereInput = {
    AND?: PasswordResetWhereInput | PasswordResetWhereInput[]
    OR?: PasswordResetWhereInput[]
    NOT?: PasswordResetWhereInput | PasswordResetWhereInput[]
    id?: StringFilter<"PasswordReset"> | string
    userId?: StringFilter<"PasswordReset"> | string
    code?: StringFilter<"PasswordReset"> | string
    expiresAt?: DateTimeFilter<"PasswordReset"> | Date | string
    used?: BoolFilter<"PasswordReset"> | boolean
    createdAt?: DateTimeFilter<"PasswordReset"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type PasswordResetOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    code?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type PasswordResetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PasswordResetWhereInput | PasswordResetWhereInput[]
    OR?: PasswordResetWhereInput[]
    NOT?: PasswordResetWhereInput | PasswordResetWhereInput[]
    userId?: StringFilter<"PasswordReset"> | string
    code?: StringFilter<"PasswordReset"> | string
    expiresAt?: DateTimeFilter<"PasswordReset"> | Date | string
    used?: BoolFilter<"PasswordReset"> | boolean
    createdAt?: DateTimeFilter<"PasswordReset"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type PasswordResetOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    code?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
    _count?: PasswordResetCountOrderByAggregateInput
    _max?: PasswordResetMaxOrderByAggregateInput
    _min?: PasswordResetMinOrderByAggregateInput
  }

  export type PasswordResetScalarWhereWithAggregatesInput = {
    AND?: PasswordResetScalarWhereWithAggregatesInput | PasswordResetScalarWhereWithAggregatesInput[]
    OR?: PasswordResetScalarWhereWithAggregatesInput[]
    NOT?: PasswordResetScalarWhereWithAggregatesInput | PasswordResetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PasswordReset"> | string
    userId?: StringWithAggregatesFilter<"PasswordReset"> | string
    code?: StringWithAggregatesFilter<"PasswordReset"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"PasswordReset"> | Date | string
    used?: BoolWithAggregatesFilter<"PasswordReset"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PasswordReset"> | Date | string
  }

  export type ClinicWhereInput = {
    AND?: ClinicWhereInput | ClinicWhereInput[]
    OR?: ClinicWhereInput[]
    NOT?: ClinicWhereInput | ClinicWhereInput[]
    id?: StringFilter<"Clinic"> | string
    name?: StringFilter<"Clinic"> | string
    email?: StringNullableFilter<"Clinic"> | string | null
    phone?: StringNullableFilter<"Clinic"> | string | null
    address?: StringNullableFilter<"Clinic"> | string | null
    logoUrl?: StringNullableFilter<"Clinic"> | string | null
    primaryColor?: StringNullableFilter<"Clinic"> | string | null
    secondaryColor?: StringNullableFilter<"Clinic"> | string | null
    isActive?: BoolFilter<"Clinic"> | boolean
    createdAt?: DateTimeFilter<"Clinic"> | Date | string
    updatedAt?: DateTimeFilter<"Clinic"> | Date | string
    users?: UserListRelationFilter
    patients?: PatientListRelationFilter
    contents?: ClinicContentListRelationFilter
    trainingProtocols?: TrainingProtocolListRelationFilter
  }

  export type ClinicOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    primaryColor?: SortOrderInput | SortOrder
    secondaryColor?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    users?: UserOrderByRelationAggregateInput
    patients?: PatientOrderByRelationAggregateInput
    contents?: ClinicContentOrderByRelationAggregateInput
    trainingProtocols?: TrainingProtocolOrderByRelationAggregateInput
  }

  export type ClinicWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClinicWhereInput | ClinicWhereInput[]
    OR?: ClinicWhereInput[]
    NOT?: ClinicWhereInput | ClinicWhereInput[]
    name?: StringFilter<"Clinic"> | string
    email?: StringNullableFilter<"Clinic"> | string | null
    phone?: StringNullableFilter<"Clinic"> | string | null
    address?: StringNullableFilter<"Clinic"> | string | null
    logoUrl?: StringNullableFilter<"Clinic"> | string | null
    primaryColor?: StringNullableFilter<"Clinic"> | string | null
    secondaryColor?: StringNullableFilter<"Clinic"> | string | null
    isActive?: BoolFilter<"Clinic"> | boolean
    createdAt?: DateTimeFilter<"Clinic"> | Date | string
    updatedAt?: DateTimeFilter<"Clinic"> | Date | string
    users?: UserListRelationFilter
    patients?: PatientListRelationFilter
    contents?: ClinicContentListRelationFilter
    trainingProtocols?: TrainingProtocolListRelationFilter
  }, "id">

  export type ClinicOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    logoUrl?: SortOrderInput | SortOrder
    primaryColor?: SortOrderInput | SortOrder
    secondaryColor?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClinicCountOrderByAggregateInput
    _max?: ClinicMaxOrderByAggregateInput
    _min?: ClinicMinOrderByAggregateInput
  }

  export type ClinicScalarWhereWithAggregatesInput = {
    AND?: ClinicScalarWhereWithAggregatesInput | ClinicScalarWhereWithAggregatesInput[]
    OR?: ClinicScalarWhereWithAggregatesInput[]
    NOT?: ClinicScalarWhereWithAggregatesInput | ClinicScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Clinic"> | string
    name?: StringWithAggregatesFilter<"Clinic"> | string
    email?: StringNullableWithAggregatesFilter<"Clinic"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Clinic"> | string | null
    address?: StringNullableWithAggregatesFilter<"Clinic"> | string | null
    logoUrl?: StringNullableWithAggregatesFilter<"Clinic"> | string | null
    primaryColor?: StringNullableWithAggregatesFilter<"Clinic"> | string | null
    secondaryColor?: StringNullableWithAggregatesFilter<"Clinic"> | string | null
    isActive?: BoolWithAggregatesFilter<"Clinic"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Clinic"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Clinic"> | Date | string
  }

  export type PatientWhereInput = {
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    id?: StringFilter<"Patient"> | string
    userId?: StringFilter<"Patient"> | string
    clinicId?: StringFilter<"Patient"> | string
    cpf?: StringNullableFilter<"Patient"> | string | null
    phone?: StringNullableFilter<"Patient"> | string | null
    birthDate?: DateTimeNullableFilter<"Patient"> | Date | string | null
    surgeryDate?: DateTimeNullableFilter<"Patient"> | Date | string | null
    surgeryType?: StringNullableFilter<"Patient"> | string | null
    createdAt?: DateTimeFilter<"Patient"> | Date | string
    updatedAt?: DateTimeFilter<"Patient"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    clinic?: XOR<ClinicRelationFilter, ClinicWhereInput>
    contentAdjustments?: PatientContentAdjustmentListRelationFilter
    appointments?: AppointmentListRelationFilter
    medicationLogs?: MedicationLogListRelationFilter
    chatConversations?: ChatConversationListRelationFilter
    exams?: ExamListRelationFilter
    trainingProgress?: PatientTrainingProgressListRelationFilter
    sessionCompletions?: PatientSessionCompletionListRelationFilter
  }

  export type PatientOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    clinicId?: SortOrder
    cpf?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    surgeryDate?: SortOrderInput | SortOrder
    surgeryType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    clinic?: ClinicOrderByWithRelationInput
    contentAdjustments?: PatientContentAdjustmentOrderByRelationAggregateInput
    appointments?: AppointmentOrderByRelationAggregateInput
    medicationLogs?: MedicationLogOrderByRelationAggregateInput
    chatConversations?: ChatConversationOrderByRelationAggregateInput
    exams?: ExamOrderByRelationAggregateInput
    trainingProgress?: PatientTrainingProgressOrderByRelationAggregateInput
    sessionCompletions?: PatientSessionCompletionOrderByRelationAggregateInput
  }

  export type PatientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: PatientWhereInput | PatientWhereInput[]
    OR?: PatientWhereInput[]
    NOT?: PatientWhereInput | PatientWhereInput[]
    clinicId?: StringFilter<"Patient"> | string
    cpf?: StringNullableFilter<"Patient"> | string | null
    phone?: StringNullableFilter<"Patient"> | string | null
    birthDate?: DateTimeNullableFilter<"Patient"> | Date | string | null
    surgeryDate?: DateTimeNullableFilter<"Patient"> | Date | string | null
    surgeryType?: StringNullableFilter<"Patient"> | string | null
    createdAt?: DateTimeFilter<"Patient"> | Date | string
    updatedAt?: DateTimeFilter<"Patient"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
    clinic?: XOR<ClinicRelationFilter, ClinicWhereInput>
    contentAdjustments?: PatientContentAdjustmentListRelationFilter
    appointments?: AppointmentListRelationFilter
    medicationLogs?: MedicationLogListRelationFilter
    chatConversations?: ChatConversationListRelationFilter
    exams?: ExamListRelationFilter
    trainingProgress?: PatientTrainingProgressListRelationFilter
    sessionCompletions?: PatientSessionCompletionListRelationFilter
  }, "id" | "userId">

  export type PatientOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    clinicId?: SortOrder
    cpf?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    surgeryDate?: SortOrderInput | SortOrder
    surgeryType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PatientCountOrderByAggregateInput
    _max?: PatientMaxOrderByAggregateInput
    _min?: PatientMinOrderByAggregateInput
  }

  export type PatientScalarWhereWithAggregatesInput = {
    AND?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    OR?: PatientScalarWhereWithAggregatesInput[]
    NOT?: PatientScalarWhereWithAggregatesInput | PatientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Patient"> | string
    userId?: StringWithAggregatesFilter<"Patient"> | string
    clinicId?: StringWithAggregatesFilter<"Patient"> | string
    cpf?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    birthDate?: DateTimeNullableWithAggregatesFilter<"Patient"> | Date | string | null
    surgeryDate?: DateTimeNullableWithAggregatesFilter<"Patient"> | Date | string | null
    surgeryType?: StringNullableWithAggregatesFilter<"Patient"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Patient"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Patient"> | Date | string
  }

  export type AppointmentWhereInput = {
    AND?: AppointmentWhereInput | AppointmentWhereInput[]
    OR?: AppointmentWhereInput[]
    NOT?: AppointmentWhereInput | AppointmentWhereInput[]
    id?: StringFilter<"Appointment"> | string
    patientId?: StringFilter<"Appointment"> | string
    title?: StringFilter<"Appointment"> | string
    description?: StringNullableFilter<"Appointment"> | string | null
    date?: DateTimeFilter<"Appointment"> | Date | string
    time?: StringFilter<"Appointment"> | string
    type?: EnumAppointmentTypeFilter<"Appointment"> | $Enums.AppointmentType
    status?: EnumAppointmentStatusFilter<"Appointment"> | $Enums.AppointmentStatus
    location?: StringNullableFilter<"Appointment"> | string | null
    notes?: StringNullableFilter<"Appointment"> | string | null
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeFilter<"Appointment"> | Date | string
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
  }

  export type AppointmentOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    date?: SortOrder
    time?: SortOrder
    type?: SortOrder
    status?: SortOrder
    location?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    patient?: PatientOrderByWithRelationInput
  }

  export type AppointmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AppointmentWhereInput | AppointmentWhereInput[]
    OR?: AppointmentWhereInput[]
    NOT?: AppointmentWhereInput | AppointmentWhereInput[]
    patientId?: StringFilter<"Appointment"> | string
    title?: StringFilter<"Appointment"> | string
    description?: StringNullableFilter<"Appointment"> | string | null
    date?: DateTimeFilter<"Appointment"> | Date | string
    time?: StringFilter<"Appointment"> | string
    type?: EnumAppointmentTypeFilter<"Appointment"> | $Enums.AppointmentType
    status?: EnumAppointmentStatusFilter<"Appointment"> | $Enums.AppointmentStatus
    location?: StringNullableFilter<"Appointment"> | string | null
    notes?: StringNullableFilter<"Appointment"> | string | null
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeFilter<"Appointment"> | Date | string
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
  }, "id">

  export type AppointmentOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    date?: SortOrder
    time?: SortOrder
    type?: SortOrder
    status?: SortOrder
    location?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AppointmentCountOrderByAggregateInput
    _max?: AppointmentMaxOrderByAggregateInput
    _min?: AppointmentMinOrderByAggregateInput
  }

  export type AppointmentScalarWhereWithAggregatesInput = {
    AND?: AppointmentScalarWhereWithAggregatesInput | AppointmentScalarWhereWithAggregatesInput[]
    OR?: AppointmentScalarWhereWithAggregatesInput[]
    NOT?: AppointmentScalarWhereWithAggregatesInput | AppointmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Appointment"> | string
    patientId?: StringWithAggregatesFilter<"Appointment"> | string
    title?: StringWithAggregatesFilter<"Appointment"> | string
    description?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    date?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    time?: StringWithAggregatesFilter<"Appointment"> | string
    type?: EnumAppointmentTypeWithAggregatesFilter<"Appointment"> | $Enums.AppointmentType
    status?: EnumAppointmentStatusWithAggregatesFilter<"Appointment"> | $Enums.AppointmentStatus
    location?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Appointment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Appointment"> | Date | string
  }

  export type MedicationLogWhereInput = {
    AND?: MedicationLogWhereInput | MedicationLogWhereInput[]
    OR?: MedicationLogWhereInput[]
    NOT?: MedicationLogWhereInput | MedicationLogWhereInput[]
    id?: StringFilter<"MedicationLog"> | string
    patientId?: StringFilter<"MedicationLog"> | string
    contentId?: StringFilter<"MedicationLog"> | string
    takenAt?: DateTimeFilter<"MedicationLog"> | Date | string
    scheduledTime?: StringFilter<"MedicationLog"> | string
    createdAt?: DateTimeFilter<"MedicationLog"> | Date | string
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
  }

  export type MedicationLogOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    contentId?: SortOrder
    takenAt?: SortOrder
    scheduledTime?: SortOrder
    createdAt?: SortOrder
    patient?: PatientOrderByWithRelationInput
  }

  export type MedicationLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MedicationLogWhereInput | MedicationLogWhereInput[]
    OR?: MedicationLogWhereInput[]
    NOT?: MedicationLogWhereInput | MedicationLogWhereInput[]
    patientId?: StringFilter<"MedicationLog"> | string
    contentId?: StringFilter<"MedicationLog"> | string
    takenAt?: DateTimeFilter<"MedicationLog"> | Date | string
    scheduledTime?: StringFilter<"MedicationLog"> | string
    createdAt?: DateTimeFilter<"MedicationLog"> | Date | string
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
  }, "id">

  export type MedicationLogOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    contentId?: SortOrder
    takenAt?: SortOrder
    scheduledTime?: SortOrder
    createdAt?: SortOrder
    _count?: MedicationLogCountOrderByAggregateInput
    _max?: MedicationLogMaxOrderByAggregateInput
    _min?: MedicationLogMinOrderByAggregateInput
  }

  export type MedicationLogScalarWhereWithAggregatesInput = {
    AND?: MedicationLogScalarWhereWithAggregatesInput | MedicationLogScalarWhereWithAggregatesInput[]
    OR?: MedicationLogScalarWhereWithAggregatesInput[]
    NOT?: MedicationLogScalarWhereWithAggregatesInput | MedicationLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MedicationLog"> | string
    patientId?: StringWithAggregatesFilter<"MedicationLog"> | string
    contentId?: StringWithAggregatesFilter<"MedicationLog"> | string
    takenAt?: DateTimeWithAggregatesFilter<"MedicationLog"> | Date | string
    scheduledTime?: StringWithAggregatesFilter<"MedicationLog"> | string
    createdAt?: DateTimeWithAggregatesFilter<"MedicationLog"> | Date | string
  }

  export type ExamWhereInput = {
    AND?: ExamWhereInput | ExamWhereInput[]
    OR?: ExamWhereInput[]
    NOT?: ExamWhereInput | ExamWhereInput[]
    id?: StringFilter<"Exam"> | string
    patientId?: StringFilter<"Exam"> | string
    title?: StringFilter<"Exam"> | string
    type?: StringFilter<"Exam"> | string
    date?: DateTimeFilter<"Exam"> | Date | string
    status?: EnumExamStatusFilter<"Exam"> | $Enums.ExamStatus
    fileUrl?: StringNullableFilter<"Exam"> | string | null
    fileName?: StringNullableFilter<"Exam"> | string | null
    fileSize?: IntNullableFilter<"Exam"> | number | null
    mimeType?: StringNullableFilter<"Exam"> | string | null
    notes?: StringNullableFilter<"Exam"> | string | null
    result?: StringNullableFilter<"Exam"> | string | null
    createdAt?: DateTimeFilter<"Exam"> | Date | string
    updatedAt?: DateTimeFilter<"Exam"> | Date | string
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
  }

  export type ExamOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    title?: SortOrder
    type?: SortOrder
    date?: SortOrder
    status?: SortOrder
    fileUrl?: SortOrderInput | SortOrder
    fileName?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    mimeType?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    result?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    patient?: PatientOrderByWithRelationInput
  }

  export type ExamWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ExamWhereInput | ExamWhereInput[]
    OR?: ExamWhereInput[]
    NOT?: ExamWhereInput | ExamWhereInput[]
    patientId?: StringFilter<"Exam"> | string
    title?: StringFilter<"Exam"> | string
    type?: StringFilter<"Exam"> | string
    date?: DateTimeFilter<"Exam"> | Date | string
    status?: EnumExamStatusFilter<"Exam"> | $Enums.ExamStatus
    fileUrl?: StringNullableFilter<"Exam"> | string | null
    fileName?: StringNullableFilter<"Exam"> | string | null
    fileSize?: IntNullableFilter<"Exam"> | number | null
    mimeType?: StringNullableFilter<"Exam"> | string | null
    notes?: StringNullableFilter<"Exam"> | string | null
    result?: StringNullableFilter<"Exam"> | string | null
    createdAt?: DateTimeFilter<"Exam"> | Date | string
    updatedAt?: DateTimeFilter<"Exam"> | Date | string
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
  }, "id">

  export type ExamOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    title?: SortOrder
    type?: SortOrder
    date?: SortOrder
    status?: SortOrder
    fileUrl?: SortOrderInput | SortOrder
    fileName?: SortOrderInput | SortOrder
    fileSize?: SortOrderInput | SortOrder
    mimeType?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    result?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ExamCountOrderByAggregateInput
    _avg?: ExamAvgOrderByAggregateInput
    _max?: ExamMaxOrderByAggregateInput
    _min?: ExamMinOrderByAggregateInput
    _sum?: ExamSumOrderByAggregateInput
  }

  export type ExamScalarWhereWithAggregatesInput = {
    AND?: ExamScalarWhereWithAggregatesInput | ExamScalarWhereWithAggregatesInput[]
    OR?: ExamScalarWhereWithAggregatesInput[]
    NOT?: ExamScalarWhereWithAggregatesInput | ExamScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Exam"> | string
    patientId?: StringWithAggregatesFilter<"Exam"> | string
    title?: StringWithAggregatesFilter<"Exam"> | string
    type?: StringWithAggregatesFilter<"Exam"> | string
    date?: DateTimeWithAggregatesFilter<"Exam"> | Date | string
    status?: EnumExamStatusWithAggregatesFilter<"Exam"> | $Enums.ExamStatus
    fileUrl?: StringNullableWithAggregatesFilter<"Exam"> | string | null
    fileName?: StringNullableWithAggregatesFilter<"Exam"> | string | null
    fileSize?: IntNullableWithAggregatesFilter<"Exam"> | number | null
    mimeType?: StringNullableWithAggregatesFilter<"Exam"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Exam"> | string | null
    result?: StringNullableWithAggregatesFilter<"Exam"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Exam"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Exam"> | Date | string
  }

  export type SystemContentTemplateWhereInput = {
    AND?: SystemContentTemplateWhereInput | SystemContentTemplateWhereInput[]
    OR?: SystemContentTemplateWhereInput[]
    NOT?: SystemContentTemplateWhereInput | SystemContentTemplateWhereInput[]
    id?: StringFilter<"SystemContentTemplate"> | string
    type?: EnumContentTypeFilter<"SystemContentTemplate"> | $Enums.ContentType
    category?: EnumContentCategoryFilter<"SystemContentTemplate"> | $Enums.ContentCategory
    title?: StringFilter<"SystemContentTemplate"> | string
    description?: StringNullableFilter<"SystemContentTemplate"> | string | null
    validFromDay?: IntNullableFilter<"SystemContentTemplate"> | number | null
    validUntilDay?: IntNullableFilter<"SystemContentTemplate"> | number | null
    sortOrder?: IntFilter<"SystemContentTemplate"> | number
    isActive?: BoolFilter<"SystemContentTemplate"> | boolean
    createdAt?: DateTimeFilter<"SystemContentTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"SystemContentTemplate"> | Date | string
  }

  export type SystemContentTemplateOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    category?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    validFromDay?: SortOrderInput | SortOrder
    validUntilDay?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemContentTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SystemContentTemplateWhereInput | SystemContentTemplateWhereInput[]
    OR?: SystemContentTemplateWhereInput[]
    NOT?: SystemContentTemplateWhereInput | SystemContentTemplateWhereInput[]
    type?: EnumContentTypeFilter<"SystemContentTemplate"> | $Enums.ContentType
    category?: EnumContentCategoryFilter<"SystemContentTemplate"> | $Enums.ContentCategory
    title?: StringFilter<"SystemContentTemplate"> | string
    description?: StringNullableFilter<"SystemContentTemplate"> | string | null
    validFromDay?: IntNullableFilter<"SystemContentTemplate"> | number | null
    validUntilDay?: IntNullableFilter<"SystemContentTemplate"> | number | null
    sortOrder?: IntFilter<"SystemContentTemplate"> | number
    isActive?: BoolFilter<"SystemContentTemplate"> | boolean
    createdAt?: DateTimeFilter<"SystemContentTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"SystemContentTemplate"> | Date | string
  }, "id">

  export type SystemContentTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    category?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    validFromDay?: SortOrderInput | SortOrder
    validUntilDay?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SystemContentTemplateCountOrderByAggregateInput
    _avg?: SystemContentTemplateAvgOrderByAggregateInput
    _max?: SystemContentTemplateMaxOrderByAggregateInput
    _min?: SystemContentTemplateMinOrderByAggregateInput
    _sum?: SystemContentTemplateSumOrderByAggregateInput
  }

  export type SystemContentTemplateScalarWhereWithAggregatesInput = {
    AND?: SystemContentTemplateScalarWhereWithAggregatesInput | SystemContentTemplateScalarWhereWithAggregatesInput[]
    OR?: SystemContentTemplateScalarWhereWithAggregatesInput[]
    NOT?: SystemContentTemplateScalarWhereWithAggregatesInput | SystemContentTemplateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemContentTemplate"> | string
    type?: EnumContentTypeWithAggregatesFilter<"SystemContentTemplate"> | $Enums.ContentType
    category?: EnumContentCategoryWithAggregatesFilter<"SystemContentTemplate"> | $Enums.ContentCategory
    title?: StringWithAggregatesFilter<"SystemContentTemplate"> | string
    description?: StringNullableWithAggregatesFilter<"SystemContentTemplate"> | string | null
    validFromDay?: IntNullableWithAggregatesFilter<"SystemContentTemplate"> | number | null
    validUntilDay?: IntNullableWithAggregatesFilter<"SystemContentTemplate"> | number | null
    sortOrder?: IntWithAggregatesFilter<"SystemContentTemplate"> | number
    isActive?: BoolWithAggregatesFilter<"SystemContentTemplate"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SystemContentTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SystemContentTemplate"> | Date | string
  }

  export type ClinicContentWhereInput = {
    AND?: ClinicContentWhereInput | ClinicContentWhereInput[]
    OR?: ClinicContentWhereInput[]
    NOT?: ClinicContentWhereInput | ClinicContentWhereInput[]
    id?: StringFilter<"ClinicContent"> | string
    clinicId?: StringFilter<"ClinicContent"> | string
    templateId?: StringNullableFilter<"ClinicContent"> | string | null
    type?: EnumContentTypeFilter<"ClinicContent"> | $Enums.ContentType
    category?: EnumContentCategoryFilter<"ClinicContent"> | $Enums.ContentCategory
    title?: StringFilter<"ClinicContent"> | string
    description?: StringNullableFilter<"ClinicContent"> | string | null
    validFromDay?: IntNullableFilter<"ClinicContent"> | number | null
    validUntilDay?: IntNullableFilter<"ClinicContent"> | number | null
    sortOrder?: IntFilter<"ClinicContent"> | number
    isActive?: BoolFilter<"ClinicContent"> | boolean
    isCustom?: BoolFilter<"ClinicContent"> | boolean
    createdAt?: DateTimeFilter<"ClinicContent"> | Date | string
    updatedAt?: DateTimeFilter<"ClinicContent"> | Date | string
    clinic?: XOR<ClinicRelationFilter, ClinicWhereInput>
    patientAdjustments?: PatientContentAdjustmentListRelationFilter
  }

  export type ClinicContentOrderByWithRelationInput = {
    id?: SortOrder
    clinicId?: SortOrder
    templateId?: SortOrderInput | SortOrder
    type?: SortOrder
    category?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    validFromDay?: SortOrderInput | SortOrder
    validUntilDay?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    isCustom?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clinic?: ClinicOrderByWithRelationInput
    patientAdjustments?: PatientContentAdjustmentOrderByRelationAggregateInput
  }

  export type ClinicContentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClinicContentWhereInput | ClinicContentWhereInput[]
    OR?: ClinicContentWhereInput[]
    NOT?: ClinicContentWhereInput | ClinicContentWhereInput[]
    clinicId?: StringFilter<"ClinicContent"> | string
    templateId?: StringNullableFilter<"ClinicContent"> | string | null
    type?: EnumContentTypeFilter<"ClinicContent"> | $Enums.ContentType
    category?: EnumContentCategoryFilter<"ClinicContent"> | $Enums.ContentCategory
    title?: StringFilter<"ClinicContent"> | string
    description?: StringNullableFilter<"ClinicContent"> | string | null
    validFromDay?: IntNullableFilter<"ClinicContent"> | number | null
    validUntilDay?: IntNullableFilter<"ClinicContent"> | number | null
    sortOrder?: IntFilter<"ClinicContent"> | number
    isActive?: BoolFilter<"ClinicContent"> | boolean
    isCustom?: BoolFilter<"ClinicContent"> | boolean
    createdAt?: DateTimeFilter<"ClinicContent"> | Date | string
    updatedAt?: DateTimeFilter<"ClinicContent"> | Date | string
    clinic?: XOR<ClinicRelationFilter, ClinicWhereInput>
    patientAdjustments?: PatientContentAdjustmentListRelationFilter
  }, "id">

  export type ClinicContentOrderByWithAggregationInput = {
    id?: SortOrder
    clinicId?: SortOrder
    templateId?: SortOrderInput | SortOrder
    type?: SortOrder
    category?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    validFromDay?: SortOrderInput | SortOrder
    validUntilDay?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    isCustom?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ClinicContentCountOrderByAggregateInput
    _avg?: ClinicContentAvgOrderByAggregateInput
    _max?: ClinicContentMaxOrderByAggregateInput
    _min?: ClinicContentMinOrderByAggregateInput
    _sum?: ClinicContentSumOrderByAggregateInput
  }

  export type ClinicContentScalarWhereWithAggregatesInput = {
    AND?: ClinicContentScalarWhereWithAggregatesInput | ClinicContentScalarWhereWithAggregatesInput[]
    OR?: ClinicContentScalarWhereWithAggregatesInput[]
    NOT?: ClinicContentScalarWhereWithAggregatesInput | ClinicContentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ClinicContent"> | string
    clinicId?: StringWithAggregatesFilter<"ClinicContent"> | string
    templateId?: StringNullableWithAggregatesFilter<"ClinicContent"> | string | null
    type?: EnumContentTypeWithAggregatesFilter<"ClinicContent"> | $Enums.ContentType
    category?: EnumContentCategoryWithAggregatesFilter<"ClinicContent"> | $Enums.ContentCategory
    title?: StringWithAggregatesFilter<"ClinicContent"> | string
    description?: StringNullableWithAggregatesFilter<"ClinicContent"> | string | null
    validFromDay?: IntNullableWithAggregatesFilter<"ClinicContent"> | number | null
    validUntilDay?: IntNullableWithAggregatesFilter<"ClinicContent"> | number | null
    sortOrder?: IntWithAggregatesFilter<"ClinicContent"> | number
    isActive?: BoolWithAggregatesFilter<"ClinicContent"> | boolean
    isCustom?: BoolWithAggregatesFilter<"ClinicContent"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ClinicContent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ClinicContent"> | Date | string
  }

  export type PatientContentAdjustmentWhereInput = {
    AND?: PatientContentAdjustmentWhereInput | PatientContentAdjustmentWhereInput[]
    OR?: PatientContentAdjustmentWhereInput[]
    NOT?: PatientContentAdjustmentWhereInput | PatientContentAdjustmentWhereInput[]
    id?: StringFilter<"PatientContentAdjustment"> | string
    patientId?: StringFilter<"PatientContentAdjustment"> | string
    baseContentId?: StringNullableFilter<"PatientContentAdjustment"> | string | null
    adjustmentType?: EnumAdjustmentTypeFilter<"PatientContentAdjustment"> | $Enums.AdjustmentType
    contentType?: EnumContentTypeNullableFilter<"PatientContentAdjustment"> | $Enums.ContentType | null
    category?: EnumContentCategoryNullableFilter<"PatientContentAdjustment"> | $Enums.ContentCategory | null
    title?: StringNullableFilter<"PatientContentAdjustment"> | string | null
    description?: StringNullableFilter<"PatientContentAdjustment"> | string | null
    validFromDay?: IntNullableFilter<"PatientContentAdjustment"> | number | null
    validUntilDay?: IntNullableFilter<"PatientContentAdjustment"> | number | null
    reason?: StringNullableFilter<"PatientContentAdjustment"> | string | null
    isActive?: BoolFilter<"PatientContentAdjustment"> | boolean
    createdBy?: StringNullableFilter<"PatientContentAdjustment"> | string | null
    createdAt?: DateTimeFilter<"PatientContentAdjustment"> | Date | string
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    baseContent?: XOR<ClinicContentNullableRelationFilter, ClinicContentWhereInput> | null
  }

  export type PatientContentAdjustmentOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    baseContentId?: SortOrderInput | SortOrder
    adjustmentType?: SortOrder
    contentType?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    validFromDay?: SortOrderInput | SortOrder
    validUntilDay?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    patient?: PatientOrderByWithRelationInput
    baseContent?: ClinicContentOrderByWithRelationInput
  }

  export type PatientContentAdjustmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PatientContentAdjustmentWhereInput | PatientContentAdjustmentWhereInput[]
    OR?: PatientContentAdjustmentWhereInput[]
    NOT?: PatientContentAdjustmentWhereInput | PatientContentAdjustmentWhereInput[]
    patientId?: StringFilter<"PatientContentAdjustment"> | string
    baseContentId?: StringNullableFilter<"PatientContentAdjustment"> | string | null
    adjustmentType?: EnumAdjustmentTypeFilter<"PatientContentAdjustment"> | $Enums.AdjustmentType
    contentType?: EnumContentTypeNullableFilter<"PatientContentAdjustment"> | $Enums.ContentType | null
    category?: EnumContentCategoryNullableFilter<"PatientContentAdjustment"> | $Enums.ContentCategory | null
    title?: StringNullableFilter<"PatientContentAdjustment"> | string | null
    description?: StringNullableFilter<"PatientContentAdjustment"> | string | null
    validFromDay?: IntNullableFilter<"PatientContentAdjustment"> | number | null
    validUntilDay?: IntNullableFilter<"PatientContentAdjustment"> | number | null
    reason?: StringNullableFilter<"PatientContentAdjustment"> | string | null
    isActive?: BoolFilter<"PatientContentAdjustment"> | boolean
    createdBy?: StringNullableFilter<"PatientContentAdjustment"> | string | null
    createdAt?: DateTimeFilter<"PatientContentAdjustment"> | Date | string
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    baseContent?: XOR<ClinicContentNullableRelationFilter, ClinicContentWhereInput> | null
  }, "id">

  export type PatientContentAdjustmentOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    baseContentId?: SortOrderInput | SortOrder
    adjustmentType?: SortOrder
    contentType?: SortOrderInput | SortOrder
    category?: SortOrderInput | SortOrder
    title?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    validFromDay?: SortOrderInput | SortOrder
    validUntilDay?: SortOrderInput | SortOrder
    reason?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: PatientContentAdjustmentCountOrderByAggregateInput
    _avg?: PatientContentAdjustmentAvgOrderByAggregateInput
    _max?: PatientContentAdjustmentMaxOrderByAggregateInput
    _min?: PatientContentAdjustmentMinOrderByAggregateInput
    _sum?: PatientContentAdjustmentSumOrderByAggregateInput
  }

  export type PatientContentAdjustmentScalarWhereWithAggregatesInput = {
    AND?: PatientContentAdjustmentScalarWhereWithAggregatesInput | PatientContentAdjustmentScalarWhereWithAggregatesInput[]
    OR?: PatientContentAdjustmentScalarWhereWithAggregatesInput[]
    NOT?: PatientContentAdjustmentScalarWhereWithAggregatesInput | PatientContentAdjustmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PatientContentAdjustment"> | string
    patientId?: StringWithAggregatesFilter<"PatientContentAdjustment"> | string
    baseContentId?: StringNullableWithAggregatesFilter<"PatientContentAdjustment"> | string | null
    adjustmentType?: EnumAdjustmentTypeWithAggregatesFilter<"PatientContentAdjustment"> | $Enums.AdjustmentType
    contentType?: EnumContentTypeNullableWithAggregatesFilter<"PatientContentAdjustment"> | $Enums.ContentType | null
    category?: EnumContentCategoryNullableWithAggregatesFilter<"PatientContentAdjustment"> | $Enums.ContentCategory | null
    title?: StringNullableWithAggregatesFilter<"PatientContentAdjustment"> | string | null
    description?: StringNullableWithAggregatesFilter<"PatientContentAdjustment"> | string | null
    validFromDay?: IntNullableWithAggregatesFilter<"PatientContentAdjustment"> | number | null
    validUntilDay?: IntNullableWithAggregatesFilter<"PatientContentAdjustment"> | number | null
    reason?: StringNullableWithAggregatesFilter<"PatientContentAdjustment"> | string | null
    isActive?: BoolWithAggregatesFilter<"PatientContentAdjustment"> | boolean
    createdBy?: StringNullableWithAggregatesFilter<"PatientContentAdjustment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PatientContentAdjustment"> | Date | string
  }

  export type TrainingProtocolWhereInput = {
    AND?: TrainingProtocolWhereInput | TrainingProtocolWhereInput[]
    OR?: TrainingProtocolWhereInput[]
    NOT?: TrainingProtocolWhereInput | TrainingProtocolWhereInput[]
    id?: StringFilter<"TrainingProtocol"> | string
    clinicId?: StringNullableFilter<"TrainingProtocol"> | string | null
    name?: StringFilter<"TrainingProtocol"> | string
    surgeryType?: StringNullableFilter<"TrainingProtocol"> | string | null
    description?: StringNullableFilter<"TrainingProtocol"> | string | null
    totalWeeks?: IntFilter<"TrainingProtocol"> | number
    isDefault?: BoolFilter<"TrainingProtocol"> | boolean
    isActive?: BoolFilter<"TrainingProtocol"> | boolean
    createdAt?: DateTimeFilter<"TrainingProtocol"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingProtocol"> | Date | string
    clinic?: XOR<ClinicNullableRelationFilter, ClinicWhereInput> | null
    weeks?: TrainingWeekListRelationFilter
  }

  export type TrainingProtocolOrderByWithRelationInput = {
    id?: SortOrder
    clinicId?: SortOrderInput | SortOrder
    name?: SortOrder
    surgeryType?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    totalWeeks?: SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    clinic?: ClinicOrderByWithRelationInput
    weeks?: TrainingWeekOrderByRelationAggregateInput
  }

  export type TrainingProtocolWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TrainingProtocolWhereInput | TrainingProtocolWhereInput[]
    OR?: TrainingProtocolWhereInput[]
    NOT?: TrainingProtocolWhereInput | TrainingProtocolWhereInput[]
    clinicId?: StringNullableFilter<"TrainingProtocol"> | string | null
    name?: StringFilter<"TrainingProtocol"> | string
    surgeryType?: StringNullableFilter<"TrainingProtocol"> | string | null
    description?: StringNullableFilter<"TrainingProtocol"> | string | null
    totalWeeks?: IntFilter<"TrainingProtocol"> | number
    isDefault?: BoolFilter<"TrainingProtocol"> | boolean
    isActive?: BoolFilter<"TrainingProtocol"> | boolean
    createdAt?: DateTimeFilter<"TrainingProtocol"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingProtocol"> | Date | string
    clinic?: XOR<ClinicNullableRelationFilter, ClinicWhereInput> | null
    weeks?: TrainingWeekListRelationFilter
  }, "id">

  export type TrainingProtocolOrderByWithAggregationInput = {
    id?: SortOrder
    clinicId?: SortOrderInput | SortOrder
    name?: SortOrder
    surgeryType?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    totalWeeks?: SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TrainingProtocolCountOrderByAggregateInput
    _avg?: TrainingProtocolAvgOrderByAggregateInput
    _max?: TrainingProtocolMaxOrderByAggregateInput
    _min?: TrainingProtocolMinOrderByAggregateInput
    _sum?: TrainingProtocolSumOrderByAggregateInput
  }

  export type TrainingProtocolScalarWhereWithAggregatesInput = {
    AND?: TrainingProtocolScalarWhereWithAggregatesInput | TrainingProtocolScalarWhereWithAggregatesInput[]
    OR?: TrainingProtocolScalarWhereWithAggregatesInput[]
    NOT?: TrainingProtocolScalarWhereWithAggregatesInput | TrainingProtocolScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrainingProtocol"> | string
    clinicId?: StringNullableWithAggregatesFilter<"TrainingProtocol"> | string | null
    name?: StringWithAggregatesFilter<"TrainingProtocol"> | string
    surgeryType?: StringNullableWithAggregatesFilter<"TrainingProtocol"> | string | null
    description?: StringNullableWithAggregatesFilter<"TrainingProtocol"> | string | null
    totalWeeks?: IntWithAggregatesFilter<"TrainingProtocol"> | number
    isDefault?: BoolWithAggregatesFilter<"TrainingProtocol"> | boolean
    isActive?: BoolWithAggregatesFilter<"TrainingProtocol"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"TrainingProtocol"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TrainingProtocol"> | Date | string
  }

  export type TrainingWeekWhereInput = {
    AND?: TrainingWeekWhereInput | TrainingWeekWhereInput[]
    OR?: TrainingWeekWhereInput[]
    NOT?: TrainingWeekWhereInput | TrainingWeekWhereInput[]
    id?: StringFilter<"TrainingWeek"> | string
    protocolId?: StringFilter<"TrainingWeek"> | string
    weekNumber?: IntFilter<"TrainingWeek"> | number
    title?: StringFilter<"TrainingWeek"> | string
    dayRange?: StringFilter<"TrainingWeek"> | string
    objective?: StringFilter<"TrainingWeek"> | string
    maxHeartRate?: IntNullableFilter<"TrainingWeek"> | number | null
    heartRateLabel?: StringNullableFilter<"TrainingWeek"> | string | null
    canDo?: StringNullableListFilter<"TrainingWeek">
    avoid?: StringNullableListFilter<"TrainingWeek">
    sortOrder?: IntFilter<"TrainingWeek"> | number
    createdAt?: DateTimeFilter<"TrainingWeek"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingWeek"> | Date | string
    protocol?: XOR<TrainingProtocolRelationFilter, TrainingProtocolWhereInput>
    sessions?: TrainingSessionListRelationFilter
    progress?: PatientTrainingProgressListRelationFilter
  }

  export type TrainingWeekOrderByWithRelationInput = {
    id?: SortOrder
    protocolId?: SortOrder
    weekNumber?: SortOrder
    title?: SortOrder
    dayRange?: SortOrder
    objective?: SortOrder
    maxHeartRate?: SortOrderInput | SortOrder
    heartRateLabel?: SortOrderInput | SortOrder
    canDo?: SortOrder
    avoid?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    protocol?: TrainingProtocolOrderByWithRelationInput
    sessions?: TrainingSessionOrderByRelationAggregateInput
    progress?: PatientTrainingProgressOrderByRelationAggregateInput
  }

  export type TrainingWeekWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    protocolId_weekNumber?: TrainingWeekProtocolIdWeekNumberCompoundUniqueInput
    AND?: TrainingWeekWhereInput | TrainingWeekWhereInput[]
    OR?: TrainingWeekWhereInput[]
    NOT?: TrainingWeekWhereInput | TrainingWeekWhereInput[]
    protocolId?: StringFilter<"TrainingWeek"> | string
    weekNumber?: IntFilter<"TrainingWeek"> | number
    title?: StringFilter<"TrainingWeek"> | string
    dayRange?: StringFilter<"TrainingWeek"> | string
    objective?: StringFilter<"TrainingWeek"> | string
    maxHeartRate?: IntNullableFilter<"TrainingWeek"> | number | null
    heartRateLabel?: StringNullableFilter<"TrainingWeek"> | string | null
    canDo?: StringNullableListFilter<"TrainingWeek">
    avoid?: StringNullableListFilter<"TrainingWeek">
    sortOrder?: IntFilter<"TrainingWeek"> | number
    createdAt?: DateTimeFilter<"TrainingWeek"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingWeek"> | Date | string
    protocol?: XOR<TrainingProtocolRelationFilter, TrainingProtocolWhereInput>
    sessions?: TrainingSessionListRelationFilter
    progress?: PatientTrainingProgressListRelationFilter
  }, "id" | "protocolId_weekNumber">

  export type TrainingWeekOrderByWithAggregationInput = {
    id?: SortOrder
    protocolId?: SortOrder
    weekNumber?: SortOrder
    title?: SortOrder
    dayRange?: SortOrder
    objective?: SortOrder
    maxHeartRate?: SortOrderInput | SortOrder
    heartRateLabel?: SortOrderInput | SortOrder
    canDo?: SortOrder
    avoid?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TrainingWeekCountOrderByAggregateInput
    _avg?: TrainingWeekAvgOrderByAggregateInput
    _max?: TrainingWeekMaxOrderByAggregateInput
    _min?: TrainingWeekMinOrderByAggregateInput
    _sum?: TrainingWeekSumOrderByAggregateInput
  }

  export type TrainingWeekScalarWhereWithAggregatesInput = {
    AND?: TrainingWeekScalarWhereWithAggregatesInput | TrainingWeekScalarWhereWithAggregatesInput[]
    OR?: TrainingWeekScalarWhereWithAggregatesInput[]
    NOT?: TrainingWeekScalarWhereWithAggregatesInput | TrainingWeekScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrainingWeek"> | string
    protocolId?: StringWithAggregatesFilter<"TrainingWeek"> | string
    weekNumber?: IntWithAggregatesFilter<"TrainingWeek"> | number
    title?: StringWithAggregatesFilter<"TrainingWeek"> | string
    dayRange?: StringWithAggregatesFilter<"TrainingWeek"> | string
    objective?: StringWithAggregatesFilter<"TrainingWeek"> | string
    maxHeartRate?: IntNullableWithAggregatesFilter<"TrainingWeek"> | number | null
    heartRateLabel?: StringNullableWithAggregatesFilter<"TrainingWeek"> | string | null
    canDo?: StringNullableListFilter<"TrainingWeek">
    avoid?: StringNullableListFilter<"TrainingWeek">
    sortOrder?: IntWithAggregatesFilter<"TrainingWeek"> | number
    createdAt?: DateTimeWithAggregatesFilter<"TrainingWeek"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TrainingWeek"> | Date | string
  }

  export type TrainingSessionWhereInput = {
    AND?: TrainingSessionWhereInput | TrainingSessionWhereInput[]
    OR?: TrainingSessionWhereInput[]
    NOT?: TrainingSessionWhereInput | TrainingSessionWhereInput[]
    id?: StringFilter<"TrainingSession"> | string
    weekId?: StringFilter<"TrainingSession"> | string
    sessionNumber?: IntFilter<"TrainingSession"> | number
    name?: StringFilter<"TrainingSession"> | string
    description?: StringNullableFilter<"TrainingSession"> | string | null
    duration?: IntNullableFilter<"TrainingSession"> | number | null
    intensity?: StringNullableFilter<"TrainingSession"> | string | null
    sortOrder?: IntFilter<"TrainingSession"> | number
    createdAt?: DateTimeFilter<"TrainingSession"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingSession"> | Date | string
    week?: XOR<TrainingWeekRelationFilter, TrainingWeekWhereInput>
    completions?: PatientSessionCompletionListRelationFilter
  }

  export type TrainingSessionOrderByWithRelationInput = {
    id?: SortOrder
    weekId?: SortOrder
    sessionNumber?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    intensity?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    week?: TrainingWeekOrderByWithRelationInput
    completions?: PatientSessionCompletionOrderByRelationAggregateInput
  }

  export type TrainingSessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    weekId_sessionNumber?: TrainingSessionWeekIdSessionNumberCompoundUniqueInput
    AND?: TrainingSessionWhereInput | TrainingSessionWhereInput[]
    OR?: TrainingSessionWhereInput[]
    NOT?: TrainingSessionWhereInput | TrainingSessionWhereInput[]
    weekId?: StringFilter<"TrainingSession"> | string
    sessionNumber?: IntFilter<"TrainingSession"> | number
    name?: StringFilter<"TrainingSession"> | string
    description?: StringNullableFilter<"TrainingSession"> | string | null
    duration?: IntNullableFilter<"TrainingSession"> | number | null
    intensity?: StringNullableFilter<"TrainingSession"> | string | null
    sortOrder?: IntFilter<"TrainingSession"> | number
    createdAt?: DateTimeFilter<"TrainingSession"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingSession"> | Date | string
    week?: XOR<TrainingWeekRelationFilter, TrainingWeekWhereInput>
    completions?: PatientSessionCompletionListRelationFilter
  }, "id" | "weekId_sessionNumber">

  export type TrainingSessionOrderByWithAggregationInput = {
    id?: SortOrder
    weekId?: SortOrder
    sessionNumber?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    intensity?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TrainingSessionCountOrderByAggregateInput
    _avg?: TrainingSessionAvgOrderByAggregateInput
    _max?: TrainingSessionMaxOrderByAggregateInput
    _min?: TrainingSessionMinOrderByAggregateInput
    _sum?: TrainingSessionSumOrderByAggregateInput
  }

  export type TrainingSessionScalarWhereWithAggregatesInput = {
    AND?: TrainingSessionScalarWhereWithAggregatesInput | TrainingSessionScalarWhereWithAggregatesInput[]
    OR?: TrainingSessionScalarWhereWithAggregatesInput[]
    NOT?: TrainingSessionScalarWhereWithAggregatesInput | TrainingSessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrainingSession"> | string
    weekId?: StringWithAggregatesFilter<"TrainingSession"> | string
    sessionNumber?: IntWithAggregatesFilter<"TrainingSession"> | number
    name?: StringWithAggregatesFilter<"TrainingSession"> | string
    description?: StringNullableWithAggregatesFilter<"TrainingSession"> | string | null
    duration?: IntNullableWithAggregatesFilter<"TrainingSession"> | number | null
    intensity?: StringNullableWithAggregatesFilter<"TrainingSession"> | string | null
    sortOrder?: IntWithAggregatesFilter<"TrainingSession"> | number
    createdAt?: DateTimeWithAggregatesFilter<"TrainingSession"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TrainingSession"> | Date | string
  }

  export type PatientTrainingProgressWhereInput = {
    AND?: PatientTrainingProgressWhereInput | PatientTrainingProgressWhereInput[]
    OR?: PatientTrainingProgressWhereInput[]
    NOT?: PatientTrainingProgressWhereInput | PatientTrainingProgressWhereInput[]
    id?: StringFilter<"PatientTrainingProgress"> | string
    patientId?: StringFilter<"PatientTrainingProgress"> | string
    weekId?: StringFilter<"PatientTrainingProgress"> | string
    status?: EnumTrainingWeekStatusFilter<"PatientTrainingProgress"> | $Enums.TrainingWeekStatus
    startedAt?: DateTimeNullableFilter<"PatientTrainingProgress"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"PatientTrainingProgress"> | Date | string | null
    createdAt?: DateTimeFilter<"PatientTrainingProgress"> | Date | string
    updatedAt?: DateTimeFilter<"PatientTrainingProgress"> | Date | string
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    week?: XOR<TrainingWeekRelationFilter, TrainingWeekWhereInput>
  }

  export type PatientTrainingProgressOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    weekId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    patient?: PatientOrderByWithRelationInput
    week?: TrainingWeekOrderByWithRelationInput
  }

  export type PatientTrainingProgressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    patientId_weekId?: PatientTrainingProgressPatientIdWeekIdCompoundUniqueInput
    AND?: PatientTrainingProgressWhereInput | PatientTrainingProgressWhereInput[]
    OR?: PatientTrainingProgressWhereInput[]
    NOT?: PatientTrainingProgressWhereInput | PatientTrainingProgressWhereInput[]
    patientId?: StringFilter<"PatientTrainingProgress"> | string
    weekId?: StringFilter<"PatientTrainingProgress"> | string
    status?: EnumTrainingWeekStatusFilter<"PatientTrainingProgress"> | $Enums.TrainingWeekStatus
    startedAt?: DateTimeNullableFilter<"PatientTrainingProgress"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"PatientTrainingProgress"> | Date | string | null
    createdAt?: DateTimeFilter<"PatientTrainingProgress"> | Date | string
    updatedAt?: DateTimeFilter<"PatientTrainingProgress"> | Date | string
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    week?: XOR<TrainingWeekRelationFilter, TrainingWeekWhereInput>
  }, "id" | "patientId_weekId">

  export type PatientTrainingProgressOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    weekId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrderInput | SortOrder
    completedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PatientTrainingProgressCountOrderByAggregateInput
    _max?: PatientTrainingProgressMaxOrderByAggregateInput
    _min?: PatientTrainingProgressMinOrderByAggregateInput
  }

  export type PatientTrainingProgressScalarWhereWithAggregatesInput = {
    AND?: PatientTrainingProgressScalarWhereWithAggregatesInput | PatientTrainingProgressScalarWhereWithAggregatesInput[]
    OR?: PatientTrainingProgressScalarWhereWithAggregatesInput[]
    NOT?: PatientTrainingProgressScalarWhereWithAggregatesInput | PatientTrainingProgressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PatientTrainingProgress"> | string
    patientId?: StringWithAggregatesFilter<"PatientTrainingProgress"> | string
    weekId?: StringWithAggregatesFilter<"PatientTrainingProgress"> | string
    status?: EnumTrainingWeekStatusWithAggregatesFilter<"PatientTrainingProgress"> | $Enums.TrainingWeekStatus
    startedAt?: DateTimeNullableWithAggregatesFilter<"PatientTrainingProgress"> | Date | string | null
    completedAt?: DateTimeNullableWithAggregatesFilter<"PatientTrainingProgress"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PatientTrainingProgress"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PatientTrainingProgress"> | Date | string
  }

  export type PatientSessionCompletionWhereInput = {
    AND?: PatientSessionCompletionWhereInput | PatientSessionCompletionWhereInput[]
    OR?: PatientSessionCompletionWhereInput[]
    NOT?: PatientSessionCompletionWhereInput | PatientSessionCompletionWhereInput[]
    id?: StringFilter<"PatientSessionCompletion"> | string
    patientId?: StringFilter<"PatientSessionCompletion"> | string
    sessionId?: StringFilter<"PatientSessionCompletion"> | string
    completedAt?: DateTimeFilter<"PatientSessionCompletion"> | Date | string
    notes?: StringNullableFilter<"PatientSessionCompletion"> | string | null
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    session?: XOR<TrainingSessionRelationFilter, TrainingSessionWhereInput>
  }

  export type PatientSessionCompletionOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    sessionId?: SortOrder
    completedAt?: SortOrder
    notes?: SortOrderInput | SortOrder
    patient?: PatientOrderByWithRelationInput
    session?: TrainingSessionOrderByWithRelationInput
  }

  export type PatientSessionCompletionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    patientId_sessionId?: PatientSessionCompletionPatientIdSessionIdCompoundUniqueInput
    AND?: PatientSessionCompletionWhereInput | PatientSessionCompletionWhereInput[]
    OR?: PatientSessionCompletionWhereInput[]
    NOT?: PatientSessionCompletionWhereInput | PatientSessionCompletionWhereInput[]
    patientId?: StringFilter<"PatientSessionCompletion"> | string
    sessionId?: StringFilter<"PatientSessionCompletion"> | string
    completedAt?: DateTimeFilter<"PatientSessionCompletion"> | Date | string
    notes?: StringNullableFilter<"PatientSessionCompletion"> | string | null
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    session?: XOR<TrainingSessionRelationFilter, TrainingSessionWhereInput>
  }, "id" | "patientId_sessionId">

  export type PatientSessionCompletionOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    sessionId?: SortOrder
    completedAt?: SortOrder
    notes?: SortOrderInput | SortOrder
    _count?: PatientSessionCompletionCountOrderByAggregateInput
    _max?: PatientSessionCompletionMaxOrderByAggregateInput
    _min?: PatientSessionCompletionMinOrderByAggregateInput
  }

  export type PatientSessionCompletionScalarWhereWithAggregatesInput = {
    AND?: PatientSessionCompletionScalarWhereWithAggregatesInput | PatientSessionCompletionScalarWhereWithAggregatesInput[]
    OR?: PatientSessionCompletionScalarWhereWithAggregatesInput[]
    NOT?: PatientSessionCompletionScalarWhereWithAggregatesInput | PatientSessionCompletionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PatientSessionCompletion"> | string
    patientId?: StringWithAggregatesFilter<"PatientSessionCompletion"> | string
    sessionId?: StringWithAggregatesFilter<"PatientSessionCompletion"> | string
    completedAt?: DateTimeWithAggregatesFilter<"PatientSessionCompletion"> | Date | string
    notes?: StringNullableWithAggregatesFilter<"PatientSessionCompletion"> | string | null
  }

  export type ChatConversationWhereInput = {
    AND?: ChatConversationWhereInput | ChatConversationWhereInput[]
    OR?: ChatConversationWhereInput[]
    NOT?: ChatConversationWhereInput | ChatConversationWhereInput[]
    id?: StringFilter<"ChatConversation"> | string
    patientId?: StringFilter<"ChatConversation"> | string
    createdAt?: DateTimeFilter<"ChatConversation"> | Date | string
    updatedAt?: DateTimeFilter<"ChatConversation"> | Date | string
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    messages?: ChatMessageListRelationFilter
  }

  export type ChatConversationOrderByWithRelationInput = {
    id?: SortOrder
    patientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    patient?: PatientOrderByWithRelationInput
    messages?: ChatMessageOrderByRelationAggregateInput
  }

  export type ChatConversationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChatConversationWhereInput | ChatConversationWhereInput[]
    OR?: ChatConversationWhereInput[]
    NOT?: ChatConversationWhereInput | ChatConversationWhereInput[]
    patientId?: StringFilter<"ChatConversation"> | string
    createdAt?: DateTimeFilter<"ChatConversation"> | Date | string
    updatedAt?: DateTimeFilter<"ChatConversation"> | Date | string
    patient?: XOR<PatientRelationFilter, PatientWhereInput>
    messages?: ChatMessageListRelationFilter
  }, "id">

  export type ChatConversationOrderByWithAggregationInput = {
    id?: SortOrder
    patientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ChatConversationCountOrderByAggregateInput
    _max?: ChatConversationMaxOrderByAggregateInput
    _min?: ChatConversationMinOrderByAggregateInput
  }

  export type ChatConversationScalarWhereWithAggregatesInput = {
    AND?: ChatConversationScalarWhereWithAggregatesInput | ChatConversationScalarWhereWithAggregatesInput[]
    OR?: ChatConversationScalarWhereWithAggregatesInput[]
    NOT?: ChatConversationScalarWhereWithAggregatesInput | ChatConversationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChatConversation"> | string
    patientId?: StringWithAggregatesFilter<"ChatConversation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ChatConversation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChatConversation"> | Date | string
  }

  export type ChatMessageWhereInput = {
    AND?: ChatMessageWhereInput | ChatMessageWhereInput[]
    OR?: ChatMessageWhereInput[]
    NOT?: ChatMessageWhereInput | ChatMessageWhereInput[]
    id?: StringFilter<"ChatMessage"> | string
    conversationId?: StringFilter<"ChatMessage"> | string
    role?: StringFilter<"ChatMessage"> | string
    content?: StringFilter<"ChatMessage"> | string
    createdAt?: DateTimeFilter<"ChatMessage"> | Date | string
    conversation?: XOR<ChatConversationRelationFilter, ChatConversationWhereInput>
  }

  export type ChatMessageOrderByWithRelationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    conversation?: ChatConversationOrderByWithRelationInput
  }

  export type ChatMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChatMessageWhereInput | ChatMessageWhereInput[]
    OR?: ChatMessageWhereInput[]
    NOT?: ChatMessageWhereInput | ChatMessageWhereInput[]
    conversationId?: StringFilter<"ChatMessage"> | string
    role?: StringFilter<"ChatMessage"> | string
    content?: StringFilter<"ChatMessage"> | string
    createdAt?: DateTimeFilter<"ChatMessage"> | Date | string
    conversation?: XOR<ChatConversationRelationFilter, ChatConversationWhereInput>
  }, "id">

  export type ChatMessageOrderByWithAggregationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    _count?: ChatMessageCountOrderByAggregateInput
    _max?: ChatMessageMaxOrderByAggregateInput
    _min?: ChatMessageMinOrderByAggregateInput
  }

  export type ChatMessageScalarWhereWithAggregatesInput = {
    AND?: ChatMessageScalarWhereWithAggregatesInput | ChatMessageScalarWhereWithAggregatesInput[]
    OR?: ChatMessageScalarWhereWithAggregatesInput[]
    NOT?: ChatMessageScalarWhereWithAggregatesInput | ChatMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChatMessage"> | string
    conversationId?: StringWithAggregatesFilter<"ChatMessage"> | string
    role?: StringWithAggregatesFilter<"ChatMessage"> | string
    content?: StringWithAggregatesFilter<"ChatMessage"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ChatMessage"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic?: ClinicCreateNestedOneWithoutUsersInput
    patient?: PatientCreateNestedOneWithoutUserInput
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    role?: $Enums.UserRole
    clinicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient?: PatientUncheckedCreateNestedOneWithoutUserInput
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneWithoutUsersNestedInput
    patient?: PatientUpdateOneWithoutUserNestedInput
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUncheckedUpdateOneWithoutUserNestedInput
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    role?: $Enums.UserRole
    clinicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetCreateInput = {
    id?: string
    code: string
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutPasswordResetsInput
  }

  export type PasswordResetUncheckedCreateInput = {
    id?: string
    userId: string
    code: string
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
  }

  export type PasswordResetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPasswordResetsNestedInput
  }

  export type PasswordResetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetCreateManyInput = {
    id?: string
    userId: string
    code: string
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
  }

  export type PasswordResetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicCreateInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    logoUrl?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutClinicInput
    patients?: PatientCreateNestedManyWithoutClinicInput
    contents?: ClinicContentCreateNestedManyWithoutClinicInput
    trainingProtocols?: TrainingProtocolCreateNestedManyWithoutClinicInput
  }

  export type ClinicUncheckedCreateInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    logoUrl?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutClinicInput
    patients?: PatientUncheckedCreateNestedManyWithoutClinicInput
    contents?: ClinicContentUncheckedCreateNestedManyWithoutClinicInput
    trainingProtocols?: TrainingProtocolUncheckedCreateNestedManyWithoutClinicInput
  }

  export type ClinicUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutClinicNestedInput
    patients?: PatientUpdateManyWithoutClinicNestedInput
    contents?: ClinicContentUpdateManyWithoutClinicNestedInput
    trainingProtocols?: TrainingProtocolUpdateManyWithoutClinicNestedInput
  }

  export type ClinicUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutClinicNestedInput
    patients?: PatientUncheckedUpdateManyWithoutClinicNestedInput
    contents?: ClinicContentUncheckedUpdateManyWithoutClinicNestedInput
    trainingProtocols?: TrainingProtocolUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type ClinicCreateManyInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    logoUrl?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClinicUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientCreateInput = {
    id?: string
    cpf?: string | null
    phone?: string | null
    birthDate?: Date | string | null
    surgeryDate?: Date | string | null
    surgeryType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPatientInput
    clinic: ClinicCreateNestedOneWithoutPatientsInput
    contentAdjustments?: PatientContentAdjustmentCreateNestedManyWithoutPatientInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    medicationLogs?: MedicationLogCreateNestedManyWithoutPatientInput
    chatConversations?: ChatConversationCreateNestedManyWithoutPatientInput
    exams?: ExamCreateNestedManyWithoutPatientInput
    trainingProgress?: PatientTrainingProgressCreateNestedManyWithoutPatientInput
    sessionCompletions?: PatientSessionCompletionCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateInput = {
    id?: string
    userId: string
    clinicId: string
    cpf?: string | null
    phone?: string | null
    birthDate?: Date | string | null
    surgeryDate?: Date | string | null
    surgeryType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contentAdjustments?: PatientContentAdjustmentUncheckedCreateNestedManyWithoutPatientInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    medicationLogs?: MedicationLogUncheckedCreateNestedManyWithoutPatientInput
    chatConversations?: ChatConversationUncheckedCreateNestedManyWithoutPatientInput
    exams?: ExamUncheckedCreateNestedManyWithoutPatientInput
    trainingProgress?: PatientTrainingProgressUncheckedCreateNestedManyWithoutPatientInput
    sessionCompletions?: PatientSessionCompletionUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surgeryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surgeryType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPatientNestedInput
    clinic?: ClinicUpdateOneRequiredWithoutPatientsNestedInput
    contentAdjustments?: PatientContentAdjustmentUpdateManyWithoutPatientNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    medicationLogs?: MedicationLogUpdateManyWithoutPatientNestedInput
    chatConversations?: ChatConversationUpdateManyWithoutPatientNestedInput
    exams?: ExamUpdateManyWithoutPatientNestedInput
    trainingProgress?: PatientTrainingProgressUpdateManyWithoutPatientNestedInput
    sessionCompletions?: PatientSessionCompletionUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surgeryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surgeryType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contentAdjustments?: PatientContentAdjustmentUncheckedUpdateManyWithoutPatientNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    medicationLogs?: MedicationLogUncheckedUpdateManyWithoutPatientNestedInput
    chatConversations?: ChatConversationUncheckedUpdateManyWithoutPatientNestedInput
    exams?: ExamUncheckedUpdateManyWithoutPatientNestedInput
    trainingProgress?: PatientTrainingProgressUncheckedUpdateManyWithoutPatientNestedInput
    sessionCompletions?: PatientSessionCompletionUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientCreateManyInput = {
    id?: string
    userId: string
    clinicId: string
    cpf?: string | null
    phone?: string | null
    birthDate?: Date | string | null
    surgeryDate?: Date | string | null
    surgeryType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surgeryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surgeryType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surgeryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surgeryType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentCreateInput = {
    id?: string
    title: string
    description?: string | null
    date: Date | string
    time: string
    type: $Enums.AppointmentType
    status?: $Enums.AppointmentStatus
    location?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutAppointmentsInput
  }

  export type AppointmentUncheckedCreateInput = {
    id?: string
    patientId: string
    title: string
    description?: string | null
    date: Date | string
    time: string
    type: $Enums.AppointmentType
    status?: $Enums.AppointmentStatus
    location?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    type?: EnumAppointmentTypeFieldUpdateOperationsInput | $Enums.AppointmentType
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutAppointmentsNestedInput
  }

  export type AppointmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    type?: EnumAppointmentTypeFieldUpdateOperationsInput | $Enums.AppointmentType
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentCreateManyInput = {
    id?: string
    patientId: string
    title: string
    description?: string | null
    date: Date | string
    time: string
    type: $Enums.AppointmentType
    status?: $Enums.AppointmentStatus
    location?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    type?: EnumAppointmentTypeFieldUpdateOperationsInput | $Enums.AppointmentType
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    type?: EnumAppointmentTypeFieldUpdateOperationsInput | $Enums.AppointmentType
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicationLogCreateInput = {
    id?: string
    contentId: string
    takenAt?: Date | string
    scheduledTime: string
    createdAt?: Date | string
    patient: PatientCreateNestedOneWithoutMedicationLogsInput
  }

  export type MedicationLogUncheckedCreateInput = {
    id?: string
    patientId: string
    contentId: string
    takenAt?: Date | string
    scheduledTime: string
    createdAt?: Date | string
  }

  export type MedicationLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    takenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutMedicationLogsNestedInput
  }

  export type MedicationLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    takenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicationLogCreateManyInput = {
    id?: string
    patientId: string
    contentId: string
    takenAt?: Date | string
    scheduledTime: string
    createdAt?: Date | string
  }

  export type MedicationLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    takenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicationLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    takenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamCreateInput = {
    id?: string
    title: string
    type: string
    date: Date | string
    status?: $Enums.ExamStatus
    fileUrl?: string | null
    fileName?: string | null
    fileSize?: number | null
    mimeType?: string | null
    notes?: string | null
    result?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutExamsInput
  }

  export type ExamUncheckedCreateInput = {
    id?: string
    patientId: string
    title: string
    type: string
    date: Date | string
    status?: $Enums.ExamStatus
    fileUrl?: string | null
    fileName?: string | null
    fileSize?: number | null
    mimeType?: string | null
    notes?: string | null
    result?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumExamStatusFieldUpdateOperationsInput | $Enums.ExamStatus
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutExamsNestedInput
  }

  export type ExamUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumExamStatusFieldUpdateOperationsInput | $Enums.ExamStatus
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamCreateManyInput = {
    id?: string
    patientId: string
    title: string
    type: string
    date: Date | string
    status?: $Enums.ExamStatus
    fileUrl?: string | null
    fileName?: string | null
    fileSize?: number | null
    mimeType?: string | null
    notes?: string | null
    result?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumExamStatusFieldUpdateOperationsInput | $Enums.ExamStatus
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumExamStatusFieldUpdateOperationsInput | $Enums.ExamStatus
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemContentTemplateCreateInput = {
    id?: string
    type: $Enums.ContentType
    category: $Enums.ContentCategory
    title: string
    description?: string | null
    validFromDay?: number | null
    validUntilDay?: number | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemContentTemplateUncheckedCreateInput = {
    id?: string
    type: $Enums.ContentType
    category: $Enums.ContentCategory
    title: string
    description?: string | null
    validFromDay?: number | null
    validUntilDay?: number | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemContentTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    category?: EnumContentCategoryFieldUpdateOperationsInput | $Enums.ContentCategory
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    validFromDay?: NullableIntFieldUpdateOperationsInput | number | null
    validUntilDay?: NullableIntFieldUpdateOperationsInput | number | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemContentTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    category?: EnumContentCategoryFieldUpdateOperationsInput | $Enums.ContentCategory
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    validFromDay?: NullableIntFieldUpdateOperationsInput | number | null
    validUntilDay?: NullableIntFieldUpdateOperationsInput | number | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemContentTemplateCreateManyInput = {
    id?: string
    type: $Enums.ContentType
    category: $Enums.ContentCategory
    title: string
    description?: string | null
    validFromDay?: number | null
    validUntilDay?: number | null
    sortOrder?: number
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemContentTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    category?: EnumContentCategoryFieldUpdateOperationsInput | $Enums.ContentCategory
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    validFromDay?: NullableIntFieldUpdateOperationsInput | number | null
    validUntilDay?: NullableIntFieldUpdateOperationsInput | number | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemContentTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    category?: EnumContentCategoryFieldUpdateOperationsInput | $Enums.ContentCategory
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    validFromDay?: NullableIntFieldUpdateOperationsInput | number | null
    validUntilDay?: NullableIntFieldUpdateOperationsInput | number | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicContentCreateInput = {
    id?: string
    templateId?: string | null
    type: $Enums.ContentType
    category: $Enums.ContentCategory
    title: string
    description?: string | null
    validFromDay?: number | null
    validUntilDay?: number | null
    sortOrder?: number
    isActive?: boolean
    isCustom?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutContentsInput
    patientAdjustments?: PatientContentAdjustmentCreateNestedManyWithoutBaseContentInput
  }

  export type ClinicContentUncheckedCreateInput = {
    id?: string
    clinicId: string
    templateId?: string | null
    type: $Enums.ContentType
    category: $Enums.ContentCategory
    title: string
    description?: string | null
    validFromDay?: number | null
    validUntilDay?: number | null
    sortOrder?: number
    isActive?: boolean
    isCustom?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    patientAdjustments?: PatientContentAdjustmentUncheckedCreateNestedManyWithoutBaseContentInput
  }

  export type ClinicContentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    category?: EnumContentCategoryFieldUpdateOperationsInput | $Enums.ContentCategory
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    validFromDay?: NullableIntFieldUpdateOperationsInput | number | null
    validUntilDay?: NullableIntFieldUpdateOperationsInput | number | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isCustom?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutContentsNestedInput
    patientAdjustments?: PatientContentAdjustmentUpdateManyWithoutBaseContentNestedInput
  }

  export type ClinicContentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    category?: EnumContentCategoryFieldUpdateOperationsInput | $Enums.ContentCategory
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    validFromDay?: NullableIntFieldUpdateOperationsInput | number | null
    validUntilDay?: NullableIntFieldUpdateOperationsInput | number | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isCustom?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patientAdjustments?: PatientContentAdjustmentUncheckedUpdateManyWithoutBaseContentNestedInput
  }

  export type ClinicContentCreateManyInput = {
    id?: string
    clinicId: string
    templateId?: string | null
    type: $Enums.ContentType
    category: $Enums.ContentCategory
    title: string
    description?: string | null
    validFromDay?: number | null
    validUntilDay?: number | null
    sortOrder?: number
    isActive?: boolean
    isCustom?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClinicContentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    category?: EnumContentCategoryFieldUpdateOperationsInput | $Enums.ContentCategory
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    validFromDay?: NullableIntFieldUpdateOperationsInput | number | null
    validUntilDay?: NullableIntFieldUpdateOperationsInput | number | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isCustom?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicContentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    category?: EnumContentCategoryFieldUpdateOperationsInput | $Enums.ContentCategory
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    validFromDay?: NullableIntFieldUpdateOperationsInput | number | null
    validUntilDay?: NullableIntFieldUpdateOperationsInput | number | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isCustom?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientContentAdjustmentCreateInput = {
    id?: string
    adjustmentType: $Enums.AdjustmentType
    contentType?: $Enums.ContentType | null
    category?: $Enums.ContentCategory | null
    title?: string | null
    description?: string | null
    validFromDay?: number | null
    validUntilDay?: number | null
    reason?: string | null
    isActive?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    patient: PatientCreateNestedOneWithoutContentAdjustmentsInput
    baseContent?: ClinicContentCreateNestedOneWithoutPatientAdjustmentsInput
  }

  export type PatientContentAdjustmentUncheckedCreateInput = {
    id?: string
    patientId: string
    baseContentId?: string | null
    adjustmentType: $Enums.AdjustmentType
    contentType?: $Enums.ContentType | null
    category?: $Enums.ContentCategory | null
    title?: string | null
    description?: string | null
    validFromDay?: number | null
    validUntilDay?: number | null
    reason?: string | null
    isActive?: boolean
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type PatientContentAdjustmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    adjustmentType?: EnumAdjustmentTypeFieldUpdateOperationsInput | $Enums.AdjustmentType
    contentType?: NullableEnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType | null
    category?: NullableEnumContentCategoryFieldUpdateOperationsInput | $Enums.ContentCategory | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    validFromDay?: NullableIntFieldUpdateOperationsInput | number | null
    validUntilDay?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutContentAdjustmentsNestedInput
    baseContent?: ClinicContentUpdateOneWithoutPatientAdjustmentsNestedInput
  }

  export type PatientContentAdjustmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    baseContentId?: NullableStringFieldUpdateOperationsInput | string | null
    adjustmentType?: EnumAdjustmentTypeFieldUpdateOperationsInput | $Enums.AdjustmentType
    contentType?: NullableEnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType | null
    category?: NullableEnumContentCategoryFieldUpdateOperationsInput | $Enums.ContentCategory | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    validFromDay?: NullableIntFieldUpdateOperationsInput | number | null
    validUntilDay?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientContentAdjustmentCreateManyInput = {
    id?: string
    patientId: string
    baseContentId?: string | null
    adjustmentType: $Enums.AdjustmentType
    contentType?: $Enums.ContentType | null
    category?: $Enums.ContentCategory | null
    title?: string | null
    description?: string | null
    validFromDay?: number | null
    validUntilDay?: number | null
    reason?: string | null
    isActive?: boolean
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type PatientContentAdjustmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    adjustmentType?: EnumAdjustmentTypeFieldUpdateOperationsInput | $Enums.AdjustmentType
    contentType?: NullableEnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType | null
    category?: NullableEnumContentCategoryFieldUpdateOperationsInput | $Enums.ContentCategory | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    validFromDay?: NullableIntFieldUpdateOperationsInput | number | null
    validUntilDay?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientContentAdjustmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    baseContentId?: NullableStringFieldUpdateOperationsInput | string | null
    adjustmentType?: EnumAdjustmentTypeFieldUpdateOperationsInput | $Enums.AdjustmentType
    contentType?: NullableEnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType | null
    category?: NullableEnumContentCategoryFieldUpdateOperationsInput | $Enums.ContentCategory | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    validFromDay?: NullableIntFieldUpdateOperationsInput | number | null
    validUntilDay?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingProtocolCreateInput = {
    id?: string
    name: string
    surgeryType?: string | null
    description?: string | null
    totalWeeks?: number
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic?: ClinicCreateNestedOneWithoutTrainingProtocolsInput
    weeks?: TrainingWeekCreateNestedManyWithoutProtocolInput
  }

  export type TrainingProtocolUncheckedCreateInput = {
    id?: string
    clinicId?: string | null
    name: string
    surgeryType?: string | null
    description?: string | null
    totalWeeks?: number
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    weeks?: TrainingWeekUncheckedCreateNestedManyWithoutProtocolInput
  }

  export type TrainingProtocolUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    surgeryType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalWeeks?: IntFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneWithoutTrainingProtocolsNestedInput
    weeks?: TrainingWeekUpdateManyWithoutProtocolNestedInput
  }

  export type TrainingProtocolUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    surgeryType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalWeeks?: IntFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    weeks?: TrainingWeekUncheckedUpdateManyWithoutProtocolNestedInput
  }

  export type TrainingProtocolCreateManyInput = {
    id?: string
    clinicId?: string | null
    name: string
    surgeryType?: string | null
    description?: string | null
    totalWeeks?: number
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingProtocolUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    surgeryType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalWeeks?: IntFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingProtocolUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    surgeryType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalWeeks?: IntFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingWeekCreateInput = {
    id?: string
    weekNumber: number
    title: string
    dayRange: string
    objective: string
    maxHeartRate?: number | null
    heartRateLabel?: string | null
    canDo?: TrainingWeekCreatecanDoInput | string[]
    avoid?: TrainingWeekCreateavoidInput | string[]
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    protocol: TrainingProtocolCreateNestedOneWithoutWeeksInput
    sessions?: TrainingSessionCreateNestedManyWithoutWeekInput
    progress?: PatientTrainingProgressCreateNestedManyWithoutWeekInput
  }

  export type TrainingWeekUncheckedCreateInput = {
    id?: string
    protocolId: string
    weekNumber: number
    title: string
    dayRange: string
    objective: string
    maxHeartRate?: number | null
    heartRateLabel?: string | null
    canDo?: TrainingWeekCreatecanDoInput | string[]
    avoid?: TrainingWeekCreateavoidInput | string[]
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: TrainingSessionUncheckedCreateNestedManyWithoutWeekInput
    progress?: PatientTrainingProgressUncheckedCreateNestedManyWithoutWeekInput
  }

  export type TrainingWeekUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    dayRange?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    maxHeartRate?: NullableIntFieldUpdateOperationsInput | number | null
    heartRateLabel?: NullableStringFieldUpdateOperationsInput | string | null
    canDo?: TrainingWeekUpdatecanDoInput | string[]
    avoid?: TrainingWeekUpdateavoidInput | string[]
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    protocol?: TrainingProtocolUpdateOneRequiredWithoutWeeksNestedInput
    sessions?: TrainingSessionUpdateManyWithoutWeekNestedInput
    progress?: PatientTrainingProgressUpdateManyWithoutWeekNestedInput
  }

  export type TrainingWeekUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    protocolId?: StringFieldUpdateOperationsInput | string
    weekNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    dayRange?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    maxHeartRate?: NullableIntFieldUpdateOperationsInput | number | null
    heartRateLabel?: NullableStringFieldUpdateOperationsInput | string | null
    canDo?: TrainingWeekUpdatecanDoInput | string[]
    avoid?: TrainingWeekUpdateavoidInput | string[]
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: TrainingSessionUncheckedUpdateManyWithoutWeekNestedInput
    progress?: PatientTrainingProgressUncheckedUpdateManyWithoutWeekNestedInput
  }

  export type TrainingWeekCreateManyInput = {
    id?: string
    protocolId: string
    weekNumber: number
    title: string
    dayRange: string
    objective: string
    maxHeartRate?: number | null
    heartRateLabel?: string | null
    canDo?: TrainingWeekCreatecanDoInput | string[]
    avoid?: TrainingWeekCreateavoidInput | string[]
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingWeekUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    dayRange?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    maxHeartRate?: NullableIntFieldUpdateOperationsInput | number | null
    heartRateLabel?: NullableStringFieldUpdateOperationsInput | string | null
    canDo?: TrainingWeekUpdatecanDoInput | string[]
    avoid?: TrainingWeekUpdateavoidInput | string[]
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingWeekUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    protocolId?: StringFieldUpdateOperationsInput | string
    weekNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    dayRange?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    maxHeartRate?: NullableIntFieldUpdateOperationsInput | number | null
    heartRateLabel?: NullableStringFieldUpdateOperationsInput | string | null
    canDo?: TrainingWeekUpdatecanDoInput | string[]
    avoid?: TrainingWeekUpdateavoidInput | string[]
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingSessionCreateInput = {
    id?: string
    sessionNumber: number
    name: string
    description?: string | null
    duration?: number | null
    intensity?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    week: TrainingWeekCreateNestedOneWithoutSessionsInput
    completions?: PatientSessionCompletionCreateNestedManyWithoutSessionInput
  }

  export type TrainingSessionUncheckedCreateInput = {
    id?: string
    weekId: string
    sessionNumber: number
    name: string
    description?: string | null
    duration?: number | null
    intensity?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    completions?: PatientSessionCompletionUncheckedCreateNestedManyWithoutSessionInput
  }

  export type TrainingSessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionNumber?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    intensity?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    week?: TrainingWeekUpdateOneRequiredWithoutSessionsNestedInput
    completions?: PatientSessionCompletionUpdateManyWithoutSessionNestedInput
  }

  export type TrainingSessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekId?: StringFieldUpdateOperationsInput | string
    sessionNumber?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    intensity?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completions?: PatientSessionCompletionUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type TrainingSessionCreateManyInput = {
    id?: string
    weekId: string
    sessionNumber: number
    name: string
    description?: string | null
    duration?: number | null
    intensity?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingSessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionNumber?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    intensity?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingSessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekId?: StringFieldUpdateOperationsInput | string
    sessionNumber?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    intensity?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientTrainingProgressCreateInput = {
    id?: string
    status?: $Enums.TrainingWeekStatus
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutTrainingProgressInput
    week: TrainingWeekCreateNestedOneWithoutProgressInput
  }

  export type PatientTrainingProgressUncheckedCreateInput = {
    id?: string
    patientId: string
    weekId: string
    status?: $Enums.TrainingWeekStatus
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatientTrainingProgressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTrainingWeekStatusFieldUpdateOperationsInput | $Enums.TrainingWeekStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutTrainingProgressNestedInput
    week?: TrainingWeekUpdateOneRequiredWithoutProgressNestedInput
  }

  export type PatientTrainingProgressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    weekId?: StringFieldUpdateOperationsInput | string
    status?: EnumTrainingWeekStatusFieldUpdateOperationsInput | $Enums.TrainingWeekStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientTrainingProgressCreateManyInput = {
    id?: string
    patientId: string
    weekId: string
    status?: $Enums.TrainingWeekStatus
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatientTrainingProgressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTrainingWeekStatusFieldUpdateOperationsInput | $Enums.TrainingWeekStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientTrainingProgressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    weekId?: StringFieldUpdateOperationsInput | string
    status?: EnumTrainingWeekStatusFieldUpdateOperationsInput | $Enums.TrainingWeekStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientSessionCompletionCreateInput = {
    id?: string
    completedAt?: Date | string
    notes?: string | null
    patient: PatientCreateNestedOneWithoutSessionCompletionsInput
    session: TrainingSessionCreateNestedOneWithoutCompletionsInput
  }

  export type PatientSessionCompletionUncheckedCreateInput = {
    id?: string
    patientId: string
    sessionId: string
    completedAt?: Date | string
    notes?: string | null
  }

  export type PatientSessionCompletionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: PatientUpdateOneRequiredWithoutSessionCompletionsNestedInput
    session?: TrainingSessionUpdateOneRequiredWithoutCompletionsNestedInput
  }

  export type PatientSessionCompletionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PatientSessionCompletionCreateManyInput = {
    id?: string
    patientId: string
    sessionId: string
    completedAt?: Date | string
    notes?: string | null
  }

  export type PatientSessionCompletionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PatientSessionCompletionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChatConversationCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutChatConversationsInput
    messages?: ChatMessageCreateNestedManyWithoutConversationInput
  }

  export type ChatConversationUncheckedCreateInput = {
    id?: string
    patientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: ChatMessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ChatConversationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutChatConversationsNestedInput
    messages?: ChatMessageUpdateManyWithoutConversationNestedInput
  }

  export type ChatConversationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: ChatMessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ChatConversationCreateManyInput = {
    id?: string
    patientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatConversationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatConversationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageCreateInput = {
    id?: string
    role: string
    content: string
    createdAt?: Date | string
    conversation: ChatConversationCreateNestedOneWithoutMessagesInput
  }

  export type ChatMessageUncheckedCreateInput = {
    id?: string
    conversationId: string
    role: string
    content: string
    createdAt?: Date | string
  }

  export type ChatMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: ChatConversationUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type ChatMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageCreateManyInput = {
    id?: string
    conversationId: string
    role: string
    content: string
    createdAt?: Date | string
  }

  export type ChatMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ClinicNullableRelationFilter = {
    is?: ClinicWhereInput | null
    isNot?: ClinicWhereInput | null
  }

  export type PatientNullableRelationFilter = {
    is?: PatientWhereInput | null
    isNot?: PatientWhereInput | null
  }

  export type PasswordResetListRelationFilter = {
    every?: PasswordResetWhereInput
    some?: PasswordResetWhereInput
    none?: PasswordResetWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type PasswordResetOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    role?: SortOrder
    clinicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    role?: SortOrder
    clinicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    passwordHash?: SortOrder
    name?: SortOrder
    role?: SortOrder
    clinicId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type PasswordResetCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    code?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    code?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
  }

  export type PasswordResetMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    code?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type UserListRelationFilter = {
    every?: UserWhereInput
    some?: UserWhereInput
    none?: UserWhereInput
  }

  export type PatientListRelationFilter = {
    every?: PatientWhereInput
    some?: PatientWhereInput
    none?: PatientWhereInput
  }

  export type ClinicContentListRelationFilter = {
    every?: ClinicContentWhereInput
    some?: ClinicContentWhereInput
    none?: ClinicContentWhereInput
  }

  export type TrainingProtocolListRelationFilter = {
    every?: TrainingProtocolWhereInput
    some?: TrainingProtocolWhereInput
    none?: TrainingProtocolWhereInput
  }

  export type UserOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PatientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClinicContentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TrainingProtocolOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClinicCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    logoUrl?: SortOrder
    primaryColor?: SortOrder
    secondaryColor?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClinicMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    logoUrl?: SortOrder
    primaryColor?: SortOrder
    secondaryColor?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClinicMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    logoUrl?: SortOrder
    primaryColor?: SortOrder
    secondaryColor?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ClinicRelationFilter = {
    is?: ClinicWhereInput
    isNot?: ClinicWhereInput
  }

  export type PatientContentAdjustmentListRelationFilter = {
    every?: PatientContentAdjustmentWhereInput
    some?: PatientContentAdjustmentWhereInput
    none?: PatientContentAdjustmentWhereInput
  }

  export type AppointmentListRelationFilter = {
    every?: AppointmentWhereInput
    some?: AppointmentWhereInput
    none?: AppointmentWhereInput
  }

  export type MedicationLogListRelationFilter = {
    every?: MedicationLogWhereInput
    some?: MedicationLogWhereInput
    none?: MedicationLogWhereInput
  }

  export type ChatConversationListRelationFilter = {
    every?: ChatConversationWhereInput
    some?: ChatConversationWhereInput
    none?: ChatConversationWhereInput
  }

  export type ExamListRelationFilter = {
    every?: ExamWhereInput
    some?: ExamWhereInput
    none?: ExamWhereInput
  }

  export type PatientTrainingProgressListRelationFilter = {
    every?: PatientTrainingProgressWhereInput
    some?: PatientTrainingProgressWhereInput
    none?: PatientTrainingProgressWhereInput
  }

  export type PatientSessionCompletionListRelationFilter = {
    every?: PatientSessionCompletionWhereInput
    some?: PatientSessionCompletionWhereInput
    none?: PatientSessionCompletionWhereInput
  }

  export type PatientContentAdjustmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AppointmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MedicationLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatConversationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ExamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PatientTrainingProgressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PatientSessionCompletionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PatientCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    clinicId?: SortOrder
    cpf?: SortOrder
    phone?: SortOrder
    birthDate?: SortOrder
    surgeryDate?: SortOrder
    surgeryType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PatientMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    clinicId?: SortOrder
    cpf?: SortOrder
    phone?: SortOrder
    birthDate?: SortOrder
    surgeryDate?: SortOrder
    surgeryType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PatientMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    clinicId?: SortOrder
    cpf?: SortOrder
    phone?: SortOrder
    birthDate?: SortOrder
    surgeryDate?: SortOrder
    surgeryType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumAppointmentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentType | EnumAppointmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentType[] | ListEnumAppointmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentType[] | ListEnumAppointmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentTypeFilter<$PrismaModel> | $Enums.AppointmentType
  }

  export type EnumAppointmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentStatusFilter<$PrismaModel> | $Enums.AppointmentStatus
  }

  export type PatientRelationFilter = {
    is?: PatientWhereInput
    isNot?: PatientWhereInput
  }

  export type AppointmentCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    date?: SortOrder
    time?: SortOrder
    type?: SortOrder
    status?: SortOrder
    location?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppointmentMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    date?: SortOrder
    time?: SortOrder
    type?: SortOrder
    status?: SortOrder
    location?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppointmentMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    date?: SortOrder
    time?: SortOrder
    type?: SortOrder
    status?: SortOrder
    location?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumAppointmentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentType | EnumAppointmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentType[] | ListEnumAppointmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentType[] | ListEnumAppointmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentTypeWithAggregatesFilter<$PrismaModel> | $Enums.AppointmentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppointmentTypeFilter<$PrismaModel>
    _max?: NestedEnumAppointmentTypeFilter<$PrismaModel>
  }

  export type EnumAppointmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.AppointmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppointmentStatusFilter<$PrismaModel>
    _max?: NestedEnumAppointmentStatusFilter<$PrismaModel>
  }

  export type MedicationLogCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    contentId?: SortOrder
    takenAt?: SortOrder
    scheduledTime?: SortOrder
    createdAt?: SortOrder
  }

  export type MedicationLogMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    contentId?: SortOrder
    takenAt?: SortOrder
    scheduledTime?: SortOrder
    createdAt?: SortOrder
  }

  export type MedicationLogMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    contentId?: SortOrder
    takenAt?: SortOrder
    scheduledTime?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumExamStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ExamStatus | EnumExamStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ExamStatus[] | ListEnumExamStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExamStatus[] | ListEnumExamStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumExamStatusFilter<$PrismaModel> | $Enums.ExamStatus
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type ExamCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    title?: SortOrder
    type?: SortOrder
    date?: SortOrder
    status?: SortOrder
    fileUrl?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    notes?: SortOrder
    result?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamAvgOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type ExamMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    title?: SortOrder
    type?: SortOrder
    date?: SortOrder
    status?: SortOrder
    fileUrl?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    notes?: SortOrder
    result?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    title?: SortOrder
    type?: SortOrder
    date?: SortOrder
    status?: SortOrder
    fileUrl?: SortOrder
    fileName?: SortOrder
    fileSize?: SortOrder
    mimeType?: SortOrder
    notes?: SortOrder
    result?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ExamSumOrderByAggregateInput = {
    fileSize?: SortOrder
  }

  export type EnumExamStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExamStatus | EnumExamStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ExamStatus[] | ListEnumExamStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExamStatus[] | ListEnumExamStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumExamStatusWithAggregatesFilter<$PrismaModel> | $Enums.ExamStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExamStatusFilter<$PrismaModel>
    _max?: NestedEnumExamStatusFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumContentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentType | EnumContentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContentTypeFilter<$PrismaModel> | $Enums.ContentType
  }

  export type EnumContentCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentCategory | EnumContentCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ContentCategory[] | ListEnumContentCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentCategory[] | ListEnumContentCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumContentCategoryFilter<$PrismaModel> | $Enums.ContentCategory
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type SystemContentTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    category?: SortOrder
    title?: SortOrder
    description?: SortOrder
    validFromDay?: SortOrder
    validUntilDay?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemContentTemplateAvgOrderByAggregateInput = {
    validFromDay?: SortOrder
    validUntilDay?: SortOrder
    sortOrder?: SortOrder
  }

  export type SystemContentTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    category?: SortOrder
    title?: SortOrder
    description?: SortOrder
    validFromDay?: SortOrder
    validUntilDay?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemContentTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    category?: SortOrder
    title?: SortOrder
    description?: SortOrder
    validFromDay?: SortOrder
    validUntilDay?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemContentTemplateSumOrderByAggregateInput = {
    validFromDay?: SortOrder
    validUntilDay?: SortOrder
    sortOrder?: SortOrder
  }

  export type EnumContentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentType | EnumContentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContentTypeWithAggregatesFilter<$PrismaModel> | $Enums.ContentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContentTypeFilter<$PrismaModel>
    _max?: NestedEnumContentTypeFilter<$PrismaModel>
  }

  export type EnumContentCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentCategory | EnumContentCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ContentCategory[] | ListEnumContentCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentCategory[] | ListEnumContentCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumContentCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ContentCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContentCategoryFilter<$PrismaModel>
    _max?: NestedEnumContentCategoryFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type ClinicContentCountOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    templateId?: SortOrder
    type?: SortOrder
    category?: SortOrder
    title?: SortOrder
    description?: SortOrder
    validFromDay?: SortOrder
    validUntilDay?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    isCustom?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClinicContentAvgOrderByAggregateInput = {
    validFromDay?: SortOrder
    validUntilDay?: SortOrder
    sortOrder?: SortOrder
  }

  export type ClinicContentMaxOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    templateId?: SortOrder
    type?: SortOrder
    category?: SortOrder
    title?: SortOrder
    description?: SortOrder
    validFromDay?: SortOrder
    validUntilDay?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    isCustom?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClinicContentMinOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    templateId?: SortOrder
    type?: SortOrder
    category?: SortOrder
    title?: SortOrder
    description?: SortOrder
    validFromDay?: SortOrder
    validUntilDay?: SortOrder
    sortOrder?: SortOrder
    isActive?: SortOrder
    isCustom?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ClinicContentSumOrderByAggregateInput = {
    validFromDay?: SortOrder
    validUntilDay?: SortOrder
    sortOrder?: SortOrder
  }

  export type EnumAdjustmentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AdjustmentType | EnumAdjustmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AdjustmentType[] | ListEnumAdjustmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdjustmentType[] | ListEnumAdjustmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAdjustmentTypeFilter<$PrismaModel> | $Enums.AdjustmentType
  }

  export type EnumContentTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentType | EnumContentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumContentTypeNullableFilter<$PrismaModel> | $Enums.ContentType | null
  }

  export type EnumContentCategoryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentCategory | EnumContentCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.ContentCategory[] | ListEnumContentCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ContentCategory[] | ListEnumContentCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumContentCategoryNullableFilter<$PrismaModel> | $Enums.ContentCategory | null
  }

  export type ClinicContentNullableRelationFilter = {
    is?: ClinicContentWhereInput | null
    isNot?: ClinicContentWhereInput | null
  }

  export type PatientContentAdjustmentCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    baseContentId?: SortOrder
    adjustmentType?: SortOrder
    contentType?: SortOrder
    category?: SortOrder
    title?: SortOrder
    description?: SortOrder
    validFromDay?: SortOrder
    validUntilDay?: SortOrder
    reason?: SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type PatientContentAdjustmentAvgOrderByAggregateInput = {
    validFromDay?: SortOrder
    validUntilDay?: SortOrder
  }

  export type PatientContentAdjustmentMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    baseContentId?: SortOrder
    adjustmentType?: SortOrder
    contentType?: SortOrder
    category?: SortOrder
    title?: SortOrder
    description?: SortOrder
    validFromDay?: SortOrder
    validUntilDay?: SortOrder
    reason?: SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type PatientContentAdjustmentMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    baseContentId?: SortOrder
    adjustmentType?: SortOrder
    contentType?: SortOrder
    category?: SortOrder
    title?: SortOrder
    description?: SortOrder
    validFromDay?: SortOrder
    validUntilDay?: SortOrder
    reason?: SortOrder
    isActive?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
  }

  export type PatientContentAdjustmentSumOrderByAggregateInput = {
    validFromDay?: SortOrder
    validUntilDay?: SortOrder
  }

  export type EnumAdjustmentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdjustmentType | EnumAdjustmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AdjustmentType[] | ListEnumAdjustmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdjustmentType[] | ListEnumAdjustmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAdjustmentTypeWithAggregatesFilter<$PrismaModel> | $Enums.AdjustmentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdjustmentTypeFilter<$PrismaModel>
    _max?: NestedEnumAdjustmentTypeFilter<$PrismaModel>
  }

  export type EnumContentTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentType | EnumContentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumContentTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ContentType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumContentTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumContentTypeNullableFilter<$PrismaModel>
  }

  export type EnumContentCategoryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentCategory | EnumContentCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.ContentCategory[] | ListEnumContentCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ContentCategory[] | ListEnumContentCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumContentCategoryNullableWithAggregatesFilter<$PrismaModel> | $Enums.ContentCategory | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumContentCategoryNullableFilter<$PrismaModel>
    _max?: NestedEnumContentCategoryNullableFilter<$PrismaModel>
  }

  export type TrainingWeekListRelationFilter = {
    every?: TrainingWeekWhereInput
    some?: TrainingWeekWhereInput
    none?: TrainingWeekWhereInput
  }

  export type TrainingWeekOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TrainingProtocolCountOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    name?: SortOrder
    surgeryType?: SortOrder
    description?: SortOrder
    totalWeeks?: SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingProtocolAvgOrderByAggregateInput = {
    totalWeeks?: SortOrder
  }

  export type TrainingProtocolMaxOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    name?: SortOrder
    surgeryType?: SortOrder
    description?: SortOrder
    totalWeeks?: SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingProtocolMinOrderByAggregateInput = {
    id?: SortOrder
    clinicId?: SortOrder
    name?: SortOrder
    surgeryType?: SortOrder
    description?: SortOrder
    totalWeeks?: SortOrder
    isDefault?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingProtocolSumOrderByAggregateInput = {
    totalWeeks?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type TrainingProtocolRelationFilter = {
    is?: TrainingProtocolWhereInput
    isNot?: TrainingProtocolWhereInput
  }

  export type TrainingSessionListRelationFilter = {
    every?: TrainingSessionWhereInput
    some?: TrainingSessionWhereInput
    none?: TrainingSessionWhereInput
  }

  export type TrainingSessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TrainingWeekProtocolIdWeekNumberCompoundUniqueInput = {
    protocolId: string
    weekNumber: number
  }

  export type TrainingWeekCountOrderByAggregateInput = {
    id?: SortOrder
    protocolId?: SortOrder
    weekNumber?: SortOrder
    title?: SortOrder
    dayRange?: SortOrder
    objective?: SortOrder
    maxHeartRate?: SortOrder
    heartRateLabel?: SortOrder
    canDo?: SortOrder
    avoid?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingWeekAvgOrderByAggregateInput = {
    weekNumber?: SortOrder
    maxHeartRate?: SortOrder
    sortOrder?: SortOrder
  }

  export type TrainingWeekMaxOrderByAggregateInput = {
    id?: SortOrder
    protocolId?: SortOrder
    weekNumber?: SortOrder
    title?: SortOrder
    dayRange?: SortOrder
    objective?: SortOrder
    maxHeartRate?: SortOrder
    heartRateLabel?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingWeekMinOrderByAggregateInput = {
    id?: SortOrder
    protocolId?: SortOrder
    weekNumber?: SortOrder
    title?: SortOrder
    dayRange?: SortOrder
    objective?: SortOrder
    maxHeartRate?: SortOrder
    heartRateLabel?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingWeekSumOrderByAggregateInput = {
    weekNumber?: SortOrder
    maxHeartRate?: SortOrder
    sortOrder?: SortOrder
  }

  export type TrainingWeekRelationFilter = {
    is?: TrainingWeekWhereInput
    isNot?: TrainingWeekWhereInput
  }

  export type TrainingSessionWeekIdSessionNumberCompoundUniqueInput = {
    weekId: string
    sessionNumber: number
  }

  export type TrainingSessionCountOrderByAggregateInput = {
    id?: SortOrder
    weekId?: SortOrder
    sessionNumber?: SortOrder
    name?: SortOrder
    description?: SortOrder
    duration?: SortOrder
    intensity?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingSessionAvgOrderByAggregateInput = {
    sessionNumber?: SortOrder
    duration?: SortOrder
    sortOrder?: SortOrder
  }

  export type TrainingSessionMaxOrderByAggregateInput = {
    id?: SortOrder
    weekId?: SortOrder
    sessionNumber?: SortOrder
    name?: SortOrder
    description?: SortOrder
    duration?: SortOrder
    intensity?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingSessionMinOrderByAggregateInput = {
    id?: SortOrder
    weekId?: SortOrder
    sessionNumber?: SortOrder
    name?: SortOrder
    description?: SortOrder
    duration?: SortOrder
    intensity?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TrainingSessionSumOrderByAggregateInput = {
    sessionNumber?: SortOrder
    duration?: SortOrder
    sortOrder?: SortOrder
  }

  export type EnumTrainingWeekStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TrainingWeekStatus | EnumTrainingWeekStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TrainingWeekStatus[] | ListEnumTrainingWeekStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrainingWeekStatus[] | ListEnumTrainingWeekStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTrainingWeekStatusFilter<$PrismaModel> | $Enums.TrainingWeekStatus
  }

  export type PatientTrainingProgressPatientIdWeekIdCompoundUniqueInput = {
    patientId: string
    weekId: string
  }

  export type PatientTrainingProgressCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    weekId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PatientTrainingProgressMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    weekId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PatientTrainingProgressMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    weekId?: SortOrder
    status?: SortOrder
    startedAt?: SortOrder
    completedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumTrainingWeekStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrainingWeekStatus | EnumTrainingWeekStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TrainingWeekStatus[] | ListEnumTrainingWeekStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrainingWeekStatus[] | ListEnumTrainingWeekStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTrainingWeekStatusWithAggregatesFilter<$PrismaModel> | $Enums.TrainingWeekStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTrainingWeekStatusFilter<$PrismaModel>
    _max?: NestedEnumTrainingWeekStatusFilter<$PrismaModel>
  }

  export type TrainingSessionRelationFilter = {
    is?: TrainingSessionWhereInput
    isNot?: TrainingSessionWhereInput
  }

  export type PatientSessionCompletionPatientIdSessionIdCompoundUniqueInput = {
    patientId: string
    sessionId: string
  }

  export type PatientSessionCompletionCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    sessionId?: SortOrder
    completedAt?: SortOrder
    notes?: SortOrder
  }

  export type PatientSessionCompletionMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    sessionId?: SortOrder
    completedAt?: SortOrder
    notes?: SortOrder
  }

  export type PatientSessionCompletionMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    sessionId?: SortOrder
    completedAt?: SortOrder
    notes?: SortOrder
  }

  export type ChatMessageListRelationFilter = {
    every?: ChatMessageWhereInput
    some?: ChatMessageWhereInput
    none?: ChatMessageWhereInput
  }

  export type ChatMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChatConversationCountOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChatConversationMaxOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChatConversationMinOrderByAggregateInput = {
    id?: SortOrder
    patientId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChatConversationRelationFilter = {
    is?: ChatConversationWhereInput
    isNot?: ChatConversationWhereInput
  }

  export type ChatMessageCountOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type ChatMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type ChatMessageMinOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    role?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
  }

  export type ClinicCreateNestedOneWithoutUsersInput = {
    create?: XOR<ClinicCreateWithoutUsersInput, ClinicUncheckedCreateWithoutUsersInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutUsersInput
    connect?: ClinicWhereUniqueInput
  }

  export type PatientCreateNestedOneWithoutUserInput = {
    create?: XOR<PatientCreateWithoutUserInput, PatientUncheckedCreateWithoutUserInput>
    connectOrCreate?: PatientCreateOrConnectWithoutUserInput
    connect?: PatientWhereUniqueInput
  }

  export type PasswordResetCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordResetCreateWithoutUserInput, PasswordResetUncheckedCreateWithoutUserInput> | PasswordResetCreateWithoutUserInput[] | PasswordResetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetCreateOrConnectWithoutUserInput | PasswordResetCreateOrConnectWithoutUserInput[]
    createMany?: PasswordResetCreateManyUserInputEnvelope
    connect?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
  }

  export type PatientUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<PatientCreateWithoutUserInput, PatientUncheckedCreateWithoutUserInput>
    connectOrCreate?: PatientCreateOrConnectWithoutUserInput
    connect?: PatientWhereUniqueInput
  }

  export type PasswordResetUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<PasswordResetCreateWithoutUserInput, PasswordResetUncheckedCreateWithoutUserInput> | PasswordResetCreateWithoutUserInput[] | PasswordResetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetCreateOrConnectWithoutUserInput | PasswordResetCreateOrConnectWithoutUserInput[]
    createMany?: PasswordResetCreateManyUserInputEnvelope
    connect?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ClinicUpdateOneWithoutUsersNestedInput = {
    create?: XOR<ClinicCreateWithoutUsersInput, ClinicUncheckedCreateWithoutUsersInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutUsersInput
    upsert?: ClinicUpsertWithoutUsersInput
    disconnect?: ClinicWhereInput | boolean
    delete?: ClinicWhereInput | boolean
    connect?: ClinicWhereUniqueInput
    update?: XOR<XOR<ClinicUpdateToOneWithWhereWithoutUsersInput, ClinicUpdateWithoutUsersInput>, ClinicUncheckedUpdateWithoutUsersInput>
  }

  export type PatientUpdateOneWithoutUserNestedInput = {
    create?: XOR<PatientCreateWithoutUserInput, PatientUncheckedCreateWithoutUserInput>
    connectOrCreate?: PatientCreateOrConnectWithoutUserInput
    upsert?: PatientUpsertWithoutUserInput
    disconnect?: PatientWhereInput | boolean
    delete?: PatientWhereInput | boolean
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutUserInput, PatientUpdateWithoutUserInput>, PatientUncheckedUpdateWithoutUserInput>
  }

  export type PasswordResetUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordResetCreateWithoutUserInput, PasswordResetUncheckedCreateWithoutUserInput> | PasswordResetCreateWithoutUserInput[] | PasswordResetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetCreateOrConnectWithoutUserInput | PasswordResetCreateOrConnectWithoutUserInput[]
    upsert?: PasswordResetUpsertWithWhereUniqueWithoutUserInput | PasswordResetUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordResetCreateManyUserInputEnvelope
    set?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
    disconnect?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
    delete?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
    connect?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
    update?: PasswordResetUpdateWithWhereUniqueWithoutUserInput | PasswordResetUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordResetUpdateManyWithWhereWithoutUserInput | PasswordResetUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordResetScalarWhereInput | PasswordResetScalarWhereInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type PatientUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<PatientCreateWithoutUserInput, PatientUncheckedCreateWithoutUserInput>
    connectOrCreate?: PatientCreateOrConnectWithoutUserInput
    upsert?: PatientUpsertWithoutUserInput
    disconnect?: PatientWhereInput | boolean
    delete?: PatientWhereInput | boolean
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutUserInput, PatientUpdateWithoutUserInput>, PatientUncheckedUpdateWithoutUserInput>
  }

  export type PasswordResetUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<PasswordResetCreateWithoutUserInput, PasswordResetUncheckedCreateWithoutUserInput> | PasswordResetCreateWithoutUserInput[] | PasswordResetUncheckedCreateWithoutUserInput[]
    connectOrCreate?: PasswordResetCreateOrConnectWithoutUserInput | PasswordResetCreateOrConnectWithoutUserInput[]
    upsert?: PasswordResetUpsertWithWhereUniqueWithoutUserInput | PasswordResetUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: PasswordResetCreateManyUserInputEnvelope
    set?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
    disconnect?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
    delete?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
    connect?: PasswordResetWhereUniqueInput | PasswordResetWhereUniqueInput[]
    update?: PasswordResetUpdateWithWhereUniqueWithoutUserInput | PasswordResetUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: PasswordResetUpdateManyWithWhereWithoutUserInput | PasswordResetUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: PasswordResetScalarWhereInput | PasswordResetScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutPasswordResetsInput = {
    create?: XOR<UserCreateWithoutPasswordResetsInput, UserUncheckedCreateWithoutPasswordResetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordResetsInput
    connect?: UserWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutPasswordResetsNestedInput = {
    create?: XOR<UserCreateWithoutPasswordResetsInput, UserUncheckedCreateWithoutPasswordResetsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPasswordResetsInput
    upsert?: UserUpsertWithoutPasswordResetsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPasswordResetsInput, UserUpdateWithoutPasswordResetsInput>, UserUncheckedUpdateWithoutPasswordResetsInput>
  }

  export type UserCreateNestedManyWithoutClinicInput = {
    create?: XOR<UserCreateWithoutClinicInput, UserUncheckedCreateWithoutClinicInput> | UserCreateWithoutClinicInput[] | UserUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: UserCreateOrConnectWithoutClinicInput | UserCreateOrConnectWithoutClinicInput[]
    createMany?: UserCreateManyClinicInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type PatientCreateNestedManyWithoutClinicInput = {
    create?: XOR<PatientCreateWithoutClinicInput, PatientUncheckedCreateWithoutClinicInput> | PatientCreateWithoutClinicInput[] | PatientUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutClinicInput | PatientCreateOrConnectWithoutClinicInput[]
    createMany?: PatientCreateManyClinicInputEnvelope
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
  }

  export type ClinicContentCreateNestedManyWithoutClinicInput = {
    create?: XOR<ClinicContentCreateWithoutClinicInput, ClinicContentUncheckedCreateWithoutClinicInput> | ClinicContentCreateWithoutClinicInput[] | ClinicContentUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: ClinicContentCreateOrConnectWithoutClinicInput | ClinicContentCreateOrConnectWithoutClinicInput[]
    createMany?: ClinicContentCreateManyClinicInputEnvelope
    connect?: ClinicContentWhereUniqueInput | ClinicContentWhereUniqueInput[]
  }

  export type TrainingProtocolCreateNestedManyWithoutClinicInput = {
    create?: XOR<TrainingProtocolCreateWithoutClinicInput, TrainingProtocolUncheckedCreateWithoutClinicInput> | TrainingProtocolCreateWithoutClinicInput[] | TrainingProtocolUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: TrainingProtocolCreateOrConnectWithoutClinicInput | TrainingProtocolCreateOrConnectWithoutClinicInput[]
    createMany?: TrainingProtocolCreateManyClinicInputEnvelope
    connect?: TrainingProtocolWhereUniqueInput | TrainingProtocolWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedManyWithoutClinicInput = {
    create?: XOR<UserCreateWithoutClinicInput, UserUncheckedCreateWithoutClinicInput> | UserCreateWithoutClinicInput[] | UserUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: UserCreateOrConnectWithoutClinicInput | UserCreateOrConnectWithoutClinicInput[]
    createMany?: UserCreateManyClinicInputEnvelope
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
  }

  export type PatientUncheckedCreateNestedManyWithoutClinicInput = {
    create?: XOR<PatientCreateWithoutClinicInput, PatientUncheckedCreateWithoutClinicInput> | PatientCreateWithoutClinicInput[] | PatientUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutClinicInput | PatientCreateOrConnectWithoutClinicInput[]
    createMany?: PatientCreateManyClinicInputEnvelope
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
  }

  export type ClinicContentUncheckedCreateNestedManyWithoutClinicInput = {
    create?: XOR<ClinicContentCreateWithoutClinicInput, ClinicContentUncheckedCreateWithoutClinicInput> | ClinicContentCreateWithoutClinicInput[] | ClinicContentUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: ClinicContentCreateOrConnectWithoutClinicInput | ClinicContentCreateOrConnectWithoutClinicInput[]
    createMany?: ClinicContentCreateManyClinicInputEnvelope
    connect?: ClinicContentWhereUniqueInput | ClinicContentWhereUniqueInput[]
  }

  export type TrainingProtocolUncheckedCreateNestedManyWithoutClinicInput = {
    create?: XOR<TrainingProtocolCreateWithoutClinicInput, TrainingProtocolUncheckedCreateWithoutClinicInput> | TrainingProtocolCreateWithoutClinicInput[] | TrainingProtocolUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: TrainingProtocolCreateOrConnectWithoutClinicInput | TrainingProtocolCreateOrConnectWithoutClinicInput[]
    createMany?: TrainingProtocolCreateManyClinicInputEnvelope
    connect?: TrainingProtocolWhereUniqueInput | TrainingProtocolWhereUniqueInput[]
  }

  export type UserUpdateManyWithoutClinicNestedInput = {
    create?: XOR<UserCreateWithoutClinicInput, UserUncheckedCreateWithoutClinicInput> | UserCreateWithoutClinicInput[] | UserUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: UserCreateOrConnectWithoutClinicInput | UserCreateOrConnectWithoutClinicInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutClinicInput | UserUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: UserCreateManyClinicInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutClinicInput | UserUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: UserUpdateManyWithWhereWithoutClinicInput | UserUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type PatientUpdateManyWithoutClinicNestedInput = {
    create?: XOR<PatientCreateWithoutClinicInput, PatientUncheckedCreateWithoutClinicInput> | PatientCreateWithoutClinicInput[] | PatientUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutClinicInput | PatientCreateOrConnectWithoutClinicInput[]
    upsert?: PatientUpsertWithWhereUniqueWithoutClinicInput | PatientUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: PatientCreateManyClinicInputEnvelope
    set?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    disconnect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    delete?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    update?: PatientUpdateWithWhereUniqueWithoutClinicInput | PatientUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: PatientUpdateManyWithWhereWithoutClinicInput | PatientUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: PatientScalarWhereInput | PatientScalarWhereInput[]
  }

  export type ClinicContentUpdateManyWithoutClinicNestedInput = {
    create?: XOR<ClinicContentCreateWithoutClinicInput, ClinicContentUncheckedCreateWithoutClinicInput> | ClinicContentCreateWithoutClinicInput[] | ClinicContentUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: ClinicContentCreateOrConnectWithoutClinicInput | ClinicContentCreateOrConnectWithoutClinicInput[]
    upsert?: ClinicContentUpsertWithWhereUniqueWithoutClinicInput | ClinicContentUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: ClinicContentCreateManyClinicInputEnvelope
    set?: ClinicContentWhereUniqueInput | ClinicContentWhereUniqueInput[]
    disconnect?: ClinicContentWhereUniqueInput | ClinicContentWhereUniqueInput[]
    delete?: ClinicContentWhereUniqueInput | ClinicContentWhereUniqueInput[]
    connect?: ClinicContentWhereUniqueInput | ClinicContentWhereUniqueInput[]
    update?: ClinicContentUpdateWithWhereUniqueWithoutClinicInput | ClinicContentUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: ClinicContentUpdateManyWithWhereWithoutClinicInput | ClinicContentUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: ClinicContentScalarWhereInput | ClinicContentScalarWhereInput[]
  }

  export type TrainingProtocolUpdateManyWithoutClinicNestedInput = {
    create?: XOR<TrainingProtocolCreateWithoutClinicInput, TrainingProtocolUncheckedCreateWithoutClinicInput> | TrainingProtocolCreateWithoutClinicInput[] | TrainingProtocolUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: TrainingProtocolCreateOrConnectWithoutClinicInput | TrainingProtocolCreateOrConnectWithoutClinicInput[]
    upsert?: TrainingProtocolUpsertWithWhereUniqueWithoutClinicInput | TrainingProtocolUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: TrainingProtocolCreateManyClinicInputEnvelope
    set?: TrainingProtocolWhereUniqueInput | TrainingProtocolWhereUniqueInput[]
    disconnect?: TrainingProtocolWhereUniqueInput | TrainingProtocolWhereUniqueInput[]
    delete?: TrainingProtocolWhereUniqueInput | TrainingProtocolWhereUniqueInput[]
    connect?: TrainingProtocolWhereUniqueInput | TrainingProtocolWhereUniqueInput[]
    update?: TrainingProtocolUpdateWithWhereUniqueWithoutClinicInput | TrainingProtocolUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: TrainingProtocolUpdateManyWithWhereWithoutClinicInput | TrainingProtocolUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: TrainingProtocolScalarWhereInput | TrainingProtocolScalarWhereInput[]
  }

  export type UserUncheckedUpdateManyWithoutClinicNestedInput = {
    create?: XOR<UserCreateWithoutClinicInput, UserUncheckedCreateWithoutClinicInput> | UserCreateWithoutClinicInput[] | UserUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: UserCreateOrConnectWithoutClinicInput | UserCreateOrConnectWithoutClinicInput[]
    upsert?: UserUpsertWithWhereUniqueWithoutClinicInput | UserUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: UserCreateManyClinicInputEnvelope
    set?: UserWhereUniqueInput | UserWhereUniqueInput[]
    disconnect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    delete?: UserWhereUniqueInput | UserWhereUniqueInput[]
    connect?: UserWhereUniqueInput | UserWhereUniqueInput[]
    update?: UserUpdateWithWhereUniqueWithoutClinicInput | UserUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: UserUpdateManyWithWhereWithoutClinicInput | UserUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: UserScalarWhereInput | UserScalarWhereInput[]
  }

  export type PatientUncheckedUpdateManyWithoutClinicNestedInput = {
    create?: XOR<PatientCreateWithoutClinicInput, PatientUncheckedCreateWithoutClinicInput> | PatientCreateWithoutClinicInput[] | PatientUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: PatientCreateOrConnectWithoutClinicInput | PatientCreateOrConnectWithoutClinicInput[]
    upsert?: PatientUpsertWithWhereUniqueWithoutClinicInput | PatientUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: PatientCreateManyClinicInputEnvelope
    set?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    disconnect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    delete?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    connect?: PatientWhereUniqueInput | PatientWhereUniqueInput[]
    update?: PatientUpdateWithWhereUniqueWithoutClinicInput | PatientUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: PatientUpdateManyWithWhereWithoutClinicInput | PatientUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: PatientScalarWhereInput | PatientScalarWhereInput[]
  }

  export type ClinicContentUncheckedUpdateManyWithoutClinicNestedInput = {
    create?: XOR<ClinicContentCreateWithoutClinicInput, ClinicContentUncheckedCreateWithoutClinicInput> | ClinicContentCreateWithoutClinicInput[] | ClinicContentUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: ClinicContentCreateOrConnectWithoutClinicInput | ClinicContentCreateOrConnectWithoutClinicInput[]
    upsert?: ClinicContentUpsertWithWhereUniqueWithoutClinicInput | ClinicContentUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: ClinicContentCreateManyClinicInputEnvelope
    set?: ClinicContentWhereUniqueInput | ClinicContentWhereUniqueInput[]
    disconnect?: ClinicContentWhereUniqueInput | ClinicContentWhereUniqueInput[]
    delete?: ClinicContentWhereUniqueInput | ClinicContentWhereUniqueInput[]
    connect?: ClinicContentWhereUniqueInput | ClinicContentWhereUniqueInput[]
    update?: ClinicContentUpdateWithWhereUniqueWithoutClinicInput | ClinicContentUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: ClinicContentUpdateManyWithWhereWithoutClinicInput | ClinicContentUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: ClinicContentScalarWhereInput | ClinicContentScalarWhereInput[]
  }

  export type TrainingProtocolUncheckedUpdateManyWithoutClinicNestedInput = {
    create?: XOR<TrainingProtocolCreateWithoutClinicInput, TrainingProtocolUncheckedCreateWithoutClinicInput> | TrainingProtocolCreateWithoutClinicInput[] | TrainingProtocolUncheckedCreateWithoutClinicInput[]
    connectOrCreate?: TrainingProtocolCreateOrConnectWithoutClinicInput | TrainingProtocolCreateOrConnectWithoutClinicInput[]
    upsert?: TrainingProtocolUpsertWithWhereUniqueWithoutClinicInput | TrainingProtocolUpsertWithWhereUniqueWithoutClinicInput[]
    createMany?: TrainingProtocolCreateManyClinicInputEnvelope
    set?: TrainingProtocolWhereUniqueInput | TrainingProtocolWhereUniqueInput[]
    disconnect?: TrainingProtocolWhereUniqueInput | TrainingProtocolWhereUniqueInput[]
    delete?: TrainingProtocolWhereUniqueInput | TrainingProtocolWhereUniqueInput[]
    connect?: TrainingProtocolWhereUniqueInput | TrainingProtocolWhereUniqueInput[]
    update?: TrainingProtocolUpdateWithWhereUniqueWithoutClinicInput | TrainingProtocolUpdateWithWhereUniqueWithoutClinicInput[]
    updateMany?: TrainingProtocolUpdateManyWithWhereWithoutClinicInput | TrainingProtocolUpdateManyWithWhereWithoutClinicInput[]
    deleteMany?: TrainingProtocolScalarWhereInput | TrainingProtocolScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutPatientInput = {
    create?: XOR<UserCreateWithoutPatientInput, UserUncheckedCreateWithoutPatientInput>
    connectOrCreate?: UserCreateOrConnectWithoutPatientInput
    connect?: UserWhereUniqueInput
  }

  export type ClinicCreateNestedOneWithoutPatientsInput = {
    create?: XOR<ClinicCreateWithoutPatientsInput, ClinicUncheckedCreateWithoutPatientsInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutPatientsInput
    connect?: ClinicWhereUniqueInput
  }

  export type PatientContentAdjustmentCreateNestedManyWithoutPatientInput = {
    create?: XOR<PatientContentAdjustmentCreateWithoutPatientInput, PatientContentAdjustmentUncheckedCreateWithoutPatientInput> | PatientContentAdjustmentCreateWithoutPatientInput[] | PatientContentAdjustmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PatientContentAdjustmentCreateOrConnectWithoutPatientInput | PatientContentAdjustmentCreateOrConnectWithoutPatientInput[]
    createMany?: PatientContentAdjustmentCreateManyPatientInputEnvelope
    connect?: PatientContentAdjustmentWhereUniqueInput | PatientContentAdjustmentWhereUniqueInput[]
  }

  export type AppointmentCreateNestedManyWithoutPatientInput = {
    create?: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput> | AppointmentCreateWithoutPatientInput[] | AppointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPatientInput | AppointmentCreateOrConnectWithoutPatientInput[]
    createMany?: AppointmentCreateManyPatientInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type MedicationLogCreateNestedManyWithoutPatientInput = {
    create?: XOR<MedicationLogCreateWithoutPatientInput, MedicationLogUncheckedCreateWithoutPatientInput> | MedicationLogCreateWithoutPatientInput[] | MedicationLogUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: MedicationLogCreateOrConnectWithoutPatientInput | MedicationLogCreateOrConnectWithoutPatientInput[]
    createMany?: MedicationLogCreateManyPatientInputEnvelope
    connect?: MedicationLogWhereUniqueInput | MedicationLogWhereUniqueInput[]
  }

  export type ChatConversationCreateNestedManyWithoutPatientInput = {
    create?: XOR<ChatConversationCreateWithoutPatientInput, ChatConversationUncheckedCreateWithoutPatientInput> | ChatConversationCreateWithoutPatientInput[] | ChatConversationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ChatConversationCreateOrConnectWithoutPatientInput | ChatConversationCreateOrConnectWithoutPatientInput[]
    createMany?: ChatConversationCreateManyPatientInputEnvelope
    connect?: ChatConversationWhereUniqueInput | ChatConversationWhereUniqueInput[]
  }

  export type ExamCreateNestedManyWithoutPatientInput = {
    create?: XOR<ExamCreateWithoutPatientInput, ExamUncheckedCreateWithoutPatientInput> | ExamCreateWithoutPatientInput[] | ExamUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutPatientInput | ExamCreateOrConnectWithoutPatientInput[]
    createMany?: ExamCreateManyPatientInputEnvelope
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
  }

  export type PatientTrainingProgressCreateNestedManyWithoutPatientInput = {
    create?: XOR<PatientTrainingProgressCreateWithoutPatientInput, PatientTrainingProgressUncheckedCreateWithoutPatientInput> | PatientTrainingProgressCreateWithoutPatientInput[] | PatientTrainingProgressUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PatientTrainingProgressCreateOrConnectWithoutPatientInput | PatientTrainingProgressCreateOrConnectWithoutPatientInput[]
    createMany?: PatientTrainingProgressCreateManyPatientInputEnvelope
    connect?: PatientTrainingProgressWhereUniqueInput | PatientTrainingProgressWhereUniqueInput[]
  }

  export type PatientSessionCompletionCreateNestedManyWithoutPatientInput = {
    create?: XOR<PatientSessionCompletionCreateWithoutPatientInput, PatientSessionCompletionUncheckedCreateWithoutPatientInput> | PatientSessionCompletionCreateWithoutPatientInput[] | PatientSessionCompletionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PatientSessionCompletionCreateOrConnectWithoutPatientInput | PatientSessionCompletionCreateOrConnectWithoutPatientInput[]
    createMany?: PatientSessionCompletionCreateManyPatientInputEnvelope
    connect?: PatientSessionCompletionWhereUniqueInput | PatientSessionCompletionWhereUniqueInput[]
  }

  export type PatientContentAdjustmentUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<PatientContentAdjustmentCreateWithoutPatientInput, PatientContentAdjustmentUncheckedCreateWithoutPatientInput> | PatientContentAdjustmentCreateWithoutPatientInput[] | PatientContentAdjustmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PatientContentAdjustmentCreateOrConnectWithoutPatientInput | PatientContentAdjustmentCreateOrConnectWithoutPatientInput[]
    createMany?: PatientContentAdjustmentCreateManyPatientInputEnvelope
    connect?: PatientContentAdjustmentWhereUniqueInput | PatientContentAdjustmentWhereUniqueInput[]
  }

  export type AppointmentUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput> | AppointmentCreateWithoutPatientInput[] | AppointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPatientInput | AppointmentCreateOrConnectWithoutPatientInput[]
    createMany?: AppointmentCreateManyPatientInputEnvelope
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
  }

  export type MedicationLogUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<MedicationLogCreateWithoutPatientInput, MedicationLogUncheckedCreateWithoutPatientInput> | MedicationLogCreateWithoutPatientInput[] | MedicationLogUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: MedicationLogCreateOrConnectWithoutPatientInput | MedicationLogCreateOrConnectWithoutPatientInput[]
    createMany?: MedicationLogCreateManyPatientInputEnvelope
    connect?: MedicationLogWhereUniqueInput | MedicationLogWhereUniqueInput[]
  }

  export type ChatConversationUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<ChatConversationCreateWithoutPatientInput, ChatConversationUncheckedCreateWithoutPatientInput> | ChatConversationCreateWithoutPatientInput[] | ChatConversationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ChatConversationCreateOrConnectWithoutPatientInput | ChatConversationCreateOrConnectWithoutPatientInput[]
    createMany?: ChatConversationCreateManyPatientInputEnvelope
    connect?: ChatConversationWhereUniqueInput | ChatConversationWhereUniqueInput[]
  }

  export type ExamUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<ExamCreateWithoutPatientInput, ExamUncheckedCreateWithoutPatientInput> | ExamCreateWithoutPatientInput[] | ExamUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutPatientInput | ExamCreateOrConnectWithoutPatientInput[]
    createMany?: ExamCreateManyPatientInputEnvelope
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
  }

  export type PatientTrainingProgressUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<PatientTrainingProgressCreateWithoutPatientInput, PatientTrainingProgressUncheckedCreateWithoutPatientInput> | PatientTrainingProgressCreateWithoutPatientInput[] | PatientTrainingProgressUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PatientTrainingProgressCreateOrConnectWithoutPatientInput | PatientTrainingProgressCreateOrConnectWithoutPatientInput[]
    createMany?: PatientTrainingProgressCreateManyPatientInputEnvelope
    connect?: PatientTrainingProgressWhereUniqueInput | PatientTrainingProgressWhereUniqueInput[]
  }

  export type PatientSessionCompletionUncheckedCreateNestedManyWithoutPatientInput = {
    create?: XOR<PatientSessionCompletionCreateWithoutPatientInput, PatientSessionCompletionUncheckedCreateWithoutPatientInput> | PatientSessionCompletionCreateWithoutPatientInput[] | PatientSessionCompletionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PatientSessionCompletionCreateOrConnectWithoutPatientInput | PatientSessionCompletionCreateOrConnectWithoutPatientInput[]
    createMany?: PatientSessionCompletionCreateManyPatientInputEnvelope
    connect?: PatientSessionCompletionWhereUniqueInput | PatientSessionCompletionWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type UserUpdateOneRequiredWithoutPatientNestedInput = {
    create?: XOR<UserCreateWithoutPatientInput, UserUncheckedCreateWithoutPatientInput>
    connectOrCreate?: UserCreateOrConnectWithoutPatientInput
    upsert?: UserUpsertWithoutPatientInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPatientInput, UserUpdateWithoutPatientInput>, UserUncheckedUpdateWithoutPatientInput>
  }

  export type ClinicUpdateOneRequiredWithoutPatientsNestedInput = {
    create?: XOR<ClinicCreateWithoutPatientsInput, ClinicUncheckedCreateWithoutPatientsInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutPatientsInput
    upsert?: ClinicUpsertWithoutPatientsInput
    connect?: ClinicWhereUniqueInput
    update?: XOR<XOR<ClinicUpdateToOneWithWhereWithoutPatientsInput, ClinicUpdateWithoutPatientsInput>, ClinicUncheckedUpdateWithoutPatientsInput>
  }

  export type PatientContentAdjustmentUpdateManyWithoutPatientNestedInput = {
    create?: XOR<PatientContentAdjustmentCreateWithoutPatientInput, PatientContentAdjustmentUncheckedCreateWithoutPatientInput> | PatientContentAdjustmentCreateWithoutPatientInput[] | PatientContentAdjustmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PatientContentAdjustmentCreateOrConnectWithoutPatientInput | PatientContentAdjustmentCreateOrConnectWithoutPatientInput[]
    upsert?: PatientContentAdjustmentUpsertWithWhereUniqueWithoutPatientInput | PatientContentAdjustmentUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: PatientContentAdjustmentCreateManyPatientInputEnvelope
    set?: PatientContentAdjustmentWhereUniqueInput | PatientContentAdjustmentWhereUniqueInput[]
    disconnect?: PatientContentAdjustmentWhereUniqueInput | PatientContentAdjustmentWhereUniqueInput[]
    delete?: PatientContentAdjustmentWhereUniqueInput | PatientContentAdjustmentWhereUniqueInput[]
    connect?: PatientContentAdjustmentWhereUniqueInput | PatientContentAdjustmentWhereUniqueInput[]
    update?: PatientContentAdjustmentUpdateWithWhereUniqueWithoutPatientInput | PatientContentAdjustmentUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: PatientContentAdjustmentUpdateManyWithWhereWithoutPatientInput | PatientContentAdjustmentUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: PatientContentAdjustmentScalarWhereInput | PatientContentAdjustmentScalarWhereInput[]
  }

  export type AppointmentUpdateManyWithoutPatientNestedInput = {
    create?: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput> | AppointmentCreateWithoutPatientInput[] | AppointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPatientInput | AppointmentCreateOrConnectWithoutPatientInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutPatientInput | AppointmentUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: AppointmentCreateManyPatientInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutPatientInput | AppointmentUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutPatientInput | AppointmentUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type MedicationLogUpdateManyWithoutPatientNestedInput = {
    create?: XOR<MedicationLogCreateWithoutPatientInput, MedicationLogUncheckedCreateWithoutPatientInput> | MedicationLogCreateWithoutPatientInput[] | MedicationLogUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: MedicationLogCreateOrConnectWithoutPatientInput | MedicationLogCreateOrConnectWithoutPatientInput[]
    upsert?: MedicationLogUpsertWithWhereUniqueWithoutPatientInput | MedicationLogUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: MedicationLogCreateManyPatientInputEnvelope
    set?: MedicationLogWhereUniqueInput | MedicationLogWhereUniqueInput[]
    disconnect?: MedicationLogWhereUniqueInput | MedicationLogWhereUniqueInput[]
    delete?: MedicationLogWhereUniqueInput | MedicationLogWhereUniqueInput[]
    connect?: MedicationLogWhereUniqueInput | MedicationLogWhereUniqueInput[]
    update?: MedicationLogUpdateWithWhereUniqueWithoutPatientInput | MedicationLogUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: MedicationLogUpdateManyWithWhereWithoutPatientInput | MedicationLogUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: MedicationLogScalarWhereInput | MedicationLogScalarWhereInput[]
  }

  export type ChatConversationUpdateManyWithoutPatientNestedInput = {
    create?: XOR<ChatConversationCreateWithoutPatientInput, ChatConversationUncheckedCreateWithoutPatientInput> | ChatConversationCreateWithoutPatientInput[] | ChatConversationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ChatConversationCreateOrConnectWithoutPatientInput | ChatConversationCreateOrConnectWithoutPatientInput[]
    upsert?: ChatConversationUpsertWithWhereUniqueWithoutPatientInput | ChatConversationUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: ChatConversationCreateManyPatientInputEnvelope
    set?: ChatConversationWhereUniqueInput | ChatConversationWhereUniqueInput[]
    disconnect?: ChatConversationWhereUniqueInput | ChatConversationWhereUniqueInput[]
    delete?: ChatConversationWhereUniqueInput | ChatConversationWhereUniqueInput[]
    connect?: ChatConversationWhereUniqueInput | ChatConversationWhereUniqueInput[]
    update?: ChatConversationUpdateWithWhereUniqueWithoutPatientInput | ChatConversationUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: ChatConversationUpdateManyWithWhereWithoutPatientInput | ChatConversationUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: ChatConversationScalarWhereInput | ChatConversationScalarWhereInput[]
  }

  export type ExamUpdateManyWithoutPatientNestedInput = {
    create?: XOR<ExamCreateWithoutPatientInput, ExamUncheckedCreateWithoutPatientInput> | ExamCreateWithoutPatientInput[] | ExamUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutPatientInput | ExamCreateOrConnectWithoutPatientInput[]
    upsert?: ExamUpsertWithWhereUniqueWithoutPatientInput | ExamUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: ExamCreateManyPatientInputEnvelope
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    update?: ExamUpdateWithWhereUniqueWithoutPatientInput | ExamUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: ExamUpdateManyWithWhereWithoutPatientInput | ExamUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[]
  }

  export type PatientTrainingProgressUpdateManyWithoutPatientNestedInput = {
    create?: XOR<PatientTrainingProgressCreateWithoutPatientInput, PatientTrainingProgressUncheckedCreateWithoutPatientInput> | PatientTrainingProgressCreateWithoutPatientInput[] | PatientTrainingProgressUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PatientTrainingProgressCreateOrConnectWithoutPatientInput | PatientTrainingProgressCreateOrConnectWithoutPatientInput[]
    upsert?: PatientTrainingProgressUpsertWithWhereUniqueWithoutPatientInput | PatientTrainingProgressUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: PatientTrainingProgressCreateManyPatientInputEnvelope
    set?: PatientTrainingProgressWhereUniqueInput | PatientTrainingProgressWhereUniqueInput[]
    disconnect?: PatientTrainingProgressWhereUniqueInput | PatientTrainingProgressWhereUniqueInput[]
    delete?: PatientTrainingProgressWhereUniqueInput | PatientTrainingProgressWhereUniqueInput[]
    connect?: PatientTrainingProgressWhereUniqueInput | PatientTrainingProgressWhereUniqueInput[]
    update?: PatientTrainingProgressUpdateWithWhereUniqueWithoutPatientInput | PatientTrainingProgressUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: PatientTrainingProgressUpdateManyWithWhereWithoutPatientInput | PatientTrainingProgressUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: PatientTrainingProgressScalarWhereInput | PatientTrainingProgressScalarWhereInput[]
  }

  export type PatientSessionCompletionUpdateManyWithoutPatientNestedInput = {
    create?: XOR<PatientSessionCompletionCreateWithoutPatientInput, PatientSessionCompletionUncheckedCreateWithoutPatientInput> | PatientSessionCompletionCreateWithoutPatientInput[] | PatientSessionCompletionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PatientSessionCompletionCreateOrConnectWithoutPatientInput | PatientSessionCompletionCreateOrConnectWithoutPatientInput[]
    upsert?: PatientSessionCompletionUpsertWithWhereUniqueWithoutPatientInput | PatientSessionCompletionUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: PatientSessionCompletionCreateManyPatientInputEnvelope
    set?: PatientSessionCompletionWhereUniqueInput | PatientSessionCompletionWhereUniqueInput[]
    disconnect?: PatientSessionCompletionWhereUniqueInput | PatientSessionCompletionWhereUniqueInput[]
    delete?: PatientSessionCompletionWhereUniqueInput | PatientSessionCompletionWhereUniqueInput[]
    connect?: PatientSessionCompletionWhereUniqueInput | PatientSessionCompletionWhereUniqueInput[]
    update?: PatientSessionCompletionUpdateWithWhereUniqueWithoutPatientInput | PatientSessionCompletionUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: PatientSessionCompletionUpdateManyWithWhereWithoutPatientInput | PatientSessionCompletionUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: PatientSessionCompletionScalarWhereInput | PatientSessionCompletionScalarWhereInput[]
  }

  export type PatientContentAdjustmentUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<PatientContentAdjustmentCreateWithoutPatientInput, PatientContentAdjustmentUncheckedCreateWithoutPatientInput> | PatientContentAdjustmentCreateWithoutPatientInput[] | PatientContentAdjustmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PatientContentAdjustmentCreateOrConnectWithoutPatientInput | PatientContentAdjustmentCreateOrConnectWithoutPatientInput[]
    upsert?: PatientContentAdjustmentUpsertWithWhereUniqueWithoutPatientInput | PatientContentAdjustmentUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: PatientContentAdjustmentCreateManyPatientInputEnvelope
    set?: PatientContentAdjustmentWhereUniqueInput | PatientContentAdjustmentWhereUniqueInput[]
    disconnect?: PatientContentAdjustmentWhereUniqueInput | PatientContentAdjustmentWhereUniqueInput[]
    delete?: PatientContentAdjustmentWhereUniqueInput | PatientContentAdjustmentWhereUniqueInput[]
    connect?: PatientContentAdjustmentWhereUniqueInput | PatientContentAdjustmentWhereUniqueInput[]
    update?: PatientContentAdjustmentUpdateWithWhereUniqueWithoutPatientInput | PatientContentAdjustmentUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: PatientContentAdjustmentUpdateManyWithWhereWithoutPatientInput | PatientContentAdjustmentUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: PatientContentAdjustmentScalarWhereInput | PatientContentAdjustmentScalarWhereInput[]
  }

  export type AppointmentUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput> | AppointmentCreateWithoutPatientInput[] | AppointmentUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: AppointmentCreateOrConnectWithoutPatientInput | AppointmentCreateOrConnectWithoutPatientInput[]
    upsert?: AppointmentUpsertWithWhereUniqueWithoutPatientInput | AppointmentUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: AppointmentCreateManyPatientInputEnvelope
    set?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    disconnect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    delete?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    connect?: AppointmentWhereUniqueInput | AppointmentWhereUniqueInput[]
    update?: AppointmentUpdateWithWhereUniqueWithoutPatientInput | AppointmentUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: AppointmentUpdateManyWithWhereWithoutPatientInput | AppointmentUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
  }

  export type MedicationLogUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<MedicationLogCreateWithoutPatientInput, MedicationLogUncheckedCreateWithoutPatientInput> | MedicationLogCreateWithoutPatientInput[] | MedicationLogUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: MedicationLogCreateOrConnectWithoutPatientInput | MedicationLogCreateOrConnectWithoutPatientInput[]
    upsert?: MedicationLogUpsertWithWhereUniqueWithoutPatientInput | MedicationLogUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: MedicationLogCreateManyPatientInputEnvelope
    set?: MedicationLogWhereUniqueInput | MedicationLogWhereUniqueInput[]
    disconnect?: MedicationLogWhereUniqueInput | MedicationLogWhereUniqueInput[]
    delete?: MedicationLogWhereUniqueInput | MedicationLogWhereUniqueInput[]
    connect?: MedicationLogWhereUniqueInput | MedicationLogWhereUniqueInput[]
    update?: MedicationLogUpdateWithWhereUniqueWithoutPatientInput | MedicationLogUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: MedicationLogUpdateManyWithWhereWithoutPatientInput | MedicationLogUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: MedicationLogScalarWhereInput | MedicationLogScalarWhereInput[]
  }

  export type ChatConversationUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<ChatConversationCreateWithoutPatientInput, ChatConversationUncheckedCreateWithoutPatientInput> | ChatConversationCreateWithoutPatientInput[] | ChatConversationUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ChatConversationCreateOrConnectWithoutPatientInput | ChatConversationCreateOrConnectWithoutPatientInput[]
    upsert?: ChatConversationUpsertWithWhereUniqueWithoutPatientInput | ChatConversationUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: ChatConversationCreateManyPatientInputEnvelope
    set?: ChatConversationWhereUniqueInput | ChatConversationWhereUniqueInput[]
    disconnect?: ChatConversationWhereUniqueInput | ChatConversationWhereUniqueInput[]
    delete?: ChatConversationWhereUniqueInput | ChatConversationWhereUniqueInput[]
    connect?: ChatConversationWhereUniqueInput | ChatConversationWhereUniqueInput[]
    update?: ChatConversationUpdateWithWhereUniqueWithoutPatientInput | ChatConversationUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: ChatConversationUpdateManyWithWhereWithoutPatientInput | ChatConversationUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: ChatConversationScalarWhereInput | ChatConversationScalarWhereInput[]
  }

  export type ExamUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<ExamCreateWithoutPatientInput, ExamUncheckedCreateWithoutPatientInput> | ExamCreateWithoutPatientInput[] | ExamUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: ExamCreateOrConnectWithoutPatientInput | ExamCreateOrConnectWithoutPatientInput[]
    upsert?: ExamUpsertWithWhereUniqueWithoutPatientInput | ExamUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: ExamCreateManyPatientInputEnvelope
    set?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    disconnect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    delete?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    connect?: ExamWhereUniqueInput | ExamWhereUniqueInput[]
    update?: ExamUpdateWithWhereUniqueWithoutPatientInput | ExamUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: ExamUpdateManyWithWhereWithoutPatientInput | ExamUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: ExamScalarWhereInput | ExamScalarWhereInput[]
  }

  export type PatientTrainingProgressUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<PatientTrainingProgressCreateWithoutPatientInput, PatientTrainingProgressUncheckedCreateWithoutPatientInput> | PatientTrainingProgressCreateWithoutPatientInput[] | PatientTrainingProgressUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PatientTrainingProgressCreateOrConnectWithoutPatientInput | PatientTrainingProgressCreateOrConnectWithoutPatientInput[]
    upsert?: PatientTrainingProgressUpsertWithWhereUniqueWithoutPatientInput | PatientTrainingProgressUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: PatientTrainingProgressCreateManyPatientInputEnvelope
    set?: PatientTrainingProgressWhereUniqueInput | PatientTrainingProgressWhereUniqueInput[]
    disconnect?: PatientTrainingProgressWhereUniqueInput | PatientTrainingProgressWhereUniqueInput[]
    delete?: PatientTrainingProgressWhereUniqueInput | PatientTrainingProgressWhereUniqueInput[]
    connect?: PatientTrainingProgressWhereUniqueInput | PatientTrainingProgressWhereUniqueInput[]
    update?: PatientTrainingProgressUpdateWithWhereUniqueWithoutPatientInput | PatientTrainingProgressUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: PatientTrainingProgressUpdateManyWithWhereWithoutPatientInput | PatientTrainingProgressUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: PatientTrainingProgressScalarWhereInput | PatientTrainingProgressScalarWhereInput[]
  }

  export type PatientSessionCompletionUncheckedUpdateManyWithoutPatientNestedInput = {
    create?: XOR<PatientSessionCompletionCreateWithoutPatientInput, PatientSessionCompletionUncheckedCreateWithoutPatientInput> | PatientSessionCompletionCreateWithoutPatientInput[] | PatientSessionCompletionUncheckedCreateWithoutPatientInput[]
    connectOrCreate?: PatientSessionCompletionCreateOrConnectWithoutPatientInput | PatientSessionCompletionCreateOrConnectWithoutPatientInput[]
    upsert?: PatientSessionCompletionUpsertWithWhereUniqueWithoutPatientInput | PatientSessionCompletionUpsertWithWhereUniqueWithoutPatientInput[]
    createMany?: PatientSessionCompletionCreateManyPatientInputEnvelope
    set?: PatientSessionCompletionWhereUniqueInput | PatientSessionCompletionWhereUniqueInput[]
    disconnect?: PatientSessionCompletionWhereUniqueInput | PatientSessionCompletionWhereUniqueInput[]
    delete?: PatientSessionCompletionWhereUniqueInput | PatientSessionCompletionWhereUniqueInput[]
    connect?: PatientSessionCompletionWhereUniqueInput | PatientSessionCompletionWhereUniqueInput[]
    update?: PatientSessionCompletionUpdateWithWhereUniqueWithoutPatientInput | PatientSessionCompletionUpdateWithWhereUniqueWithoutPatientInput[]
    updateMany?: PatientSessionCompletionUpdateManyWithWhereWithoutPatientInput | PatientSessionCompletionUpdateManyWithWhereWithoutPatientInput[]
    deleteMany?: PatientSessionCompletionScalarWhereInput | PatientSessionCompletionScalarWhereInput[]
  }

  export type PatientCreateNestedOneWithoutAppointmentsInput = {
    create?: XOR<PatientCreateWithoutAppointmentsInput, PatientUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutAppointmentsInput
    connect?: PatientWhereUniqueInput
  }

  export type EnumAppointmentTypeFieldUpdateOperationsInput = {
    set?: $Enums.AppointmentType
  }

  export type EnumAppointmentStatusFieldUpdateOperationsInput = {
    set?: $Enums.AppointmentStatus
  }

  export type PatientUpdateOneRequiredWithoutAppointmentsNestedInput = {
    create?: XOR<PatientCreateWithoutAppointmentsInput, PatientUncheckedCreateWithoutAppointmentsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutAppointmentsInput
    upsert?: PatientUpsertWithoutAppointmentsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutAppointmentsInput, PatientUpdateWithoutAppointmentsInput>, PatientUncheckedUpdateWithoutAppointmentsInput>
  }

  export type PatientCreateNestedOneWithoutMedicationLogsInput = {
    create?: XOR<PatientCreateWithoutMedicationLogsInput, PatientUncheckedCreateWithoutMedicationLogsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutMedicationLogsInput
    connect?: PatientWhereUniqueInput
  }

  export type PatientUpdateOneRequiredWithoutMedicationLogsNestedInput = {
    create?: XOR<PatientCreateWithoutMedicationLogsInput, PatientUncheckedCreateWithoutMedicationLogsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutMedicationLogsInput
    upsert?: PatientUpsertWithoutMedicationLogsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutMedicationLogsInput, PatientUpdateWithoutMedicationLogsInput>, PatientUncheckedUpdateWithoutMedicationLogsInput>
  }

  export type PatientCreateNestedOneWithoutExamsInput = {
    create?: XOR<PatientCreateWithoutExamsInput, PatientUncheckedCreateWithoutExamsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutExamsInput
    connect?: PatientWhereUniqueInput
  }

  export type EnumExamStatusFieldUpdateOperationsInput = {
    set?: $Enums.ExamStatus
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PatientUpdateOneRequiredWithoutExamsNestedInput = {
    create?: XOR<PatientCreateWithoutExamsInput, PatientUncheckedCreateWithoutExamsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutExamsInput
    upsert?: PatientUpsertWithoutExamsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutExamsInput, PatientUpdateWithoutExamsInput>, PatientUncheckedUpdateWithoutExamsInput>
  }

  export type EnumContentTypeFieldUpdateOperationsInput = {
    set?: $Enums.ContentType
  }

  export type EnumContentCategoryFieldUpdateOperationsInput = {
    set?: $Enums.ContentCategory
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ClinicCreateNestedOneWithoutContentsInput = {
    create?: XOR<ClinicCreateWithoutContentsInput, ClinicUncheckedCreateWithoutContentsInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutContentsInput
    connect?: ClinicWhereUniqueInput
  }

  export type PatientContentAdjustmentCreateNestedManyWithoutBaseContentInput = {
    create?: XOR<PatientContentAdjustmentCreateWithoutBaseContentInput, PatientContentAdjustmentUncheckedCreateWithoutBaseContentInput> | PatientContentAdjustmentCreateWithoutBaseContentInput[] | PatientContentAdjustmentUncheckedCreateWithoutBaseContentInput[]
    connectOrCreate?: PatientContentAdjustmentCreateOrConnectWithoutBaseContentInput | PatientContentAdjustmentCreateOrConnectWithoutBaseContentInput[]
    createMany?: PatientContentAdjustmentCreateManyBaseContentInputEnvelope
    connect?: PatientContentAdjustmentWhereUniqueInput | PatientContentAdjustmentWhereUniqueInput[]
  }

  export type PatientContentAdjustmentUncheckedCreateNestedManyWithoutBaseContentInput = {
    create?: XOR<PatientContentAdjustmentCreateWithoutBaseContentInput, PatientContentAdjustmentUncheckedCreateWithoutBaseContentInput> | PatientContentAdjustmentCreateWithoutBaseContentInput[] | PatientContentAdjustmentUncheckedCreateWithoutBaseContentInput[]
    connectOrCreate?: PatientContentAdjustmentCreateOrConnectWithoutBaseContentInput | PatientContentAdjustmentCreateOrConnectWithoutBaseContentInput[]
    createMany?: PatientContentAdjustmentCreateManyBaseContentInputEnvelope
    connect?: PatientContentAdjustmentWhereUniqueInput | PatientContentAdjustmentWhereUniqueInput[]
  }

  export type ClinicUpdateOneRequiredWithoutContentsNestedInput = {
    create?: XOR<ClinicCreateWithoutContentsInput, ClinicUncheckedCreateWithoutContentsInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutContentsInput
    upsert?: ClinicUpsertWithoutContentsInput
    connect?: ClinicWhereUniqueInput
    update?: XOR<XOR<ClinicUpdateToOneWithWhereWithoutContentsInput, ClinicUpdateWithoutContentsInput>, ClinicUncheckedUpdateWithoutContentsInput>
  }

  export type PatientContentAdjustmentUpdateManyWithoutBaseContentNestedInput = {
    create?: XOR<PatientContentAdjustmentCreateWithoutBaseContentInput, PatientContentAdjustmentUncheckedCreateWithoutBaseContentInput> | PatientContentAdjustmentCreateWithoutBaseContentInput[] | PatientContentAdjustmentUncheckedCreateWithoutBaseContentInput[]
    connectOrCreate?: PatientContentAdjustmentCreateOrConnectWithoutBaseContentInput | PatientContentAdjustmentCreateOrConnectWithoutBaseContentInput[]
    upsert?: PatientContentAdjustmentUpsertWithWhereUniqueWithoutBaseContentInput | PatientContentAdjustmentUpsertWithWhereUniqueWithoutBaseContentInput[]
    createMany?: PatientContentAdjustmentCreateManyBaseContentInputEnvelope
    set?: PatientContentAdjustmentWhereUniqueInput | PatientContentAdjustmentWhereUniqueInput[]
    disconnect?: PatientContentAdjustmentWhereUniqueInput | PatientContentAdjustmentWhereUniqueInput[]
    delete?: PatientContentAdjustmentWhereUniqueInput | PatientContentAdjustmentWhereUniqueInput[]
    connect?: PatientContentAdjustmentWhereUniqueInput | PatientContentAdjustmentWhereUniqueInput[]
    update?: PatientContentAdjustmentUpdateWithWhereUniqueWithoutBaseContentInput | PatientContentAdjustmentUpdateWithWhereUniqueWithoutBaseContentInput[]
    updateMany?: PatientContentAdjustmentUpdateManyWithWhereWithoutBaseContentInput | PatientContentAdjustmentUpdateManyWithWhereWithoutBaseContentInput[]
    deleteMany?: PatientContentAdjustmentScalarWhereInput | PatientContentAdjustmentScalarWhereInput[]
  }

  export type PatientContentAdjustmentUncheckedUpdateManyWithoutBaseContentNestedInput = {
    create?: XOR<PatientContentAdjustmentCreateWithoutBaseContentInput, PatientContentAdjustmentUncheckedCreateWithoutBaseContentInput> | PatientContentAdjustmentCreateWithoutBaseContentInput[] | PatientContentAdjustmentUncheckedCreateWithoutBaseContentInput[]
    connectOrCreate?: PatientContentAdjustmentCreateOrConnectWithoutBaseContentInput | PatientContentAdjustmentCreateOrConnectWithoutBaseContentInput[]
    upsert?: PatientContentAdjustmentUpsertWithWhereUniqueWithoutBaseContentInput | PatientContentAdjustmentUpsertWithWhereUniqueWithoutBaseContentInput[]
    createMany?: PatientContentAdjustmentCreateManyBaseContentInputEnvelope
    set?: PatientContentAdjustmentWhereUniqueInput | PatientContentAdjustmentWhereUniqueInput[]
    disconnect?: PatientContentAdjustmentWhereUniqueInput | PatientContentAdjustmentWhereUniqueInput[]
    delete?: PatientContentAdjustmentWhereUniqueInput | PatientContentAdjustmentWhereUniqueInput[]
    connect?: PatientContentAdjustmentWhereUniqueInput | PatientContentAdjustmentWhereUniqueInput[]
    update?: PatientContentAdjustmentUpdateWithWhereUniqueWithoutBaseContentInput | PatientContentAdjustmentUpdateWithWhereUniqueWithoutBaseContentInput[]
    updateMany?: PatientContentAdjustmentUpdateManyWithWhereWithoutBaseContentInput | PatientContentAdjustmentUpdateManyWithWhereWithoutBaseContentInput[]
    deleteMany?: PatientContentAdjustmentScalarWhereInput | PatientContentAdjustmentScalarWhereInput[]
  }

  export type PatientCreateNestedOneWithoutContentAdjustmentsInput = {
    create?: XOR<PatientCreateWithoutContentAdjustmentsInput, PatientUncheckedCreateWithoutContentAdjustmentsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutContentAdjustmentsInput
    connect?: PatientWhereUniqueInput
  }

  export type ClinicContentCreateNestedOneWithoutPatientAdjustmentsInput = {
    create?: XOR<ClinicContentCreateWithoutPatientAdjustmentsInput, ClinicContentUncheckedCreateWithoutPatientAdjustmentsInput>
    connectOrCreate?: ClinicContentCreateOrConnectWithoutPatientAdjustmentsInput
    connect?: ClinicContentWhereUniqueInput
  }

  export type EnumAdjustmentTypeFieldUpdateOperationsInput = {
    set?: $Enums.AdjustmentType
  }

  export type NullableEnumContentTypeFieldUpdateOperationsInput = {
    set?: $Enums.ContentType | null
  }

  export type NullableEnumContentCategoryFieldUpdateOperationsInput = {
    set?: $Enums.ContentCategory | null
  }

  export type PatientUpdateOneRequiredWithoutContentAdjustmentsNestedInput = {
    create?: XOR<PatientCreateWithoutContentAdjustmentsInput, PatientUncheckedCreateWithoutContentAdjustmentsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutContentAdjustmentsInput
    upsert?: PatientUpsertWithoutContentAdjustmentsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutContentAdjustmentsInput, PatientUpdateWithoutContentAdjustmentsInput>, PatientUncheckedUpdateWithoutContentAdjustmentsInput>
  }

  export type ClinicContentUpdateOneWithoutPatientAdjustmentsNestedInput = {
    create?: XOR<ClinicContentCreateWithoutPatientAdjustmentsInput, ClinicContentUncheckedCreateWithoutPatientAdjustmentsInput>
    connectOrCreate?: ClinicContentCreateOrConnectWithoutPatientAdjustmentsInput
    upsert?: ClinicContentUpsertWithoutPatientAdjustmentsInput
    disconnect?: ClinicContentWhereInput | boolean
    delete?: ClinicContentWhereInput | boolean
    connect?: ClinicContentWhereUniqueInput
    update?: XOR<XOR<ClinicContentUpdateToOneWithWhereWithoutPatientAdjustmentsInput, ClinicContentUpdateWithoutPatientAdjustmentsInput>, ClinicContentUncheckedUpdateWithoutPatientAdjustmentsInput>
  }

  export type ClinicCreateNestedOneWithoutTrainingProtocolsInput = {
    create?: XOR<ClinicCreateWithoutTrainingProtocolsInput, ClinicUncheckedCreateWithoutTrainingProtocolsInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutTrainingProtocolsInput
    connect?: ClinicWhereUniqueInput
  }

  export type TrainingWeekCreateNestedManyWithoutProtocolInput = {
    create?: XOR<TrainingWeekCreateWithoutProtocolInput, TrainingWeekUncheckedCreateWithoutProtocolInput> | TrainingWeekCreateWithoutProtocolInput[] | TrainingWeekUncheckedCreateWithoutProtocolInput[]
    connectOrCreate?: TrainingWeekCreateOrConnectWithoutProtocolInput | TrainingWeekCreateOrConnectWithoutProtocolInput[]
    createMany?: TrainingWeekCreateManyProtocolInputEnvelope
    connect?: TrainingWeekWhereUniqueInput | TrainingWeekWhereUniqueInput[]
  }

  export type TrainingWeekUncheckedCreateNestedManyWithoutProtocolInput = {
    create?: XOR<TrainingWeekCreateWithoutProtocolInput, TrainingWeekUncheckedCreateWithoutProtocolInput> | TrainingWeekCreateWithoutProtocolInput[] | TrainingWeekUncheckedCreateWithoutProtocolInput[]
    connectOrCreate?: TrainingWeekCreateOrConnectWithoutProtocolInput | TrainingWeekCreateOrConnectWithoutProtocolInput[]
    createMany?: TrainingWeekCreateManyProtocolInputEnvelope
    connect?: TrainingWeekWhereUniqueInput | TrainingWeekWhereUniqueInput[]
  }

  export type ClinicUpdateOneWithoutTrainingProtocolsNestedInput = {
    create?: XOR<ClinicCreateWithoutTrainingProtocolsInput, ClinicUncheckedCreateWithoutTrainingProtocolsInput>
    connectOrCreate?: ClinicCreateOrConnectWithoutTrainingProtocolsInput
    upsert?: ClinicUpsertWithoutTrainingProtocolsInput
    disconnect?: ClinicWhereInput | boolean
    delete?: ClinicWhereInput | boolean
    connect?: ClinicWhereUniqueInput
    update?: XOR<XOR<ClinicUpdateToOneWithWhereWithoutTrainingProtocolsInput, ClinicUpdateWithoutTrainingProtocolsInput>, ClinicUncheckedUpdateWithoutTrainingProtocolsInput>
  }

  export type TrainingWeekUpdateManyWithoutProtocolNestedInput = {
    create?: XOR<TrainingWeekCreateWithoutProtocolInput, TrainingWeekUncheckedCreateWithoutProtocolInput> | TrainingWeekCreateWithoutProtocolInput[] | TrainingWeekUncheckedCreateWithoutProtocolInput[]
    connectOrCreate?: TrainingWeekCreateOrConnectWithoutProtocolInput | TrainingWeekCreateOrConnectWithoutProtocolInput[]
    upsert?: TrainingWeekUpsertWithWhereUniqueWithoutProtocolInput | TrainingWeekUpsertWithWhereUniqueWithoutProtocolInput[]
    createMany?: TrainingWeekCreateManyProtocolInputEnvelope
    set?: TrainingWeekWhereUniqueInput | TrainingWeekWhereUniqueInput[]
    disconnect?: TrainingWeekWhereUniqueInput | TrainingWeekWhereUniqueInput[]
    delete?: TrainingWeekWhereUniqueInput | TrainingWeekWhereUniqueInput[]
    connect?: TrainingWeekWhereUniqueInput | TrainingWeekWhereUniqueInput[]
    update?: TrainingWeekUpdateWithWhereUniqueWithoutProtocolInput | TrainingWeekUpdateWithWhereUniqueWithoutProtocolInput[]
    updateMany?: TrainingWeekUpdateManyWithWhereWithoutProtocolInput | TrainingWeekUpdateManyWithWhereWithoutProtocolInput[]
    deleteMany?: TrainingWeekScalarWhereInput | TrainingWeekScalarWhereInput[]
  }

  export type TrainingWeekUncheckedUpdateManyWithoutProtocolNestedInput = {
    create?: XOR<TrainingWeekCreateWithoutProtocolInput, TrainingWeekUncheckedCreateWithoutProtocolInput> | TrainingWeekCreateWithoutProtocolInput[] | TrainingWeekUncheckedCreateWithoutProtocolInput[]
    connectOrCreate?: TrainingWeekCreateOrConnectWithoutProtocolInput | TrainingWeekCreateOrConnectWithoutProtocolInput[]
    upsert?: TrainingWeekUpsertWithWhereUniqueWithoutProtocolInput | TrainingWeekUpsertWithWhereUniqueWithoutProtocolInput[]
    createMany?: TrainingWeekCreateManyProtocolInputEnvelope
    set?: TrainingWeekWhereUniqueInput | TrainingWeekWhereUniqueInput[]
    disconnect?: TrainingWeekWhereUniqueInput | TrainingWeekWhereUniqueInput[]
    delete?: TrainingWeekWhereUniqueInput | TrainingWeekWhereUniqueInput[]
    connect?: TrainingWeekWhereUniqueInput | TrainingWeekWhereUniqueInput[]
    update?: TrainingWeekUpdateWithWhereUniqueWithoutProtocolInput | TrainingWeekUpdateWithWhereUniqueWithoutProtocolInput[]
    updateMany?: TrainingWeekUpdateManyWithWhereWithoutProtocolInput | TrainingWeekUpdateManyWithWhereWithoutProtocolInput[]
    deleteMany?: TrainingWeekScalarWhereInput | TrainingWeekScalarWhereInput[]
  }

  export type TrainingWeekCreatecanDoInput = {
    set: string[]
  }

  export type TrainingWeekCreateavoidInput = {
    set: string[]
  }

  export type TrainingProtocolCreateNestedOneWithoutWeeksInput = {
    create?: XOR<TrainingProtocolCreateWithoutWeeksInput, TrainingProtocolUncheckedCreateWithoutWeeksInput>
    connectOrCreate?: TrainingProtocolCreateOrConnectWithoutWeeksInput
    connect?: TrainingProtocolWhereUniqueInput
  }

  export type TrainingSessionCreateNestedManyWithoutWeekInput = {
    create?: XOR<TrainingSessionCreateWithoutWeekInput, TrainingSessionUncheckedCreateWithoutWeekInput> | TrainingSessionCreateWithoutWeekInput[] | TrainingSessionUncheckedCreateWithoutWeekInput[]
    connectOrCreate?: TrainingSessionCreateOrConnectWithoutWeekInput | TrainingSessionCreateOrConnectWithoutWeekInput[]
    createMany?: TrainingSessionCreateManyWeekInputEnvelope
    connect?: TrainingSessionWhereUniqueInput | TrainingSessionWhereUniqueInput[]
  }

  export type PatientTrainingProgressCreateNestedManyWithoutWeekInput = {
    create?: XOR<PatientTrainingProgressCreateWithoutWeekInput, PatientTrainingProgressUncheckedCreateWithoutWeekInput> | PatientTrainingProgressCreateWithoutWeekInput[] | PatientTrainingProgressUncheckedCreateWithoutWeekInput[]
    connectOrCreate?: PatientTrainingProgressCreateOrConnectWithoutWeekInput | PatientTrainingProgressCreateOrConnectWithoutWeekInput[]
    createMany?: PatientTrainingProgressCreateManyWeekInputEnvelope
    connect?: PatientTrainingProgressWhereUniqueInput | PatientTrainingProgressWhereUniqueInput[]
  }

  export type TrainingSessionUncheckedCreateNestedManyWithoutWeekInput = {
    create?: XOR<TrainingSessionCreateWithoutWeekInput, TrainingSessionUncheckedCreateWithoutWeekInput> | TrainingSessionCreateWithoutWeekInput[] | TrainingSessionUncheckedCreateWithoutWeekInput[]
    connectOrCreate?: TrainingSessionCreateOrConnectWithoutWeekInput | TrainingSessionCreateOrConnectWithoutWeekInput[]
    createMany?: TrainingSessionCreateManyWeekInputEnvelope
    connect?: TrainingSessionWhereUniqueInput | TrainingSessionWhereUniqueInput[]
  }

  export type PatientTrainingProgressUncheckedCreateNestedManyWithoutWeekInput = {
    create?: XOR<PatientTrainingProgressCreateWithoutWeekInput, PatientTrainingProgressUncheckedCreateWithoutWeekInput> | PatientTrainingProgressCreateWithoutWeekInput[] | PatientTrainingProgressUncheckedCreateWithoutWeekInput[]
    connectOrCreate?: PatientTrainingProgressCreateOrConnectWithoutWeekInput | PatientTrainingProgressCreateOrConnectWithoutWeekInput[]
    createMany?: PatientTrainingProgressCreateManyWeekInputEnvelope
    connect?: PatientTrainingProgressWhereUniqueInput | PatientTrainingProgressWhereUniqueInput[]
  }

  export type TrainingWeekUpdatecanDoInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TrainingWeekUpdateavoidInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TrainingProtocolUpdateOneRequiredWithoutWeeksNestedInput = {
    create?: XOR<TrainingProtocolCreateWithoutWeeksInput, TrainingProtocolUncheckedCreateWithoutWeeksInput>
    connectOrCreate?: TrainingProtocolCreateOrConnectWithoutWeeksInput
    upsert?: TrainingProtocolUpsertWithoutWeeksInput
    connect?: TrainingProtocolWhereUniqueInput
    update?: XOR<XOR<TrainingProtocolUpdateToOneWithWhereWithoutWeeksInput, TrainingProtocolUpdateWithoutWeeksInput>, TrainingProtocolUncheckedUpdateWithoutWeeksInput>
  }

  export type TrainingSessionUpdateManyWithoutWeekNestedInput = {
    create?: XOR<TrainingSessionCreateWithoutWeekInput, TrainingSessionUncheckedCreateWithoutWeekInput> | TrainingSessionCreateWithoutWeekInput[] | TrainingSessionUncheckedCreateWithoutWeekInput[]
    connectOrCreate?: TrainingSessionCreateOrConnectWithoutWeekInput | TrainingSessionCreateOrConnectWithoutWeekInput[]
    upsert?: TrainingSessionUpsertWithWhereUniqueWithoutWeekInput | TrainingSessionUpsertWithWhereUniqueWithoutWeekInput[]
    createMany?: TrainingSessionCreateManyWeekInputEnvelope
    set?: TrainingSessionWhereUniqueInput | TrainingSessionWhereUniqueInput[]
    disconnect?: TrainingSessionWhereUniqueInput | TrainingSessionWhereUniqueInput[]
    delete?: TrainingSessionWhereUniqueInput | TrainingSessionWhereUniqueInput[]
    connect?: TrainingSessionWhereUniqueInput | TrainingSessionWhereUniqueInput[]
    update?: TrainingSessionUpdateWithWhereUniqueWithoutWeekInput | TrainingSessionUpdateWithWhereUniqueWithoutWeekInput[]
    updateMany?: TrainingSessionUpdateManyWithWhereWithoutWeekInput | TrainingSessionUpdateManyWithWhereWithoutWeekInput[]
    deleteMany?: TrainingSessionScalarWhereInput | TrainingSessionScalarWhereInput[]
  }

  export type PatientTrainingProgressUpdateManyWithoutWeekNestedInput = {
    create?: XOR<PatientTrainingProgressCreateWithoutWeekInput, PatientTrainingProgressUncheckedCreateWithoutWeekInput> | PatientTrainingProgressCreateWithoutWeekInput[] | PatientTrainingProgressUncheckedCreateWithoutWeekInput[]
    connectOrCreate?: PatientTrainingProgressCreateOrConnectWithoutWeekInput | PatientTrainingProgressCreateOrConnectWithoutWeekInput[]
    upsert?: PatientTrainingProgressUpsertWithWhereUniqueWithoutWeekInput | PatientTrainingProgressUpsertWithWhereUniqueWithoutWeekInput[]
    createMany?: PatientTrainingProgressCreateManyWeekInputEnvelope
    set?: PatientTrainingProgressWhereUniqueInput | PatientTrainingProgressWhereUniqueInput[]
    disconnect?: PatientTrainingProgressWhereUniqueInput | PatientTrainingProgressWhereUniqueInput[]
    delete?: PatientTrainingProgressWhereUniqueInput | PatientTrainingProgressWhereUniqueInput[]
    connect?: PatientTrainingProgressWhereUniqueInput | PatientTrainingProgressWhereUniqueInput[]
    update?: PatientTrainingProgressUpdateWithWhereUniqueWithoutWeekInput | PatientTrainingProgressUpdateWithWhereUniqueWithoutWeekInput[]
    updateMany?: PatientTrainingProgressUpdateManyWithWhereWithoutWeekInput | PatientTrainingProgressUpdateManyWithWhereWithoutWeekInput[]
    deleteMany?: PatientTrainingProgressScalarWhereInput | PatientTrainingProgressScalarWhereInput[]
  }

  export type TrainingSessionUncheckedUpdateManyWithoutWeekNestedInput = {
    create?: XOR<TrainingSessionCreateWithoutWeekInput, TrainingSessionUncheckedCreateWithoutWeekInput> | TrainingSessionCreateWithoutWeekInput[] | TrainingSessionUncheckedCreateWithoutWeekInput[]
    connectOrCreate?: TrainingSessionCreateOrConnectWithoutWeekInput | TrainingSessionCreateOrConnectWithoutWeekInput[]
    upsert?: TrainingSessionUpsertWithWhereUniqueWithoutWeekInput | TrainingSessionUpsertWithWhereUniqueWithoutWeekInput[]
    createMany?: TrainingSessionCreateManyWeekInputEnvelope
    set?: TrainingSessionWhereUniqueInput | TrainingSessionWhereUniqueInput[]
    disconnect?: TrainingSessionWhereUniqueInput | TrainingSessionWhereUniqueInput[]
    delete?: TrainingSessionWhereUniqueInput | TrainingSessionWhereUniqueInput[]
    connect?: TrainingSessionWhereUniqueInput | TrainingSessionWhereUniqueInput[]
    update?: TrainingSessionUpdateWithWhereUniqueWithoutWeekInput | TrainingSessionUpdateWithWhereUniqueWithoutWeekInput[]
    updateMany?: TrainingSessionUpdateManyWithWhereWithoutWeekInput | TrainingSessionUpdateManyWithWhereWithoutWeekInput[]
    deleteMany?: TrainingSessionScalarWhereInput | TrainingSessionScalarWhereInput[]
  }

  export type PatientTrainingProgressUncheckedUpdateManyWithoutWeekNestedInput = {
    create?: XOR<PatientTrainingProgressCreateWithoutWeekInput, PatientTrainingProgressUncheckedCreateWithoutWeekInput> | PatientTrainingProgressCreateWithoutWeekInput[] | PatientTrainingProgressUncheckedCreateWithoutWeekInput[]
    connectOrCreate?: PatientTrainingProgressCreateOrConnectWithoutWeekInput | PatientTrainingProgressCreateOrConnectWithoutWeekInput[]
    upsert?: PatientTrainingProgressUpsertWithWhereUniqueWithoutWeekInput | PatientTrainingProgressUpsertWithWhereUniqueWithoutWeekInput[]
    createMany?: PatientTrainingProgressCreateManyWeekInputEnvelope
    set?: PatientTrainingProgressWhereUniqueInput | PatientTrainingProgressWhereUniqueInput[]
    disconnect?: PatientTrainingProgressWhereUniqueInput | PatientTrainingProgressWhereUniqueInput[]
    delete?: PatientTrainingProgressWhereUniqueInput | PatientTrainingProgressWhereUniqueInput[]
    connect?: PatientTrainingProgressWhereUniqueInput | PatientTrainingProgressWhereUniqueInput[]
    update?: PatientTrainingProgressUpdateWithWhereUniqueWithoutWeekInput | PatientTrainingProgressUpdateWithWhereUniqueWithoutWeekInput[]
    updateMany?: PatientTrainingProgressUpdateManyWithWhereWithoutWeekInput | PatientTrainingProgressUpdateManyWithWhereWithoutWeekInput[]
    deleteMany?: PatientTrainingProgressScalarWhereInput | PatientTrainingProgressScalarWhereInput[]
  }

  export type TrainingWeekCreateNestedOneWithoutSessionsInput = {
    create?: XOR<TrainingWeekCreateWithoutSessionsInput, TrainingWeekUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: TrainingWeekCreateOrConnectWithoutSessionsInput
    connect?: TrainingWeekWhereUniqueInput
  }

  export type PatientSessionCompletionCreateNestedManyWithoutSessionInput = {
    create?: XOR<PatientSessionCompletionCreateWithoutSessionInput, PatientSessionCompletionUncheckedCreateWithoutSessionInput> | PatientSessionCompletionCreateWithoutSessionInput[] | PatientSessionCompletionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: PatientSessionCompletionCreateOrConnectWithoutSessionInput | PatientSessionCompletionCreateOrConnectWithoutSessionInput[]
    createMany?: PatientSessionCompletionCreateManySessionInputEnvelope
    connect?: PatientSessionCompletionWhereUniqueInput | PatientSessionCompletionWhereUniqueInput[]
  }

  export type PatientSessionCompletionUncheckedCreateNestedManyWithoutSessionInput = {
    create?: XOR<PatientSessionCompletionCreateWithoutSessionInput, PatientSessionCompletionUncheckedCreateWithoutSessionInput> | PatientSessionCompletionCreateWithoutSessionInput[] | PatientSessionCompletionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: PatientSessionCompletionCreateOrConnectWithoutSessionInput | PatientSessionCompletionCreateOrConnectWithoutSessionInput[]
    createMany?: PatientSessionCompletionCreateManySessionInputEnvelope
    connect?: PatientSessionCompletionWhereUniqueInput | PatientSessionCompletionWhereUniqueInput[]
  }

  export type TrainingWeekUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<TrainingWeekCreateWithoutSessionsInput, TrainingWeekUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: TrainingWeekCreateOrConnectWithoutSessionsInput
    upsert?: TrainingWeekUpsertWithoutSessionsInput
    connect?: TrainingWeekWhereUniqueInput
    update?: XOR<XOR<TrainingWeekUpdateToOneWithWhereWithoutSessionsInput, TrainingWeekUpdateWithoutSessionsInput>, TrainingWeekUncheckedUpdateWithoutSessionsInput>
  }

  export type PatientSessionCompletionUpdateManyWithoutSessionNestedInput = {
    create?: XOR<PatientSessionCompletionCreateWithoutSessionInput, PatientSessionCompletionUncheckedCreateWithoutSessionInput> | PatientSessionCompletionCreateWithoutSessionInput[] | PatientSessionCompletionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: PatientSessionCompletionCreateOrConnectWithoutSessionInput | PatientSessionCompletionCreateOrConnectWithoutSessionInput[]
    upsert?: PatientSessionCompletionUpsertWithWhereUniqueWithoutSessionInput | PatientSessionCompletionUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: PatientSessionCompletionCreateManySessionInputEnvelope
    set?: PatientSessionCompletionWhereUniqueInput | PatientSessionCompletionWhereUniqueInput[]
    disconnect?: PatientSessionCompletionWhereUniqueInput | PatientSessionCompletionWhereUniqueInput[]
    delete?: PatientSessionCompletionWhereUniqueInput | PatientSessionCompletionWhereUniqueInput[]
    connect?: PatientSessionCompletionWhereUniqueInput | PatientSessionCompletionWhereUniqueInput[]
    update?: PatientSessionCompletionUpdateWithWhereUniqueWithoutSessionInput | PatientSessionCompletionUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: PatientSessionCompletionUpdateManyWithWhereWithoutSessionInput | PatientSessionCompletionUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: PatientSessionCompletionScalarWhereInput | PatientSessionCompletionScalarWhereInput[]
  }

  export type PatientSessionCompletionUncheckedUpdateManyWithoutSessionNestedInput = {
    create?: XOR<PatientSessionCompletionCreateWithoutSessionInput, PatientSessionCompletionUncheckedCreateWithoutSessionInput> | PatientSessionCompletionCreateWithoutSessionInput[] | PatientSessionCompletionUncheckedCreateWithoutSessionInput[]
    connectOrCreate?: PatientSessionCompletionCreateOrConnectWithoutSessionInput | PatientSessionCompletionCreateOrConnectWithoutSessionInput[]
    upsert?: PatientSessionCompletionUpsertWithWhereUniqueWithoutSessionInput | PatientSessionCompletionUpsertWithWhereUniqueWithoutSessionInput[]
    createMany?: PatientSessionCompletionCreateManySessionInputEnvelope
    set?: PatientSessionCompletionWhereUniqueInput | PatientSessionCompletionWhereUniqueInput[]
    disconnect?: PatientSessionCompletionWhereUniqueInput | PatientSessionCompletionWhereUniqueInput[]
    delete?: PatientSessionCompletionWhereUniqueInput | PatientSessionCompletionWhereUniqueInput[]
    connect?: PatientSessionCompletionWhereUniqueInput | PatientSessionCompletionWhereUniqueInput[]
    update?: PatientSessionCompletionUpdateWithWhereUniqueWithoutSessionInput | PatientSessionCompletionUpdateWithWhereUniqueWithoutSessionInput[]
    updateMany?: PatientSessionCompletionUpdateManyWithWhereWithoutSessionInput | PatientSessionCompletionUpdateManyWithWhereWithoutSessionInput[]
    deleteMany?: PatientSessionCompletionScalarWhereInput | PatientSessionCompletionScalarWhereInput[]
  }

  export type PatientCreateNestedOneWithoutTrainingProgressInput = {
    create?: XOR<PatientCreateWithoutTrainingProgressInput, PatientUncheckedCreateWithoutTrainingProgressInput>
    connectOrCreate?: PatientCreateOrConnectWithoutTrainingProgressInput
    connect?: PatientWhereUniqueInput
  }

  export type TrainingWeekCreateNestedOneWithoutProgressInput = {
    create?: XOR<TrainingWeekCreateWithoutProgressInput, TrainingWeekUncheckedCreateWithoutProgressInput>
    connectOrCreate?: TrainingWeekCreateOrConnectWithoutProgressInput
    connect?: TrainingWeekWhereUniqueInput
  }

  export type EnumTrainingWeekStatusFieldUpdateOperationsInput = {
    set?: $Enums.TrainingWeekStatus
  }

  export type PatientUpdateOneRequiredWithoutTrainingProgressNestedInput = {
    create?: XOR<PatientCreateWithoutTrainingProgressInput, PatientUncheckedCreateWithoutTrainingProgressInput>
    connectOrCreate?: PatientCreateOrConnectWithoutTrainingProgressInput
    upsert?: PatientUpsertWithoutTrainingProgressInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutTrainingProgressInput, PatientUpdateWithoutTrainingProgressInput>, PatientUncheckedUpdateWithoutTrainingProgressInput>
  }

  export type TrainingWeekUpdateOneRequiredWithoutProgressNestedInput = {
    create?: XOR<TrainingWeekCreateWithoutProgressInput, TrainingWeekUncheckedCreateWithoutProgressInput>
    connectOrCreate?: TrainingWeekCreateOrConnectWithoutProgressInput
    upsert?: TrainingWeekUpsertWithoutProgressInput
    connect?: TrainingWeekWhereUniqueInput
    update?: XOR<XOR<TrainingWeekUpdateToOneWithWhereWithoutProgressInput, TrainingWeekUpdateWithoutProgressInput>, TrainingWeekUncheckedUpdateWithoutProgressInput>
  }

  export type PatientCreateNestedOneWithoutSessionCompletionsInput = {
    create?: XOR<PatientCreateWithoutSessionCompletionsInput, PatientUncheckedCreateWithoutSessionCompletionsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutSessionCompletionsInput
    connect?: PatientWhereUniqueInput
  }

  export type TrainingSessionCreateNestedOneWithoutCompletionsInput = {
    create?: XOR<TrainingSessionCreateWithoutCompletionsInput, TrainingSessionUncheckedCreateWithoutCompletionsInput>
    connectOrCreate?: TrainingSessionCreateOrConnectWithoutCompletionsInput
    connect?: TrainingSessionWhereUniqueInput
  }

  export type PatientUpdateOneRequiredWithoutSessionCompletionsNestedInput = {
    create?: XOR<PatientCreateWithoutSessionCompletionsInput, PatientUncheckedCreateWithoutSessionCompletionsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutSessionCompletionsInput
    upsert?: PatientUpsertWithoutSessionCompletionsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutSessionCompletionsInput, PatientUpdateWithoutSessionCompletionsInput>, PatientUncheckedUpdateWithoutSessionCompletionsInput>
  }

  export type TrainingSessionUpdateOneRequiredWithoutCompletionsNestedInput = {
    create?: XOR<TrainingSessionCreateWithoutCompletionsInput, TrainingSessionUncheckedCreateWithoutCompletionsInput>
    connectOrCreate?: TrainingSessionCreateOrConnectWithoutCompletionsInput
    upsert?: TrainingSessionUpsertWithoutCompletionsInput
    connect?: TrainingSessionWhereUniqueInput
    update?: XOR<XOR<TrainingSessionUpdateToOneWithWhereWithoutCompletionsInput, TrainingSessionUpdateWithoutCompletionsInput>, TrainingSessionUncheckedUpdateWithoutCompletionsInput>
  }

  export type PatientCreateNestedOneWithoutChatConversationsInput = {
    create?: XOR<PatientCreateWithoutChatConversationsInput, PatientUncheckedCreateWithoutChatConversationsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutChatConversationsInput
    connect?: PatientWhereUniqueInput
  }

  export type ChatMessageCreateNestedManyWithoutConversationInput = {
    create?: XOR<ChatMessageCreateWithoutConversationInput, ChatMessageUncheckedCreateWithoutConversationInput> | ChatMessageCreateWithoutConversationInput[] | ChatMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutConversationInput | ChatMessageCreateOrConnectWithoutConversationInput[]
    createMany?: ChatMessageCreateManyConversationInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type ChatMessageUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<ChatMessageCreateWithoutConversationInput, ChatMessageUncheckedCreateWithoutConversationInput> | ChatMessageCreateWithoutConversationInput[] | ChatMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutConversationInput | ChatMessageCreateOrConnectWithoutConversationInput[]
    createMany?: ChatMessageCreateManyConversationInputEnvelope
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
  }

  export type PatientUpdateOneRequiredWithoutChatConversationsNestedInput = {
    create?: XOR<PatientCreateWithoutChatConversationsInput, PatientUncheckedCreateWithoutChatConversationsInput>
    connectOrCreate?: PatientCreateOrConnectWithoutChatConversationsInput
    upsert?: PatientUpsertWithoutChatConversationsInput
    connect?: PatientWhereUniqueInput
    update?: XOR<XOR<PatientUpdateToOneWithWhereWithoutChatConversationsInput, PatientUpdateWithoutChatConversationsInput>, PatientUncheckedUpdateWithoutChatConversationsInput>
  }

  export type ChatMessageUpdateManyWithoutConversationNestedInput = {
    create?: XOR<ChatMessageCreateWithoutConversationInput, ChatMessageUncheckedCreateWithoutConversationInput> | ChatMessageCreateWithoutConversationInput[] | ChatMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutConversationInput | ChatMessageCreateOrConnectWithoutConversationInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutConversationInput | ChatMessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: ChatMessageCreateManyConversationInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutConversationInput | ChatMessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutConversationInput | ChatMessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type ChatMessageUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<ChatMessageCreateWithoutConversationInput, ChatMessageUncheckedCreateWithoutConversationInput> | ChatMessageCreateWithoutConversationInput[] | ChatMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: ChatMessageCreateOrConnectWithoutConversationInput | ChatMessageCreateOrConnectWithoutConversationInput[]
    upsert?: ChatMessageUpsertWithWhereUniqueWithoutConversationInput | ChatMessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: ChatMessageCreateManyConversationInputEnvelope
    set?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    disconnect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    delete?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    connect?: ChatMessageWhereUniqueInput | ChatMessageWhereUniqueInput[]
    update?: ChatMessageUpdateWithWhereUniqueWithoutConversationInput | ChatMessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: ChatMessageUpdateManyWithWhereWithoutConversationInput | ChatMessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
  }

  export type ChatConversationCreateNestedOneWithoutMessagesInput = {
    create?: XOR<ChatConversationCreateWithoutMessagesInput, ChatConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChatConversationCreateOrConnectWithoutMessagesInput
    connect?: ChatConversationWhereUniqueInput
  }

  export type ChatConversationUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<ChatConversationCreateWithoutMessagesInput, ChatConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: ChatConversationCreateOrConnectWithoutMessagesInput
    upsert?: ChatConversationUpsertWithoutMessagesInput
    connect?: ChatConversationWhereUniqueInput
    update?: XOR<XOR<ChatConversationUpdateToOneWithWhereWithoutMessagesInput, ChatConversationUpdateWithoutMessagesInput>, ChatConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumAppointmentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentType | EnumAppointmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentType[] | ListEnumAppointmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentType[] | ListEnumAppointmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentTypeFilter<$PrismaModel> | $Enums.AppointmentType
  }

  export type NestedEnumAppointmentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentStatusFilter<$PrismaModel> | $Enums.AppointmentStatus
  }

  export type NestedEnumAppointmentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentType | EnumAppointmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentType[] | ListEnumAppointmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentType[] | ListEnumAppointmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentTypeWithAggregatesFilter<$PrismaModel> | $Enums.AppointmentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppointmentTypeFilter<$PrismaModel>
    _max?: NestedEnumAppointmentTypeFilter<$PrismaModel>
  }

  export type NestedEnumAppointmentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppointmentStatus | EnumAppointmentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppointmentStatus[] | ListEnumAppointmentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppointmentStatusWithAggregatesFilter<$PrismaModel> | $Enums.AppointmentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppointmentStatusFilter<$PrismaModel>
    _max?: NestedEnumAppointmentStatusFilter<$PrismaModel>
  }

  export type NestedEnumExamStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ExamStatus | EnumExamStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ExamStatus[] | ListEnumExamStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExamStatus[] | ListEnumExamStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumExamStatusFilter<$PrismaModel> | $Enums.ExamStatus
  }

  export type NestedEnumExamStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExamStatus | EnumExamStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ExamStatus[] | ListEnumExamStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExamStatus[] | ListEnumExamStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumExamStatusWithAggregatesFilter<$PrismaModel> | $Enums.ExamStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExamStatusFilter<$PrismaModel>
    _max?: NestedEnumExamStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumContentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentType | EnumContentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContentTypeFilter<$PrismaModel> | $Enums.ContentType
  }

  export type NestedEnumContentCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentCategory | EnumContentCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ContentCategory[] | ListEnumContentCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentCategory[] | ListEnumContentCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumContentCategoryFilter<$PrismaModel> | $Enums.ContentCategory
  }

  export type NestedEnumContentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentType | EnumContentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContentTypeWithAggregatesFilter<$PrismaModel> | $Enums.ContentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContentTypeFilter<$PrismaModel>
    _max?: NestedEnumContentTypeFilter<$PrismaModel>
  }

  export type NestedEnumContentCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentCategory | EnumContentCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ContentCategory[] | ListEnumContentCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentCategory[] | ListEnumContentCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumContentCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ContentCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContentCategoryFilter<$PrismaModel>
    _max?: NestedEnumContentCategoryFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumAdjustmentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AdjustmentType | EnumAdjustmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AdjustmentType[] | ListEnumAdjustmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdjustmentType[] | ListEnumAdjustmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAdjustmentTypeFilter<$PrismaModel> | $Enums.AdjustmentType
  }

  export type NestedEnumContentTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentType | EnumContentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumContentTypeNullableFilter<$PrismaModel> | $Enums.ContentType | null
  }

  export type NestedEnumContentCategoryNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentCategory | EnumContentCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.ContentCategory[] | ListEnumContentCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ContentCategory[] | ListEnumContentCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumContentCategoryNullableFilter<$PrismaModel> | $Enums.ContentCategory | null
  }

  export type NestedEnumAdjustmentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AdjustmentType | EnumAdjustmentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AdjustmentType[] | ListEnumAdjustmentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AdjustmentType[] | ListEnumAdjustmentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAdjustmentTypeWithAggregatesFilter<$PrismaModel> | $Enums.AdjustmentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAdjustmentTypeFilter<$PrismaModel>
    _max?: NestedEnumAdjustmentTypeFilter<$PrismaModel>
  }

  export type NestedEnumContentTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentType | EnumContentTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumContentTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ContentType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumContentTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumContentTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumContentCategoryNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentCategory | EnumContentCategoryFieldRefInput<$PrismaModel> | null
    in?: $Enums.ContentCategory[] | ListEnumContentCategoryFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ContentCategory[] | ListEnumContentCategoryFieldRefInput<$PrismaModel> | null
    not?: NestedEnumContentCategoryNullableWithAggregatesFilter<$PrismaModel> | $Enums.ContentCategory | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumContentCategoryNullableFilter<$PrismaModel>
    _max?: NestedEnumContentCategoryNullableFilter<$PrismaModel>
  }

  export type NestedEnumTrainingWeekStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TrainingWeekStatus | EnumTrainingWeekStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TrainingWeekStatus[] | ListEnumTrainingWeekStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrainingWeekStatus[] | ListEnumTrainingWeekStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTrainingWeekStatusFilter<$PrismaModel> | $Enums.TrainingWeekStatus
  }

  export type NestedEnumTrainingWeekStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TrainingWeekStatus | EnumTrainingWeekStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TrainingWeekStatus[] | ListEnumTrainingWeekStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TrainingWeekStatus[] | ListEnumTrainingWeekStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTrainingWeekStatusWithAggregatesFilter<$PrismaModel> | $Enums.TrainingWeekStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTrainingWeekStatusFilter<$PrismaModel>
    _max?: NestedEnumTrainingWeekStatusFilter<$PrismaModel>
  }

  export type ClinicCreateWithoutUsersInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    logoUrl?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    patients?: PatientCreateNestedManyWithoutClinicInput
    contents?: ClinicContentCreateNestedManyWithoutClinicInput
    trainingProtocols?: TrainingProtocolCreateNestedManyWithoutClinicInput
  }

  export type ClinicUncheckedCreateWithoutUsersInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    logoUrl?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    patients?: PatientUncheckedCreateNestedManyWithoutClinicInput
    contents?: ClinicContentUncheckedCreateNestedManyWithoutClinicInput
    trainingProtocols?: TrainingProtocolUncheckedCreateNestedManyWithoutClinicInput
  }

  export type ClinicCreateOrConnectWithoutUsersInput = {
    where: ClinicWhereUniqueInput
    create: XOR<ClinicCreateWithoutUsersInput, ClinicUncheckedCreateWithoutUsersInput>
  }

  export type PatientCreateWithoutUserInput = {
    id?: string
    cpf?: string | null
    phone?: string | null
    birthDate?: Date | string | null
    surgeryDate?: Date | string | null
    surgeryType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutPatientsInput
    contentAdjustments?: PatientContentAdjustmentCreateNestedManyWithoutPatientInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    medicationLogs?: MedicationLogCreateNestedManyWithoutPatientInput
    chatConversations?: ChatConversationCreateNestedManyWithoutPatientInput
    exams?: ExamCreateNestedManyWithoutPatientInput
    trainingProgress?: PatientTrainingProgressCreateNestedManyWithoutPatientInput
    sessionCompletions?: PatientSessionCompletionCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutUserInput = {
    id?: string
    clinicId: string
    cpf?: string | null
    phone?: string | null
    birthDate?: Date | string | null
    surgeryDate?: Date | string | null
    surgeryType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contentAdjustments?: PatientContentAdjustmentUncheckedCreateNestedManyWithoutPatientInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    medicationLogs?: MedicationLogUncheckedCreateNestedManyWithoutPatientInput
    chatConversations?: ChatConversationUncheckedCreateNestedManyWithoutPatientInput
    exams?: ExamUncheckedCreateNestedManyWithoutPatientInput
    trainingProgress?: PatientTrainingProgressUncheckedCreateNestedManyWithoutPatientInput
    sessionCompletions?: PatientSessionCompletionUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutUserInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutUserInput, PatientUncheckedCreateWithoutUserInput>
  }

  export type PasswordResetCreateWithoutUserInput = {
    id?: string
    code: string
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
  }

  export type PasswordResetUncheckedCreateWithoutUserInput = {
    id?: string
    code: string
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
  }

  export type PasswordResetCreateOrConnectWithoutUserInput = {
    where: PasswordResetWhereUniqueInput
    create: XOR<PasswordResetCreateWithoutUserInput, PasswordResetUncheckedCreateWithoutUserInput>
  }

  export type PasswordResetCreateManyUserInputEnvelope = {
    data: PasswordResetCreateManyUserInput | PasswordResetCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ClinicUpsertWithoutUsersInput = {
    update: XOR<ClinicUpdateWithoutUsersInput, ClinicUncheckedUpdateWithoutUsersInput>
    create: XOR<ClinicCreateWithoutUsersInput, ClinicUncheckedCreateWithoutUsersInput>
    where?: ClinicWhereInput
  }

  export type ClinicUpdateToOneWithWhereWithoutUsersInput = {
    where?: ClinicWhereInput
    data: XOR<ClinicUpdateWithoutUsersInput, ClinicUncheckedUpdateWithoutUsersInput>
  }

  export type ClinicUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patients?: PatientUpdateManyWithoutClinicNestedInput
    contents?: ClinicContentUpdateManyWithoutClinicNestedInput
    trainingProtocols?: TrainingProtocolUpdateManyWithoutClinicNestedInput
  }

  export type ClinicUncheckedUpdateWithoutUsersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patients?: PatientUncheckedUpdateManyWithoutClinicNestedInput
    contents?: ClinicContentUncheckedUpdateManyWithoutClinicNestedInput
    trainingProtocols?: TrainingProtocolUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type PatientUpsertWithoutUserInput = {
    update: XOR<PatientUpdateWithoutUserInput, PatientUncheckedUpdateWithoutUserInput>
    create: XOR<PatientCreateWithoutUserInput, PatientUncheckedCreateWithoutUserInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutUserInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutUserInput, PatientUncheckedUpdateWithoutUserInput>
  }

  export type PatientUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surgeryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surgeryType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutPatientsNestedInput
    contentAdjustments?: PatientContentAdjustmentUpdateManyWithoutPatientNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    medicationLogs?: MedicationLogUpdateManyWithoutPatientNestedInput
    chatConversations?: ChatConversationUpdateManyWithoutPatientNestedInput
    exams?: ExamUpdateManyWithoutPatientNestedInput
    trainingProgress?: PatientTrainingProgressUpdateManyWithoutPatientNestedInput
    sessionCompletions?: PatientSessionCompletionUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surgeryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surgeryType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contentAdjustments?: PatientContentAdjustmentUncheckedUpdateManyWithoutPatientNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    medicationLogs?: MedicationLogUncheckedUpdateManyWithoutPatientNestedInput
    chatConversations?: ChatConversationUncheckedUpdateManyWithoutPatientNestedInput
    exams?: ExamUncheckedUpdateManyWithoutPatientNestedInput
    trainingProgress?: PatientTrainingProgressUncheckedUpdateManyWithoutPatientNestedInput
    sessionCompletions?: PatientSessionCompletionUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PasswordResetUpsertWithWhereUniqueWithoutUserInput = {
    where: PasswordResetWhereUniqueInput
    update: XOR<PasswordResetUpdateWithoutUserInput, PasswordResetUncheckedUpdateWithoutUserInput>
    create: XOR<PasswordResetCreateWithoutUserInput, PasswordResetUncheckedCreateWithoutUserInput>
  }

  export type PasswordResetUpdateWithWhereUniqueWithoutUserInput = {
    where: PasswordResetWhereUniqueInput
    data: XOR<PasswordResetUpdateWithoutUserInput, PasswordResetUncheckedUpdateWithoutUserInput>
  }

  export type PasswordResetUpdateManyWithWhereWithoutUserInput = {
    where: PasswordResetScalarWhereInput
    data: XOR<PasswordResetUpdateManyMutationInput, PasswordResetUncheckedUpdateManyWithoutUserInput>
  }

  export type PasswordResetScalarWhereInput = {
    AND?: PasswordResetScalarWhereInput | PasswordResetScalarWhereInput[]
    OR?: PasswordResetScalarWhereInput[]
    NOT?: PasswordResetScalarWhereInput | PasswordResetScalarWhereInput[]
    id?: StringFilter<"PasswordReset"> | string
    userId?: StringFilter<"PasswordReset"> | string
    code?: StringFilter<"PasswordReset"> | string
    expiresAt?: DateTimeFilter<"PasswordReset"> | Date | string
    used?: BoolFilter<"PasswordReset"> | boolean
    createdAt?: DateTimeFilter<"PasswordReset"> | Date | string
  }

  export type UserCreateWithoutPasswordResetsInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic?: ClinicCreateNestedOneWithoutUsersInput
    patient?: PatientCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPasswordResetsInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    role?: $Enums.UserRole
    clinicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient?: PatientUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPasswordResetsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPasswordResetsInput, UserUncheckedCreateWithoutPasswordResetsInput>
  }

  export type UserUpsertWithoutPasswordResetsInput = {
    update: XOR<UserUpdateWithoutPasswordResetsInput, UserUncheckedUpdateWithoutPasswordResetsInput>
    create: XOR<UserCreateWithoutPasswordResetsInput, UserUncheckedCreateWithoutPasswordResetsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPasswordResetsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPasswordResetsInput, UserUncheckedUpdateWithoutPasswordResetsInput>
  }

  export type UserUpdateWithoutPasswordResetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneWithoutUsersNestedInput
    patient?: PatientUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPasswordResetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateWithoutClinicInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    patient?: PatientCreateNestedOneWithoutUserInput
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutClinicInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    patient?: PatientUncheckedCreateNestedOneWithoutUserInput
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutClinicInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutClinicInput, UserUncheckedCreateWithoutClinicInput>
  }

  export type UserCreateManyClinicInputEnvelope = {
    data: UserCreateManyClinicInput | UserCreateManyClinicInput[]
    skipDuplicates?: boolean
  }

  export type PatientCreateWithoutClinicInput = {
    id?: string
    cpf?: string | null
    phone?: string | null
    birthDate?: Date | string | null
    surgeryDate?: Date | string | null
    surgeryType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPatientInput
    contentAdjustments?: PatientContentAdjustmentCreateNestedManyWithoutPatientInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    medicationLogs?: MedicationLogCreateNestedManyWithoutPatientInput
    chatConversations?: ChatConversationCreateNestedManyWithoutPatientInput
    exams?: ExamCreateNestedManyWithoutPatientInput
    trainingProgress?: PatientTrainingProgressCreateNestedManyWithoutPatientInput
    sessionCompletions?: PatientSessionCompletionCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutClinicInput = {
    id?: string
    userId: string
    cpf?: string | null
    phone?: string | null
    birthDate?: Date | string | null
    surgeryDate?: Date | string | null
    surgeryType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contentAdjustments?: PatientContentAdjustmentUncheckedCreateNestedManyWithoutPatientInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    medicationLogs?: MedicationLogUncheckedCreateNestedManyWithoutPatientInput
    chatConversations?: ChatConversationUncheckedCreateNestedManyWithoutPatientInput
    exams?: ExamUncheckedCreateNestedManyWithoutPatientInput
    trainingProgress?: PatientTrainingProgressUncheckedCreateNestedManyWithoutPatientInput
    sessionCompletions?: PatientSessionCompletionUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutClinicInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutClinicInput, PatientUncheckedCreateWithoutClinicInput>
  }

  export type PatientCreateManyClinicInputEnvelope = {
    data: PatientCreateManyClinicInput | PatientCreateManyClinicInput[]
    skipDuplicates?: boolean
  }

  export type ClinicContentCreateWithoutClinicInput = {
    id?: string
    templateId?: string | null
    type: $Enums.ContentType
    category: $Enums.ContentCategory
    title: string
    description?: string | null
    validFromDay?: number | null
    validUntilDay?: number | null
    sortOrder?: number
    isActive?: boolean
    isCustom?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    patientAdjustments?: PatientContentAdjustmentCreateNestedManyWithoutBaseContentInput
  }

  export type ClinicContentUncheckedCreateWithoutClinicInput = {
    id?: string
    templateId?: string | null
    type: $Enums.ContentType
    category: $Enums.ContentCategory
    title: string
    description?: string | null
    validFromDay?: number | null
    validUntilDay?: number | null
    sortOrder?: number
    isActive?: boolean
    isCustom?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    patientAdjustments?: PatientContentAdjustmentUncheckedCreateNestedManyWithoutBaseContentInput
  }

  export type ClinicContentCreateOrConnectWithoutClinicInput = {
    where: ClinicContentWhereUniqueInput
    create: XOR<ClinicContentCreateWithoutClinicInput, ClinicContentUncheckedCreateWithoutClinicInput>
  }

  export type ClinicContentCreateManyClinicInputEnvelope = {
    data: ClinicContentCreateManyClinicInput | ClinicContentCreateManyClinicInput[]
    skipDuplicates?: boolean
  }

  export type TrainingProtocolCreateWithoutClinicInput = {
    id?: string
    name: string
    surgeryType?: string | null
    description?: string | null
    totalWeeks?: number
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    weeks?: TrainingWeekCreateNestedManyWithoutProtocolInput
  }

  export type TrainingProtocolUncheckedCreateWithoutClinicInput = {
    id?: string
    name: string
    surgeryType?: string | null
    description?: string | null
    totalWeeks?: number
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    weeks?: TrainingWeekUncheckedCreateNestedManyWithoutProtocolInput
  }

  export type TrainingProtocolCreateOrConnectWithoutClinicInput = {
    where: TrainingProtocolWhereUniqueInput
    create: XOR<TrainingProtocolCreateWithoutClinicInput, TrainingProtocolUncheckedCreateWithoutClinicInput>
  }

  export type TrainingProtocolCreateManyClinicInputEnvelope = {
    data: TrainingProtocolCreateManyClinicInput | TrainingProtocolCreateManyClinicInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithWhereUniqueWithoutClinicInput = {
    where: UserWhereUniqueInput
    update: XOR<UserUpdateWithoutClinicInput, UserUncheckedUpdateWithoutClinicInput>
    create: XOR<UserCreateWithoutClinicInput, UserUncheckedCreateWithoutClinicInput>
  }

  export type UserUpdateWithWhereUniqueWithoutClinicInput = {
    where: UserWhereUniqueInput
    data: XOR<UserUpdateWithoutClinicInput, UserUncheckedUpdateWithoutClinicInput>
  }

  export type UserUpdateManyWithWhereWithoutClinicInput = {
    where: UserScalarWhereInput
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyWithoutClinicInput>
  }

  export type UserScalarWhereInput = {
    AND?: UserScalarWhereInput | UserScalarWhereInput[]
    OR?: UserScalarWhereInput[]
    NOT?: UserScalarWhereInput | UserScalarWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    passwordHash?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    clinicId?: StringNullableFilter<"User"> | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type PatientUpsertWithWhereUniqueWithoutClinicInput = {
    where: PatientWhereUniqueInput
    update: XOR<PatientUpdateWithoutClinicInput, PatientUncheckedUpdateWithoutClinicInput>
    create: XOR<PatientCreateWithoutClinicInput, PatientUncheckedCreateWithoutClinicInput>
  }

  export type PatientUpdateWithWhereUniqueWithoutClinicInput = {
    where: PatientWhereUniqueInput
    data: XOR<PatientUpdateWithoutClinicInput, PatientUncheckedUpdateWithoutClinicInput>
  }

  export type PatientUpdateManyWithWhereWithoutClinicInput = {
    where: PatientScalarWhereInput
    data: XOR<PatientUpdateManyMutationInput, PatientUncheckedUpdateManyWithoutClinicInput>
  }

  export type PatientScalarWhereInput = {
    AND?: PatientScalarWhereInput | PatientScalarWhereInput[]
    OR?: PatientScalarWhereInput[]
    NOT?: PatientScalarWhereInput | PatientScalarWhereInput[]
    id?: StringFilter<"Patient"> | string
    userId?: StringFilter<"Patient"> | string
    clinicId?: StringFilter<"Patient"> | string
    cpf?: StringNullableFilter<"Patient"> | string | null
    phone?: StringNullableFilter<"Patient"> | string | null
    birthDate?: DateTimeNullableFilter<"Patient"> | Date | string | null
    surgeryDate?: DateTimeNullableFilter<"Patient"> | Date | string | null
    surgeryType?: StringNullableFilter<"Patient"> | string | null
    createdAt?: DateTimeFilter<"Patient"> | Date | string
    updatedAt?: DateTimeFilter<"Patient"> | Date | string
  }

  export type ClinicContentUpsertWithWhereUniqueWithoutClinicInput = {
    where: ClinicContentWhereUniqueInput
    update: XOR<ClinicContentUpdateWithoutClinicInput, ClinicContentUncheckedUpdateWithoutClinicInput>
    create: XOR<ClinicContentCreateWithoutClinicInput, ClinicContentUncheckedCreateWithoutClinicInput>
  }

  export type ClinicContentUpdateWithWhereUniqueWithoutClinicInput = {
    where: ClinicContentWhereUniqueInput
    data: XOR<ClinicContentUpdateWithoutClinicInput, ClinicContentUncheckedUpdateWithoutClinicInput>
  }

  export type ClinicContentUpdateManyWithWhereWithoutClinicInput = {
    where: ClinicContentScalarWhereInput
    data: XOR<ClinicContentUpdateManyMutationInput, ClinicContentUncheckedUpdateManyWithoutClinicInput>
  }

  export type ClinicContentScalarWhereInput = {
    AND?: ClinicContentScalarWhereInput | ClinicContentScalarWhereInput[]
    OR?: ClinicContentScalarWhereInput[]
    NOT?: ClinicContentScalarWhereInput | ClinicContentScalarWhereInput[]
    id?: StringFilter<"ClinicContent"> | string
    clinicId?: StringFilter<"ClinicContent"> | string
    templateId?: StringNullableFilter<"ClinicContent"> | string | null
    type?: EnumContentTypeFilter<"ClinicContent"> | $Enums.ContentType
    category?: EnumContentCategoryFilter<"ClinicContent"> | $Enums.ContentCategory
    title?: StringFilter<"ClinicContent"> | string
    description?: StringNullableFilter<"ClinicContent"> | string | null
    validFromDay?: IntNullableFilter<"ClinicContent"> | number | null
    validUntilDay?: IntNullableFilter<"ClinicContent"> | number | null
    sortOrder?: IntFilter<"ClinicContent"> | number
    isActive?: BoolFilter<"ClinicContent"> | boolean
    isCustom?: BoolFilter<"ClinicContent"> | boolean
    createdAt?: DateTimeFilter<"ClinicContent"> | Date | string
    updatedAt?: DateTimeFilter<"ClinicContent"> | Date | string
  }

  export type TrainingProtocolUpsertWithWhereUniqueWithoutClinicInput = {
    where: TrainingProtocolWhereUniqueInput
    update: XOR<TrainingProtocolUpdateWithoutClinicInput, TrainingProtocolUncheckedUpdateWithoutClinicInput>
    create: XOR<TrainingProtocolCreateWithoutClinicInput, TrainingProtocolUncheckedCreateWithoutClinicInput>
  }

  export type TrainingProtocolUpdateWithWhereUniqueWithoutClinicInput = {
    where: TrainingProtocolWhereUniqueInput
    data: XOR<TrainingProtocolUpdateWithoutClinicInput, TrainingProtocolUncheckedUpdateWithoutClinicInput>
  }

  export type TrainingProtocolUpdateManyWithWhereWithoutClinicInput = {
    where: TrainingProtocolScalarWhereInput
    data: XOR<TrainingProtocolUpdateManyMutationInput, TrainingProtocolUncheckedUpdateManyWithoutClinicInput>
  }

  export type TrainingProtocolScalarWhereInput = {
    AND?: TrainingProtocolScalarWhereInput | TrainingProtocolScalarWhereInput[]
    OR?: TrainingProtocolScalarWhereInput[]
    NOT?: TrainingProtocolScalarWhereInput | TrainingProtocolScalarWhereInput[]
    id?: StringFilter<"TrainingProtocol"> | string
    clinicId?: StringNullableFilter<"TrainingProtocol"> | string | null
    name?: StringFilter<"TrainingProtocol"> | string
    surgeryType?: StringNullableFilter<"TrainingProtocol"> | string | null
    description?: StringNullableFilter<"TrainingProtocol"> | string | null
    totalWeeks?: IntFilter<"TrainingProtocol"> | number
    isDefault?: BoolFilter<"TrainingProtocol"> | boolean
    isActive?: BoolFilter<"TrainingProtocol"> | boolean
    createdAt?: DateTimeFilter<"TrainingProtocol"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingProtocol"> | Date | string
  }

  export type UserCreateWithoutPatientInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic?: ClinicCreateNestedOneWithoutUsersInput
    passwordResets?: PasswordResetCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutPatientInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    role?: $Enums.UserRole
    clinicId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    passwordResets?: PasswordResetUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutPatientInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPatientInput, UserUncheckedCreateWithoutPatientInput>
  }

  export type ClinicCreateWithoutPatientsInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    logoUrl?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutClinicInput
    contents?: ClinicContentCreateNestedManyWithoutClinicInput
    trainingProtocols?: TrainingProtocolCreateNestedManyWithoutClinicInput
  }

  export type ClinicUncheckedCreateWithoutPatientsInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    logoUrl?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutClinicInput
    contents?: ClinicContentUncheckedCreateNestedManyWithoutClinicInput
    trainingProtocols?: TrainingProtocolUncheckedCreateNestedManyWithoutClinicInput
  }

  export type ClinicCreateOrConnectWithoutPatientsInput = {
    where: ClinicWhereUniqueInput
    create: XOR<ClinicCreateWithoutPatientsInput, ClinicUncheckedCreateWithoutPatientsInput>
  }

  export type PatientContentAdjustmentCreateWithoutPatientInput = {
    id?: string
    adjustmentType: $Enums.AdjustmentType
    contentType?: $Enums.ContentType | null
    category?: $Enums.ContentCategory | null
    title?: string | null
    description?: string | null
    validFromDay?: number | null
    validUntilDay?: number | null
    reason?: string | null
    isActive?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    baseContent?: ClinicContentCreateNestedOneWithoutPatientAdjustmentsInput
  }

  export type PatientContentAdjustmentUncheckedCreateWithoutPatientInput = {
    id?: string
    baseContentId?: string | null
    adjustmentType: $Enums.AdjustmentType
    contentType?: $Enums.ContentType | null
    category?: $Enums.ContentCategory | null
    title?: string | null
    description?: string | null
    validFromDay?: number | null
    validUntilDay?: number | null
    reason?: string | null
    isActive?: boolean
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type PatientContentAdjustmentCreateOrConnectWithoutPatientInput = {
    where: PatientContentAdjustmentWhereUniqueInput
    create: XOR<PatientContentAdjustmentCreateWithoutPatientInput, PatientContentAdjustmentUncheckedCreateWithoutPatientInput>
  }

  export type PatientContentAdjustmentCreateManyPatientInputEnvelope = {
    data: PatientContentAdjustmentCreateManyPatientInput | PatientContentAdjustmentCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type AppointmentCreateWithoutPatientInput = {
    id?: string
    title: string
    description?: string | null
    date: Date | string
    time: string
    type: $Enums.AppointmentType
    status?: $Enums.AppointmentStatus
    location?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentUncheckedCreateWithoutPatientInput = {
    id?: string
    title: string
    description?: string | null
    date: Date | string
    time: string
    type: $Enums.AppointmentType
    status?: $Enums.AppointmentStatus
    location?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppointmentCreateOrConnectWithoutPatientInput = {
    where: AppointmentWhereUniqueInput
    create: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput>
  }

  export type AppointmentCreateManyPatientInputEnvelope = {
    data: AppointmentCreateManyPatientInput | AppointmentCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type MedicationLogCreateWithoutPatientInput = {
    id?: string
    contentId: string
    takenAt?: Date | string
    scheduledTime: string
    createdAt?: Date | string
  }

  export type MedicationLogUncheckedCreateWithoutPatientInput = {
    id?: string
    contentId: string
    takenAt?: Date | string
    scheduledTime: string
    createdAt?: Date | string
  }

  export type MedicationLogCreateOrConnectWithoutPatientInput = {
    where: MedicationLogWhereUniqueInput
    create: XOR<MedicationLogCreateWithoutPatientInput, MedicationLogUncheckedCreateWithoutPatientInput>
  }

  export type MedicationLogCreateManyPatientInputEnvelope = {
    data: MedicationLogCreateManyPatientInput | MedicationLogCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type ChatConversationCreateWithoutPatientInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: ChatMessageCreateNestedManyWithoutConversationInput
  }

  export type ChatConversationUncheckedCreateWithoutPatientInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: ChatMessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ChatConversationCreateOrConnectWithoutPatientInput = {
    where: ChatConversationWhereUniqueInput
    create: XOR<ChatConversationCreateWithoutPatientInput, ChatConversationUncheckedCreateWithoutPatientInput>
  }

  export type ChatConversationCreateManyPatientInputEnvelope = {
    data: ChatConversationCreateManyPatientInput | ChatConversationCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type ExamCreateWithoutPatientInput = {
    id?: string
    title: string
    type: string
    date: Date | string
    status?: $Enums.ExamStatus
    fileUrl?: string | null
    fileName?: string | null
    fileSize?: number | null
    mimeType?: string | null
    notes?: string | null
    result?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamUncheckedCreateWithoutPatientInput = {
    id?: string
    title: string
    type: string
    date: Date | string
    status?: $Enums.ExamStatus
    fileUrl?: string | null
    fileName?: string | null
    fileSize?: number | null
    mimeType?: string | null
    notes?: string | null
    result?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamCreateOrConnectWithoutPatientInput = {
    where: ExamWhereUniqueInput
    create: XOR<ExamCreateWithoutPatientInput, ExamUncheckedCreateWithoutPatientInput>
  }

  export type ExamCreateManyPatientInputEnvelope = {
    data: ExamCreateManyPatientInput | ExamCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type PatientTrainingProgressCreateWithoutPatientInput = {
    id?: string
    status?: $Enums.TrainingWeekStatus
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    week: TrainingWeekCreateNestedOneWithoutProgressInput
  }

  export type PatientTrainingProgressUncheckedCreateWithoutPatientInput = {
    id?: string
    weekId: string
    status?: $Enums.TrainingWeekStatus
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatientTrainingProgressCreateOrConnectWithoutPatientInput = {
    where: PatientTrainingProgressWhereUniqueInput
    create: XOR<PatientTrainingProgressCreateWithoutPatientInput, PatientTrainingProgressUncheckedCreateWithoutPatientInput>
  }

  export type PatientTrainingProgressCreateManyPatientInputEnvelope = {
    data: PatientTrainingProgressCreateManyPatientInput | PatientTrainingProgressCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type PatientSessionCompletionCreateWithoutPatientInput = {
    id?: string
    completedAt?: Date | string
    notes?: string | null
    session: TrainingSessionCreateNestedOneWithoutCompletionsInput
  }

  export type PatientSessionCompletionUncheckedCreateWithoutPatientInput = {
    id?: string
    sessionId: string
    completedAt?: Date | string
    notes?: string | null
  }

  export type PatientSessionCompletionCreateOrConnectWithoutPatientInput = {
    where: PatientSessionCompletionWhereUniqueInput
    create: XOR<PatientSessionCompletionCreateWithoutPatientInput, PatientSessionCompletionUncheckedCreateWithoutPatientInput>
  }

  export type PatientSessionCompletionCreateManyPatientInputEnvelope = {
    data: PatientSessionCompletionCreateManyPatientInput | PatientSessionCompletionCreateManyPatientInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutPatientInput = {
    update: XOR<UserUpdateWithoutPatientInput, UserUncheckedUpdateWithoutPatientInput>
    create: XOR<UserCreateWithoutPatientInput, UserUncheckedCreateWithoutPatientInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPatientInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPatientInput, UserUncheckedUpdateWithoutPatientInput>
  }

  export type UserUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneWithoutUsersNestedInput
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
  }

  export type ClinicUpsertWithoutPatientsInput = {
    update: XOR<ClinicUpdateWithoutPatientsInput, ClinicUncheckedUpdateWithoutPatientsInput>
    create: XOR<ClinicCreateWithoutPatientsInput, ClinicUncheckedCreateWithoutPatientsInput>
    where?: ClinicWhereInput
  }

  export type ClinicUpdateToOneWithWhereWithoutPatientsInput = {
    where?: ClinicWhereInput
    data: XOR<ClinicUpdateWithoutPatientsInput, ClinicUncheckedUpdateWithoutPatientsInput>
  }

  export type ClinicUpdateWithoutPatientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutClinicNestedInput
    contents?: ClinicContentUpdateManyWithoutClinicNestedInput
    trainingProtocols?: TrainingProtocolUpdateManyWithoutClinicNestedInput
  }

  export type ClinicUncheckedUpdateWithoutPatientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutClinicNestedInput
    contents?: ClinicContentUncheckedUpdateManyWithoutClinicNestedInput
    trainingProtocols?: TrainingProtocolUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type PatientContentAdjustmentUpsertWithWhereUniqueWithoutPatientInput = {
    where: PatientContentAdjustmentWhereUniqueInput
    update: XOR<PatientContentAdjustmentUpdateWithoutPatientInput, PatientContentAdjustmentUncheckedUpdateWithoutPatientInput>
    create: XOR<PatientContentAdjustmentCreateWithoutPatientInput, PatientContentAdjustmentUncheckedCreateWithoutPatientInput>
  }

  export type PatientContentAdjustmentUpdateWithWhereUniqueWithoutPatientInput = {
    where: PatientContentAdjustmentWhereUniqueInput
    data: XOR<PatientContentAdjustmentUpdateWithoutPatientInput, PatientContentAdjustmentUncheckedUpdateWithoutPatientInput>
  }

  export type PatientContentAdjustmentUpdateManyWithWhereWithoutPatientInput = {
    where: PatientContentAdjustmentScalarWhereInput
    data: XOR<PatientContentAdjustmentUpdateManyMutationInput, PatientContentAdjustmentUncheckedUpdateManyWithoutPatientInput>
  }

  export type PatientContentAdjustmentScalarWhereInput = {
    AND?: PatientContentAdjustmentScalarWhereInput | PatientContentAdjustmentScalarWhereInput[]
    OR?: PatientContentAdjustmentScalarWhereInput[]
    NOT?: PatientContentAdjustmentScalarWhereInput | PatientContentAdjustmentScalarWhereInput[]
    id?: StringFilter<"PatientContentAdjustment"> | string
    patientId?: StringFilter<"PatientContentAdjustment"> | string
    baseContentId?: StringNullableFilter<"PatientContentAdjustment"> | string | null
    adjustmentType?: EnumAdjustmentTypeFilter<"PatientContentAdjustment"> | $Enums.AdjustmentType
    contentType?: EnumContentTypeNullableFilter<"PatientContentAdjustment"> | $Enums.ContentType | null
    category?: EnumContentCategoryNullableFilter<"PatientContentAdjustment"> | $Enums.ContentCategory | null
    title?: StringNullableFilter<"PatientContentAdjustment"> | string | null
    description?: StringNullableFilter<"PatientContentAdjustment"> | string | null
    validFromDay?: IntNullableFilter<"PatientContentAdjustment"> | number | null
    validUntilDay?: IntNullableFilter<"PatientContentAdjustment"> | number | null
    reason?: StringNullableFilter<"PatientContentAdjustment"> | string | null
    isActive?: BoolFilter<"PatientContentAdjustment"> | boolean
    createdBy?: StringNullableFilter<"PatientContentAdjustment"> | string | null
    createdAt?: DateTimeFilter<"PatientContentAdjustment"> | Date | string
  }

  export type AppointmentUpsertWithWhereUniqueWithoutPatientInput = {
    where: AppointmentWhereUniqueInput
    update: XOR<AppointmentUpdateWithoutPatientInput, AppointmentUncheckedUpdateWithoutPatientInput>
    create: XOR<AppointmentCreateWithoutPatientInput, AppointmentUncheckedCreateWithoutPatientInput>
  }

  export type AppointmentUpdateWithWhereUniqueWithoutPatientInput = {
    where: AppointmentWhereUniqueInput
    data: XOR<AppointmentUpdateWithoutPatientInput, AppointmentUncheckedUpdateWithoutPatientInput>
  }

  export type AppointmentUpdateManyWithWhereWithoutPatientInput = {
    where: AppointmentScalarWhereInput
    data: XOR<AppointmentUpdateManyMutationInput, AppointmentUncheckedUpdateManyWithoutPatientInput>
  }

  export type AppointmentScalarWhereInput = {
    AND?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
    OR?: AppointmentScalarWhereInput[]
    NOT?: AppointmentScalarWhereInput | AppointmentScalarWhereInput[]
    id?: StringFilter<"Appointment"> | string
    patientId?: StringFilter<"Appointment"> | string
    title?: StringFilter<"Appointment"> | string
    description?: StringNullableFilter<"Appointment"> | string | null
    date?: DateTimeFilter<"Appointment"> | Date | string
    time?: StringFilter<"Appointment"> | string
    type?: EnumAppointmentTypeFilter<"Appointment"> | $Enums.AppointmentType
    status?: EnumAppointmentStatusFilter<"Appointment"> | $Enums.AppointmentStatus
    location?: StringNullableFilter<"Appointment"> | string | null
    notes?: StringNullableFilter<"Appointment"> | string | null
    createdAt?: DateTimeFilter<"Appointment"> | Date | string
    updatedAt?: DateTimeFilter<"Appointment"> | Date | string
  }

  export type MedicationLogUpsertWithWhereUniqueWithoutPatientInput = {
    where: MedicationLogWhereUniqueInput
    update: XOR<MedicationLogUpdateWithoutPatientInput, MedicationLogUncheckedUpdateWithoutPatientInput>
    create: XOR<MedicationLogCreateWithoutPatientInput, MedicationLogUncheckedCreateWithoutPatientInput>
  }

  export type MedicationLogUpdateWithWhereUniqueWithoutPatientInput = {
    where: MedicationLogWhereUniqueInput
    data: XOR<MedicationLogUpdateWithoutPatientInput, MedicationLogUncheckedUpdateWithoutPatientInput>
  }

  export type MedicationLogUpdateManyWithWhereWithoutPatientInput = {
    where: MedicationLogScalarWhereInput
    data: XOR<MedicationLogUpdateManyMutationInput, MedicationLogUncheckedUpdateManyWithoutPatientInput>
  }

  export type MedicationLogScalarWhereInput = {
    AND?: MedicationLogScalarWhereInput | MedicationLogScalarWhereInput[]
    OR?: MedicationLogScalarWhereInput[]
    NOT?: MedicationLogScalarWhereInput | MedicationLogScalarWhereInput[]
    id?: StringFilter<"MedicationLog"> | string
    patientId?: StringFilter<"MedicationLog"> | string
    contentId?: StringFilter<"MedicationLog"> | string
    takenAt?: DateTimeFilter<"MedicationLog"> | Date | string
    scheduledTime?: StringFilter<"MedicationLog"> | string
    createdAt?: DateTimeFilter<"MedicationLog"> | Date | string
  }

  export type ChatConversationUpsertWithWhereUniqueWithoutPatientInput = {
    where: ChatConversationWhereUniqueInput
    update: XOR<ChatConversationUpdateWithoutPatientInput, ChatConversationUncheckedUpdateWithoutPatientInput>
    create: XOR<ChatConversationCreateWithoutPatientInput, ChatConversationUncheckedCreateWithoutPatientInput>
  }

  export type ChatConversationUpdateWithWhereUniqueWithoutPatientInput = {
    where: ChatConversationWhereUniqueInput
    data: XOR<ChatConversationUpdateWithoutPatientInput, ChatConversationUncheckedUpdateWithoutPatientInput>
  }

  export type ChatConversationUpdateManyWithWhereWithoutPatientInput = {
    where: ChatConversationScalarWhereInput
    data: XOR<ChatConversationUpdateManyMutationInput, ChatConversationUncheckedUpdateManyWithoutPatientInput>
  }

  export type ChatConversationScalarWhereInput = {
    AND?: ChatConversationScalarWhereInput | ChatConversationScalarWhereInput[]
    OR?: ChatConversationScalarWhereInput[]
    NOT?: ChatConversationScalarWhereInput | ChatConversationScalarWhereInput[]
    id?: StringFilter<"ChatConversation"> | string
    patientId?: StringFilter<"ChatConversation"> | string
    createdAt?: DateTimeFilter<"ChatConversation"> | Date | string
    updatedAt?: DateTimeFilter<"ChatConversation"> | Date | string
  }

  export type ExamUpsertWithWhereUniqueWithoutPatientInput = {
    where: ExamWhereUniqueInput
    update: XOR<ExamUpdateWithoutPatientInput, ExamUncheckedUpdateWithoutPatientInput>
    create: XOR<ExamCreateWithoutPatientInput, ExamUncheckedCreateWithoutPatientInput>
  }

  export type ExamUpdateWithWhereUniqueWithoutPatientInput = {
    where: ExamWhereUniqueInput
    data: XOR<ExamUpdateWithoutPatientInput, ExamUncheckedUpdateWithoutPatientInput>
  }

  export type ExamUpdateManyWithWhereWithoutPatientInput = {
    where: ExamScalarWhereInput
    data: XOR<ExamUpdateManyMutationInput, ExamUncheckedUpdateManyWithoutPatientInput>
  }

  export type ExamScalarWhereInput = {
    AND?: ExamScalarWhereInput | ExamScalarWhereInput[]
    OR?: ExamScalarWhereInput[]
    NOT?: ExamScalarWhereInput | ExamScalarWhereInput[]
    id?: StringFilter<"Exam"> | string
    patientId?: StringFilter<"Exam"> | string
    title?: StringFilter<"Exam"> | string
    type?: StringFilter<"Exam"> | string
    date?: DateTimeFilter<"Exam"> | Date | string
    status?: EnumExamStatusFilter<"Exam"> | $Enums.ExamStatus
    fileUrl?: StringNullableFilter<"Exam"> | string | null
    fileName?: StringNullableFilter<"Exam"> | string | null
    fileSize?: IntNullableFilter<"Exam"> | number | null
    mimeType?: StringNullableFilter<"Exam"> | string | null
    notes?: StringNullableFilter<"Exam"> | string | null
    result?: StringNullableFilter<"Exam"> | string | null
    createdAt?: DateTimeFilter<"Exam"> | Date | string
    updatedAt?: DateTimeFilter<"Exam"> | Date | string
  }

  export type PatientTrainingProgressUpsertWithWhereUniqueWithoutPatientInput = {
    where: PatientTrainingProgressWhereUniqueInput
    update: XOR<PatientTrainingProgressUpdateWithoutPatientInput, PatientTrainingProgressUncheckedUpdateWithoutPatientInput>
    create: XOR<PatientTrainingProgressCreateWithoutPatientInput, PatientTrainingProgressUncheckedCreateWithoutPatientInput>
  }

  export type PatientTrainingProgressUpdateWithWhereUniqueWithoutPatientInput = {
    where: PatientTrainingProgressWhereUniqueInput
    data: XOR<PatientTrainingProgressUpdateWithoutPatientInput, PatientTrainingProgressUncheckedUpdateWithoutPatientInput>
  }

  export type PatientTrainingProgressUpdateManyWithWhereWithoutPatientInput = {
    where: PatientTrainingProgressScalarWhereInput
    data: XOR<PatientTrainingProgressUpdateManyMutationInput, PatientTrainingProgressUncheckedUpdateManyWithoutPatientInput>
  }

  export type PatientTrainingProgressScalarWhereInput = {
    AND?: PatientTrainingProgressScalarWhereInput | PatientTrainingProgressScalarWhereInput[]
    OR?: PatientTrainingProgressScalarWhereInput[]
    NOT?: PatientTrainingProgressScalarWhereInput | PatientTrainingProgressScalarWhereInput[]
    id?: StringFilter<"PatientTrainingProgress"> | string
    patientId?: StringFilter<"PatientTrainingProgress"> | string
    weekId?: StringFilter<"PatientTrainingProgress"> | string
    status?: EnumTrainingWeekStatusFilter<"PatientTrainingProgress"> | $Enums.TrainingWeekStatus
    startedAt?: DateTimeNullableFilter<"PatientTrainingProgress"> | Date | string | null
    completedAt?: DateTimeNullableFilter<"PatientTrainingProgress"> | Date | string | null
    createdAt?: DateTimeFilter<"PatientTrainingProgress"> | Date | string
    updatedAt?: DateTimeFilter<"PatientTrainingProgress"> | Date | string
  }

  export type PatientSessionCompletionUpsertWithWhereUniqueWithoutPatientInput = {
    where: PatientSessionCompletionWhereUniqueInput
    update: XOR<PatientSessionCompletionUpdateWithoutPatientInput, PatientSessionCompletionUncheckedUpdateWithoutPatientInput>
    create: XOR<PatientSessionCompletionCreateWithoutPatientInput, PatientSessionCompletionUncheckedCreateWithoutPatientInput>
  }

  export type PatientSessionCompletionUpdateWithWhereUniqueWithoutPatientInput = {
    where: PatientSessionCompletionWhereUniqueInput
    data: XOR<PatientSessionCompletionUpdateWithoutPatientInput, PatientSessionCompletionUncheckedUpdateWithoutPatientInput>
  }

  export type PatientSessionCompletionUpdateManyWithWhereWithoutPatientInput = {
    where: PatientSessionCompletionScalarWhereInput
    data: XOR<PatientSessionCompletionUpdateManyMutationInput, PatientSessionCompletionUncheckedUpdateManyWithoutPatientInput>
  }

  export type PatientSessionCompletionScalarWhereInput = {
    AND?: PatientSessionCompletionScalarWhereInput | PatientSessionCompletionScalarWhereInput[]
    OR?: PatientSessionCompletionScalarWhereInput[]
    NOT?: PatientSessionCompletionScalarWhereInput | PatientSessionCompletionScalarWhereInput[]
    id?: StringFilter<"PatientSessionCompletion"> | string
    patientId?: StringFilter<"PatientSessionCompletion"> | string
    sessionId?: StringFilter<"PatientSessionCompletion"> | string
    completedAt?: DateTimeFilter<"PatientSessionCompletion"> | Date | string
    notes?: StringNullableFilter<"PatientSessionCompletion"> | string | null
  }

  export type PatientCreateWithoutAppointmentsInput = {
    id?: string
    cpf?: string | null
    phone?: string | null
    birthDate?: Date | string | null
    surgeryDate?: Date | string | null
    surgeryType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPatientInput
    clinic: ClinicCreateNestedOneWithoutPatientsInput
    contentAdjustments?: PatientContentAdjustmentCreateNestedManyWithoutPatientInput
    medicationLogs?: MedicationLogCreateNestedManyWithoutPatientInput
    chatConversations?: ChatConversationCreateNestedManyWithoutPatientInput
    exams?: ExamCreateNestedManyWithoutPatientInput
    trainingProgress?: PatientTrainingProgressCreateNestedManyWithoutPatientInput
    sessionCompletions?: PatientSessionCompletionCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutAppointmentsInput = {
    id?: string
    userId: string
    clinicId: string
    cpf?: string | null
    phone?: string | null
    birthDate?: Date | string | null
    surgeryDate?: Date | string | null
    surgeryType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contentAdjustments?: PatientContentAdjustmentUncheckedCreateNestedManyWithoutPatientInput
    medicationLogs?: MedicationLogUncheckedCreateNestedManyWithoutPatientInput
    chatConversations?: ChatConversationUncheckedCreateNestedManyWithoutPatientInput
    exams?: ExamUncheckedCreateNestedManyWithoutPatientInput
    trainingProgress?: PatientTrainingProgressUncheckedCreateNestedManyWithoutPatientInput
    sessionCompletions?: PatientSessionCompletionUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutAppointmentsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutAppointmentsInput, PatientUncheckedCreateWithoutAppointmentsInput>
  }

  export type PatientUpsertWithoutAppointmentsInput = {
    update: XOR<PatientUpdateWithoutAppointmentsInput, PatientUncheckedUpdateWithoutAppointmentsInput>
    create: XOR<PatientCreateWithoutAppointmentsInput, PatientUncheckedCreateWithoutAppointmentsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutAppointmentsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutAppointmentsInput, PatientUncheckedUpdateWithoutAppointmentsInput>
  }

  export type PatientUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surgeryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surgeryType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPatientNestedInput
    clinic?: ClinicUpdateOneRequiredWithoutPatientsNestedInput
    contentAdjustments?: PatientContentAdjustmentUpdateManyWithoutPatientNestedInput
    medicationLogs?: MedicationLogUpdateManyWithoutPatientNestedInput
    chatConversations?: ChatConversationUpdateManyWithoutPatientNestedInput
    exams?: ExamUpdateManyWithoutPatientNestedInput
    trainingProgress?: PatientTrainingProgressUpdateManyWithoutPatientNestedInput
    sessionCompletions?: PatientSessionCompletionUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutAppointmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surgeryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surgeryType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contentAdjustments?: PatientContentAdjustmentUncheckedUpdateManyWithoutPatientNestedInput
    medicationLogs?: MedicationLogUncheckedUpdateManyWithoutPatientNestedInput
    chatConversations?: ChatConversationUncheckedUpdateManyWithoutPatientNestedInput
    exams?: ExamUncheckedUpdateManyWithoutPatientNestedInput
    trainingProgress?: PatientTrainingProgressUncheckedUpdateManyWithoutPatientNestedInput
    sessionCompletions?: PatientSessionCompletionUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientCreateWithoutMedicationLogsInput = {
    id?: string
    cpf?: string | null
    phone?: string | null
    birthDate?: Date | string | null
    surgeryDate?: Date | string | null
    surgeryType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPatientInput
    clinic: ClinicCreateNestedOneWithoutPatientsInput
    contentAdjustments?: PatientContentAdjustmentCreateNestedManyWithoutPatientInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    chatConversations?: ChatConversationCreateNestedManyWithoutPatientInput
    exams?: ExamCreateNestedManyWithoutPatientInput
    trainingProgress?: PatientTrainingProgressCreateNestedManyWithoutPatientInput
    sessionCompletions?: PatientSessionCompletionCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutMedicationLogsInput = {
    id?: string
    userId: string
    clinicId: string
    cpf?: string | null
    phone?: string | null
    birthDate?: Date | string | null
    surgeryDate?: Date | string | null
    surgeryType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contentAdjustments?: PatientContentAdjustmentUncheckedCreateNestedManyWithoutPatientInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    chatConversations?: ChatConversationUncheckedCreateNestedManyWithoutPatientInput
    exams?: ExamUncheckedCreateNestedManyWithoutPatientInput
    trainingProgress?: PatientTrainingProgressUncheckedCreateNestedManyWithoutPatientInput
    sessionCompletions?: PatientSessionCompletionUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutMedicationLogsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutMedicationLogsInput, PatientUncheckedCreateWithoutMedicationLogsInput>
  }

  export type PatientUpsertWithoutMedicationLogsInput = {
    update: XOR<PatientUpdateWithoutMedicationLogsInput, PatientUncheckedUpdateWithoutMedicationLogsInput>
    create: XOR<PatientCreateWithoutMedicationLogsInput, PatientUncheckedCreateWithoutMedicationLogsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutMedicationLogsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutMedicationLogsInput, PatientUncheckedUpdateWithoutMedicationLogsInput>
  }

  export type PatientUpdateWithoutMedicationLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surgeryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surgeryType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPatientNestedInput
    clinic?: ClinicUpdateOneRequiredWithoutPatientsNestedInput
    contentAdjustments?: PatientContentAdjustmentUpdateManyWithoutPatientNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    chatConversations?: ChatConversationUpdateManyWithoutPatientNestedInput
    exams?: ExamUpdateManyWithoutPatientNestedInput
    trainingProgress?: PatientTrainingProgressUpdateManyWithoutPatientNestedInput
    sessionCompletions?: PatientSessionCompletionUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutMedicationLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surgeryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surgeryType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contentAdjustments?: PatientContentAdjustmentUncheckedUpdateManyWithoutPatientNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    chatConversations?: ChatConversationUncheckedUpdateManyWithoutPatientNestedInput
    exams?: ExamUncheckedUpdateManyWithoutPatientNestedInput
    trainingProgress?: PatientTrainingProgressUncheckedUpdateManyWithoutPatientNestedInput
    sessionCompletions?: PatientSessionCompletionUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientCreateWithoutExamsInput = {
    id?: string
    cpf?: string | null
    phone?: string | null
    birthDate?: Date | string | null
    surgeryDate?: Date | string | null
    surgeryType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPatientInput
    clinic: ClinicCreateNestedOneWithoutPatientsInput
    contentAdjustments?: PatientContentAdjustmentCreateNestedManyWithoutPatientInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    medicationLogs?: MedicationLogCreateNestedManyWithoutPatientInput
    chatConversations?: ChatConversationCreateNestedManyWithoutPatientInput
    trainingProgress?: PatientTrainingProgressCreateNestedManyWithoutPatientInput
    sessionCompletions?: PatientSessionCompletionCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutExamsInput = {
    id?: string
    userId: string
    clinicId: string
    cpf?: string | null
    phone?: string | null
    birthDate?: Date | string | null
    surgeryDate?: Date | string | null
    surgeryType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contentAdjustments?: PatientContentAdjustmentUncheckedCreateNestedManyWithoutPatientInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    medicationLogs?: MedicationLogUncheckedCreateNestedManyWithoutPatientInput
    chatConversations?: ChatConversationUncheckedCreateNestedManyWithoutPatientInput
    trainingProgress?: PatientTrainingProgressUncheckedCreateNestedManyWithoutPatientInput
    sessionCompletions?: PatientSessionCompletionUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutExamsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutExamsInput, PatientUncheckedCreateWithoutExamsInput>
  }

  export type PatientUpsertWithoutExamsInput = {
    update: XOR<PatientUpdateWithoutExamsInput, PatientUncheckedUpdateWithoutExamsInput>
    create: XOR<PatientCreateWithoutExamsInput, PatientUncheckedCreateWithoutExamsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutExamsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutExamsInput, PatientUncheckedUpdateWithoutExamsInput>
  }

  export type PatientUpdateWithoutExamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surgeryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surgeryType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPatientNestedInput
    clinic?: ClinicUpdateOneRequiredWithoutPatientsNestedInput
    contentAdjustments?: PatientContentAdjustmentUpdateManyWithoutPatientNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    medicationLogs?: MedicationLogUpdateManyWithoutPatientNestedInput
    chatConversations?: ChatConversationUpdateManyWithoutPatientNestedInput
    trainingProgress?: PatientTrainingProgressUpdateManyWithoutPatientNestedInput
    sessionCompletions?: PatientSessionCompletionUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutExamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surgeryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surgeryType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contentAdjustments?: PatientContentAdjustmentUncheckedUpdateManyWithoutPatientNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    medicationLogs?: MedicationLogUncheckedUpdateManyWithoutPatientNestedInput
    chatConversations?: ChatConversationUncheckedUpdateManyWithoutPatientNestedInput
    trainingProgress?: PatientTrainingProgressUncheckedUpdateManyWithoutPatientNestedInput
    sessionCompletions?: PatientSessionCompletionUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type ClinicCreateWithoutContentsInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    logoUrl?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutClinicInput
    patients?: PatientCreateNestedManyWithoutClinicInput
    trainingProtocols?: TrainingProtocolCreateNestedManyWithoutClinicInput
  }

  export type ClinicUncheckedCreateWithoutContentsInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    logoUrl?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutClinicInput
    patients?: PatientUncheckedCreateNestedManyWithoutClinicInput
    trainingProtocols?: TrainingProtocolUncheckedCreateNestedManyWithoutClinicInput
  }

  export type ClinicCreateOrConnectWithoutContentsInput = {
    where: ClinicWhereUniqueInput
    create: XOR<ClinicCreateWithoutContentsInput, ClinicUncheckedCreateWithoutContentsInput>
  }

  export type PatientContentAdjustmentCreateWithoutBaseContentInput = {
    id?: string
    adjustmentType: $Enums.AdjustmentType
    contentType?: $Enums.ContentType | null
    category?: $Enums.ContentCategory | null
    title?: string | null
    description?: string | null
    validFromDay?: number | null
    validUntilDay?: number | null
    reason?: string | null
    isActive?: boolean
    createdBy?: string | null
    createdAt?: Date | string
    patient: PatientCreateNestedOneWithoutContentAdjustmentsInput
  }

  export type PatientContentAdjustmentUncheckedCreateWithoutBaseContentInput = {
    id?: string
    patientId: string
    adjustmentType: $Enums.AdjustmentType
    contentType?: $Enums.ContentType | null
    category?: $Enums.ContentCategory | null
    title?: string | null
    description?: string | null
    validFromDay?: number | null
    validUntilDay?: number | null
    reason?: string | null
    isActive?: boolean
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type PatientContentAdjustmentCreateOrConnectWithoutBaseContentInput = {
    where: PatientContentAdjustmentWhereUniqueInput
    create: XOR<PatientContentAdjustmentCreateWithoutBaseContentInput, PatientContentAdjustmentUncheckedCreateWithoutBaseContentInput>
  }

  export type PatientContentAdjustmentCreateManyBaseContentInputEnvelope = {
    data: PatientContentAdjustmentCreateManyBaseContentInput | PatientContentAdjustmentCreateManyBaseContentInput[]
    skipDuplicates?: boolean
  }

  export type ClinicUpsertWithoutContentsInput = {
    update: XOR<ClinicUpdateWithoutContentsInput, ClinicUncheckedUpdateWithoutContentsInput>
    create: XOR<ClinicCreateWithoutContentsInput, ClinicUncheckedCreateWithoutContentsInput>
    where?: ClinicWhereInput
  }

  export type ClinicUpdateToOneWithWhereWithoutContentsInput = {
    where?: ClinicWhereInput
    data: XOR<ClinicUpdateWithoutContentsInput, ClinicUncheckedUpdateWithoutContentsInput>
  }

  export type ClinicUpdateWithoutContentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutClinicNestedInput
    patients?: PatientUpdateManyWithoutClinicNestedInput
    trainingProtocols?: TrainingProtocolUpdateManyWithoutClinicNestedInput
  }

  export type ClinicUncheckedUpdateWithoutContentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutClinicNestedInput
    patients?: PatientUncheckedUpdateManyWithoutClinicNestedInput
    trainingProtocols?: TrainingProtocolUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type PatientContentAdjustmentUpsertWithWhereUniqueWithoutBaseContentInput = {
    where: PatientContentAdjustmentWhereUniqueInput
    update: XOR<PatientContentAdjustmentUpdateWithoutBaseContentInput, PatientContentAdjustmentUncheckedUpdateWithoutBaseContentInput>
    create: XOR<PatientContentAdjustmentCreateWithoutBaseContentInput, PatientContentAdjustmentUncheckedCreateWithoutBaseContentInput>
  }

  export type PatientContentAdjustmentUpdateWithWhereUniqueWithoutBaseContentInput = {
    where: PatientContentAdjustmentWhereUniqueInput
    data: XOR<PatientContentAdjustmentUpdateWithoutBaseContentInput, PatientContentAdjustmentUncheckedUpdateWithoutBaseContentInput>
  }

  export type PatientContentAdjustmentUpdateManyWithWhereWithoutBaseContentInput = {
    where: PatientContentAdjustmentScalarWhereInput
    data: XOR<PatientContentAdjustmentUpdateManyMutationInput, PatientContentAdjustmentUncheckedUpdateManyWithoutBaseContentInput>
  }

  export type PatientCreateWithoutContentAdjustmentsInput = {
    id?: string
    cpf?: string | null
    phone?: string | null
    birthDate?: Date | string | null
    surgeryDate?: Date | string | null
    surgeryType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPatientInput
    clinic: ClinicCreateNestedOneWithoutPatientsInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    medicationLogs?: MedicationLogCreateNestedManyWithoutPatientInput
    chatConversations?: ChatConversationCreateNestedManyWithoutPatientInput
    exams?: ExamCreateNestedManyWithoutPatientInput
    trainingProgress?: PatientTrainingProgressCreateNestedManyWithoutPatientInput
    sessionCompletions?: PatientSessionCompletionCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutContentAdjustmentsInput = {
    id?: string
    userId: string
    clinicId: string
    cpf?: string | null
    phone?: string | null
    birthDate?: Date | string | null
    surgeryDate?: Date | string | null
    surgeryType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    medicationLogs?: MedicationLogUncheckedCreateNestedManyWithoutPatientInput
    chatConversations?: ChatConversationUncheckedCreateNestedManyWithoutPatientInput
    exams?: ExamUncheckedCreateNestedManyWithoutPatientInput
    trainingProgress?: PatientTrainingProgressUncheckedCreateNestedManyWithoutPatientInput
    sessionCompletions?: PatientSessionCompletionUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutContentAdjustmentsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutContentAdjustmentsInput, PatientUncheckedCreateWithoutContentAdjustmentsInput>
  }

  export type ClinicContentCreateWithoutPatientAdjustmentsInput = {
    id?: string
    templateId?: string | null
    type: $Enums.ContentType
    category: $Enums.ContentCategory
    title: string
    description?: string | null
    validFromDay?: number | null
    validUntilDay?: number | null
    sortOrder?: number
    isActive?: boolean
    isCustom?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic: ClinicCreateNestedOneWithoutContentsInput
  }

  export type ClinicContentUncheckedCreateWithoutPatientAdjustmentsInput = {
    id?: string
    clinicId: string
    templateId?: string | null
    type: $Enums.ContentType
    category: $Enums.ContentCategory
    title: string
    description?: string | null
    validFromDay?: number | null
    validUntilDay?: number | null
    sortOrder?: number
    isActive?: boolean
    isCustom?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClinicContentCreateOrConnectWithoutPatientAdjustmentsInput = {
    where: ClinicContentWhereUniqueInput
    create: XOR<ClinicContentCreateWithoutPatientAdjustmentsInput, ClinicContentUncheckedCreateWithoutPatientAdjustmentsInput>
  }

  export type PatientUpsertWithoutContentAdjustmentsInput = {
    update: XOR<PatientUpdateWithoutContentAdjustmentsInput, PatientUncheckedUpdateWithoutContentAdjustmentsInput>
    create: XOR<PatientCreateWithoutContentAdjustmentsInput, PatientUncheckedCreateWithoutContentAdjustmentsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutContentAdjustmentsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutContentAdjustmentsInput, PatientUncheckedUpdateWithoutContentAdjustmentsInput>
  }

  export type PatientUpdateWithoutContentAdjustmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surgeryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surgeryType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPatientNestedInput
    clinic?: ClinicUpdateOneRequiredWithoutPatientsNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    medicationLogs?: MedicationLogUpdateManyWithoutPatientNestedInput
    chatConversations?: ChatConversationUpdateManyWithoutPatientNestedInput
    exams?: ExamUpdateManyWithoutPatientNestedInput
    trainingProgress?: PatientTrainingProgressUpdateManyWithoutPatientNestedInput
    sessionCompletions?: PatientSessionCompletionUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutContentAdjustmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surgeryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surgeryType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    medicationLogs?: MedicationLogUncheckedUpdateManyWithoutPatientNestedInput
    chatConversations?: ChatConversationUncheckedUpdateManyWithoutPatientNestedInput
    exams?: ExamUncheckedUpdateManyWithoutPatientNestedInput
    trainingProgress?: PatientTrainingProgressUncheckedUpdateManyWithoutPatientNestedInput
    sessionCompletions?: PatientSessionCompletionUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type ClinicContentUpsertWithoutPatientAdjustmentsInput = {
    update: XOR<ClinicContentUpdateWithoutPatientAdjustmentsInput, ClinicContentUncheckedUpdateWithoutPatientAdjustmentsInput>
    create: XOR<ClinicContentCreateWithoutPatientAdjustmentsInput, ClinicContentUncheckedCreateWithoutPatientAdjustmentsInput>
    where?: ClinicContentWhereInput
  }

  export type ClinicContentUpdateToOneWithWhereWithoutPatientAdjustmentsInput = {
    where?: ClinicContentWhereInput
    data: XOR<ClinicContentUpdateWithoutPatientAdjustmentsInput, ClinicContentUncheckedUpdateWithoutPatientAdjustmentsInput>
  }

  export type ClinicContentUpdateWithoutPatientAdjustmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    category?: EnumContentCategoryFieldUpdateOperationsInput | $Enums.ContentCategory
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    validFromDay?: NullableIntFieldUpdateOperationsInput | number | null
    validUntilDay?: NullableIntFieldUpdateOperationsInput | number | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isCustom?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneRequiredWithoutContentsNestedInput
  }

  export type ClinicContentUncheckedUpdateWithoutPatientAdjustmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    category?: EnumContentCategoryFieldUpdateOperationsInput | $Enums.ContentCategory
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    validFromDay?: NullableIntFieldUpdateOperationsInput | number | null
    validUntilDay?: NullableIntFieldUpdateOperationsInput | number | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isCustom?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicCreateWithoutTrainingProtocolsInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    logoUrl?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserCreateNestedManyWithoutClinicInput
    patients?: PatientCreateNestedManyWithoutClinicInput
    contents?: ClinicContentCreateNestedManyWithoutClinicInput
  }

  export type ClinicUncheckedCreateWithoutTrainingProtocolsInput = {
    id?: string
    name: string
    email?: string | null
    phone?: string | null
    address?: string | null
    logoUrl?: string | null
    primaryColor?: string | null
    secondaryColor?: string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    users?: UserUncheckedCreateNestedManyWithoutClinicInput
    patients?: PatientUncheckedCreateNestedManyWithoutClinicInput
    contents?: ClinicContentUncheckedCreateNestedManyWithoutClinicInput
  }

  export type ClinicCreateOrConnectWithoutTrainingProtocolsInput = {
    where: ClinicWhereUniqueInput
    create: XOR<ClinicCreateWithoutTrainingProtocolsInput, ClinicUncheckedCreateWithoutTrainingProtocolsInput>
  }

  export type TrainingWeekCreateWithoutProtocolInput = {
    id?: string
    weekNumber: number
    title: string
    dayRange: string
    objective: string
    maxHeartRate?: number | null
    heartRateLabel?: string | null
    canDo?: TrainingWeekCreatecanDoInput | string[]
    avoid?: TrainingWeekCreateavoidInput | string[]
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: TrainingSessionCreateNestedManyWithoutWeekInput
    progress?: PatientTrainingProgressCreateNestedManyWithoutWeekInput
  }

  export type TrainingWeekUncheckedCreateWithoutProtocolInput = {
    id?: string
    weekNumber: number
    title: string
    dayRange: string
    objective: string
    maxHeartRate?: number | null
    heartRateLabel?: string | null
    canDo?: TrainingWeekCreatecanDoInput | string[]
    avoid?: TrainingWeekCreateavoidInput | string[]
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: TrainingSessionUncheckedCreateNestedManyWithoutWeekInput
    progress?: PatientTrainingProgressUncheckedCreateNestedManyWithoutWeekInput
  }

  export type TrainingWeekCreateOrConnectWithoutProtocolInput = {
    where: TrainingWeekWhereUniqueInput
    create: XOR<TrainingWeekCreateWithoutProtocolInput, TrainingWeekUncheckedCreateWithoutProtocolInput>
  }

  export type TrainingWeekCreateManyProtocolInputEnvelope = {
    data: TrainingWeekCreateManyProtocolInput | TrainingWeekCreateManyProtocolInput[]
    skipDuplicates?: boolean
  }

  export type ClinicUpsertWithoutTrainingProtocolsInput = {
    update: XOR<ClinicUpdateWithoutTrainingProtocolsInput, ClinicUncheckedUpdateWithoutTrainingProtocolsInput>
    create: XOR<ClinicCreateWithoutTrainingProtocolsInput, ClinicUncheckedCreateWithoutTrainingProtocolsInput>
    where?: ClinicWhereInput
  }

  export type ClinicUpdateToOneWithWhereWithoutTrainingProtocolsInput = {
    where?: ClinicWhereInput
    data: XOR<ClinicUpdateWithoutTrainingProtocolsInput, ClinicUncheckedUpdateWithoutTrainingProtocolsInput>
  }

  export type ClinicUpdateWithoutTrainingProtocolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUpdateManyWithoutClinicNestedInput
    patients?: PatientUpdateManyWithoutClinicNestedInput
    contents?: ClinicContentUpdateManyWithoutClinicNestedInput
  }

  export type ClinicUncheckedUpdateWithoutTrainingProtocolsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    logoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    primaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    secondaryColor?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    users?: UserUncheckedUpdateManyWithoutClinicNestedInput
    patients?: PatientUncheckedUpdateManyWithoutClinicNestedInput
    contents?: ClinicContentUncheckedUpdateManyWithoutClinicNestedInput
  }

  export type TrainingWeekUpsertWithWhereUniqueWithoutProtocolInput = {
    where: TrainingWeekWhereUniqueInput
    update: XOR<TrainingWeekUpdateWithoutProtocolInput, TrainingWeekUncheckedUpdateWithoutProtocolInput>
    create: XOR<TrainingWeekCreateWithoutProtocolInput, TrainingWeekUncheckedCreateWithoutProtocolInput>
  }

  export type TrainingWeekUpdateWithWhereUniqueWithoutProtocolInput = {
    where: TrainingWeekWhereUniqueInput
    data: XOR<TrainingWeekUpdateWithoutProtocolInput, TrainingWeekUncheckedUpdateWithoutProtocolInput>
  }

  export type TrainingWeekUpdateManyWithWhereWithoutProtocolInput = {
    where: TrainingWeekScalarWhereInput
    data: XOR<TrainingWeekUpdateManyMutationInput, TrainingWeekUncheckedUpdateManyWithoutProtocolInput>
  }

  export type TrainingWeekScalarWhereInput = {
    AND?: TrainingWeekScalarWhereInput | TrainingWeekScalarWhereInput[]
    OR?: TrainingWeekScalarWhereInput[]
    NOT?: TrainingWeekScalarWhereInput | TrainingWeekScalarWhereInput[]
    id?: StringFilter<"TrainingWeek"> | string
    protocolId?: StringFilter<"TrainingWeek"> | string
    weekNumber?: IntFilter<"TrainingWeek"> | number
    title?: StringFilter<"TrainingWeek"> | string
    dayRange?: StringFilter<"TrainingWeek"> | string
    objective?: StringFilter<"TrainingWeek"> | string
    maxHeartRate?: IntNullableFilter<"TrainingWeek"> | number | null
    heartRateLabel?: StringNullableFilter<"TrainingWeek"> | string | null
    canDo?: StringNullableListFilter<"TrainingWeek">
    avoid?: StringNullableListFilter<"TrainingWeek">
    sortOrder?: IntFilter<"TrainingWeek"> | number
    createdAt?: DateTimeFilter<"TrainingWeek"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingWeek"> | Date | string
  }

  export type TrainingProtocolCreateWithoutWeeksInput = {
    id?: string
    name: string
    surgeryType?: string | null
    description?: string | null
    totalWeeks?: number
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    clinic?: ClinicCreateNestedOneWithoutTrainingProtocolsInput
  }

  export type TrainingProtocolUncheckedCreateWithoutWeeksInput = {
    id?: string
    clinicId?: string | null
    name: string
    surgeryType?: string | null
    description?: string | null
    totalWeeks?: number
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingProtocolCreateOrConnectWithoutWeeksInput = {
    where: TrainingProtocolWhereUniqueInput
    create: XOR<TrainingProtocolCreateWithoutWeeksInput, TrainingProtocolUncheckedCreateWithoutWeeksInput>
  }

  export type TrainingSessionCreateWithoutWeekInput = {
    id?: string
    sessionNumber: number
    name: string
    description?: string | null
    duration?: number | null
    intensity?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    completions?: PatientSessionCompletionCreateNestedManyWithoutSessionInput
  }

  export type TrainingSessionUncheckedCreateWithoutWeekInput = {
    id?: string
    sessionNumber: number
    name: string
    description?: string | null
    duration?: number | null
    intensity?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    completions?: PatientSessionCompletionUncheckedCreateNestedManyWithoutSessionInput
  }

  export type TrainingSessionCreateOrConnectWithoutWeekInput = {
    where: TrainingSessionWhereUniqueInput
    create: XOR<TrainingSessionCreateWithoutWeekInput, TrainingSessionUncheckedCreateWithoutWeekInput>
  }

  export type TrainingSessionCreateManyWeekInputEnvelope = {
    data: TrainingSessionCreateManyWeekInput | TrainingSessionCreateManyWeekInput[]
    skipDuplicates?: boolean
  }

  export type PatientTrainingProgressCreateWithoutWeekInput = {
    id?: string
    status?: $Enums.TrainingWeekStatus
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutTrainingProgressInput
  }

  export type PatientTrainingProgressUncheckedCreateWithoutWeekInput = {
    id?: string
    patientId: string
    status?: $Enums.TrainingWeekStatus
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatientTrainingProgressCreateOrConnectWithoutWeekInput = {
    where: PatientTrainingProgressWhereUniqueInput
    create: XOR<PatientTrainingProgressCreateWithoutWeekInput, PatientTrainingProgressUncheckedCreateWithoutWeekInput>
  }

  export type PatientTrainingProgressCreateManyWeekInputEnvelope = {
    data: PatientTrainingProgressCreateManyWeekInput | PatientTrainingProgressCreateManyWeekInput[]
    skipDuplicates?: boolean
  }

  export type TrainingProtocolUpsertWithoutWeeksInput = {
    update: XOR<TrainingProtocolUpdateWithoutWeeksInput, TrainingProtocolUncheckedUpdateWithoutWeeksInput>
    create: XOR<TrainingProtocolCreateWithoutWeeksInput, TrainingProtocolUncheckedCreateWithoutWeeksInput>
    where?: TrainingProtocolWhereInput
  }

  export type TrainingProtocolUpdateToOneWithWhereWithoutWeeksInput = {
    where?: TrainingProtocolWhereInput
    data: XOR<TrainingProtocolUpdateWithoutWeeksInput, TrainingProtocolUncheckedUpdateWithoutWeeksInput>
  }

  export type TrainingProtocolUpdateWithoutWeeksInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    surgeryType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalWeeks?: IntFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    clinic?: ClinicUpdateOneWithoutTrainingProtocolsNestedInput
  }

  export type TrainingProtocolUncheckedUpdateWithoutWeeksInput = {
    id?: StringFieldUpdateOperationsInput | string
    clinicId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    surgeryType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalWeeks?: IntFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingSessionUpsertWithWhereUniqueWithoutWeekInput = {
    where: TrainingSessionWhereUniqueInput
    update: XOR<TrainingSessionUpdateWithoutWeekInput, TrainingSessionUncheckedUpdateWithoutWeekInput>
    create: XOR<TrainingSessionCreateWithoutWeekInput, TrainingSessionUncheckedCreateWithoutWeekInput>
  }

  export type TrainingSessionUpdateWithWhereUniqueWithoutWeekInput = {
    where: TrainingSessionWhereUniqueInput
    data: XOR<TrainingSessionUpdateWithoutWeekInput, TrainingSessionUncheckedUpdateWithoutWeekInput>
  }

  export type TrainingSessionUpdateManyWithWhereWithoutWeekInput = {
    where: TrainingSessionScalarWhereInput
    data: XOR<TrainingSessionUpdateManyMutationInput, TrainingSessionUncheckedUpdateManyWithoutWeekInput>
  }

  export type TrainingSessionScalarWhereInput = {
    AND?: TrainingSessionScalarWhereInput | TrainingSessionScalarWhereInput[]
    OR?: TrainingSessionScalarWhereInput[]
    NOT?: TrainingSessionScalarWhereInput | TrainingSessionScalarWhereInput[]
    id?: StringFilter<"TrainingSession"> | string
    weekId?: StringFilter<"TrainingSession"> | string
    sessionNumber?: IntFilter<"TrainingSession"> | number
    name?: StringFilter<"TrainingSession"> | string
    description?: StringNullableFilter<"TrainingSession"> | string | null
    duration?: IntNullableFilter<"TrainingSession"> | number | null
    intensity?: StringNullableFilter<"TrainingSession"> | string | null
    sortOrder?: IntFilter<"TrainingSession"> | number
    createdAt?: DateTimeFilter<"TrainingSession"> | Date | string
    updatedAt?: DateTimeFilter<"TrainingSession"> | Date | string
  }

  export type PatientTrainingProgressUpsertWithWhereUniqueWithoutWeekInput = {
    where: PatientTrainingProgressWhereUniqueInput
    update: XOR<PatientTrainingProgressUpdateWithoutWeekInput, PatientTrainingProgressUncheckedUpdateWithoutWeekInput>
    create: XOR<PatientTrainingProgressCreateWithoutWeekInput, PatientTrainingProgressUncheckedCreateWithoutWeekInput>
  }

  export type PatientTrainingProgressUpdateWithWhereUniqueWithoutWeekInput = {
    where: PatientTrainingProgressWhereUniqueInput
    data: XOR<PatientTrainingProgressUpdateWithoutWeekInput, PatientTrainingProgressUncheckedUpdateWithoutWeekInput>
  }

  export type PatientTrainingProgressUpdateManyWithWhereWithoutWeekInput = {
    where: PatientTrainingProgressScalarWhereInput
    data: XOR<PatientTrainingProgressUpdateManyMutationInput, PatientTrainingProgressUncheckedUpdateManyWithoutWeekInput>
  }

  export type TrainingWeekCreateWithoutSessionsInput = {
    id?: string
    weekNumber: number
    title: string
    dayRange: string
    objective: string
    maxHeartRate?: number | null
    heartRateLabel?: string | null
    canDo?: TrainingWeekCreatecanDoInput | string[]
    avoid?: TrainingWeekCreateavoidInput | string[]
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    protocol: TrainingProtocolCreateNestedOneWithoutWeeksInput
    progress?: PatientTrainingProgressCreateNestedManyWithoutWeekInput
  }

  export type TrainingWeekUncheckedCreateWithoutSessionsInput = {
    id?: string
    protocolId: string
    weekNumber: number
    title: string
    dayRange: string
    objective: string
    maxHeartRate?: number | null
    heartRateLabel?: string | null
    canDo?: TrainingWeekCreatecanDoInput | string[]
    avoid?: TrainingWeekCreateavoidInput | string[]
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    progress?: PatientTrainingProgressUncheckedCreateNestedManyWithoutWeekInput
  }

  export type TrainingWeekCreateOrConnectWithoutSessionsInput = {
    where: TrainingWeekWhereUniqueInput
    create: XOR<TrainingWeekCreateWithoutSessionsInput, TrainingWeekUncheckedCreateWithoutSessionsInput>
  }

  export type PatientSessionCompletionCreateWithoutSessionInput = {
    id?: string
    completedAt?: Date | string
    notes?: string | null
    patient: PatientCreateNestedOneWithoutSessionCompletionsInput
  }

  export type PatientSessionCompletionUncheckedCreateWithoutSessionInput = {
    id?: string
    patientId: string
    completedAt?: Date | string
    notes?: string | null
  }

  export type PatientSessionCompletionCreateOrConnectWithoutSessionInput = {
    where: PatientSessionCompletionWhereUniqueInput
    create: XOR<PatientSessionCompletionCreateWithoutSessionInput, PatientSessionCompletionUncheckedCreateWithoutSessionInput>
  }

  export type PatientSessionCompletionCreateManySessionInputEnvelope = {
    data: PatientSessionCompletionCreateManySessionInput | PatientSessionCompletionCreateManySessionInput[]
    skipDuplicates?: boolean
  }

  export type TrainingWeekUpsertWithoutSessionsInput = {
    update: XOR<TrainingWeekUpdateWithoutSessionsInput, TrainingWeekUncheckedUpdateWithoutSessionsInput>
    create: XOR<TrainingWeekCreateWithoutSessionsInput, TrainingWeekUncheckedCreateWithoutSessionsInput>
    where?: TrainingWeekWhereInput
  }

  export type TrainingWeekUpdateToOneWithWhereWithoutSessionsInput = {
    where?: TrainingWeekWhereInput
    data: XOR<TrainingWeekUpdateWithoutSessionsInput, TrainingWeekUncheckedUpdateWithoutSessionsInput>
  }

  export type TrainingWeekUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    dayRange?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    maxHeartRate?: NullableIntFieldUpdateOperationsInput | number | null
    heartRateLabel?: NullableStringFieldUpdateOperationsInput | string | null
    canDo?: TrainingWeekUpdatecanDoInput | string[]
    avoid?: TrainingWeekUpdateavoidInput | string[]
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    protocol?: TrainingProtocolUpdateOneRequiredWithoutWeeksNestedInput
    progress?: PatientTrainingProgressUpdateManyWithoutWeekNestedInput
  }

  export type TrainingWeekUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    protocolId?: StringFieldUpdateOperationsInput | string
    weekNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    dayRange?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    maxHeartRate?: NullableIntFieldUpdateOperationsInput | number | null
    heartRateLabel?: NullableStringFieldUpdateOperationsInput | string | null
    canDo?: TrainingWeekUpdatecanDoInput | string[]
    avoid?: TrainingWeekUpdateavoidInput | string[]
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    progress?: PatientTrainingProgressUncheckedUpdateManyWithoutWeekNestedInput
  }

  export type PatientSessionCompletionUpsertWithWhereUniqueWithoutSessionInput = {
    where: PatientSessionCompletionWhereUniqueInput
    update: XOR<PatientSessionCompletionUpdateWithoutSessionInput, PatientSessionCompletionUncheckedUpdateWithoutSessionInput>
    create: XOR<PatientSessionCompletionCreateWithoutSessionInput, PatientSessionCompletionUncheckedCreateWithoutSessionInput>
  }

  export type PatientSessionCompletionUpdateWithWhereUniqueWithoutSessionInput = {
    where: PatientSessionCompletionWhereUniqueInput
    data: XOR<PatientSessionCompletionUpdateWithoutSessionInput, PatientSessionCompletionUncheckedUpdateWithoutSessionInput>
  }

  export type PatientSessionCompletionUpdateManyWithWhereWithoutSessionInput = {
    where: PatientSessionCompletionScalarWhereInput
    data: XOR<PatientSessionCompletionUpdateManyMutationInput, PatientSessionCompletionUncheckedUpdateManyWithoutSessionInput>
  }

  export type PatientCreateWithoutTrainingProgressInput = {
    id?: string
    cpf?: string | null
    phone?: string | null
    birthDate?: Date | string | null
    surgeryDate?: Date | string | null
    surgeryType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPatientInput
    clinic: ClinicCreateNestedOneWithoutPatientsInput
    contentAdjustments?: PatientContentAdjustmentCreateNestedManyWithoutPatientInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    medicationLogs?: MedicationLogCreateNestedManyWithoutPatientInput
    chatConversations?: ChatConversationCreateNestedManyWithoutPatientInput
    exams?: ExamCreateNestedManyWithoutPatientInput
    sessionCompletions?: PatientSessionCompletionCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutTrainingProgressInput = {
    id?: string
    userId: string
    clinicId: string
    cpf?: string | null
    phone?: string | null
    birthDate?: Date | string | null
    surgeryDate?: Date | string | null
    surgeryType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contentAdjustments?: PatientContentAdjustmentUncheckedCreateNestedManyWithoutPatientInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    medicationLogs?: MedicationLogUncheckedCreateNestedManyWithoutPatientInput
    chatConversations?: ChatConversationUncheckedCreateNestedManyWithoutPatientInput
    exams?: ExamUncheckedCreateNestedManyWithoutPatientInput
    sessionCompletions?: PatientSessionCompletionUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutTrainingProgressInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutTrainingProgressInput, PatientUncheckedCreateWithoutTrainingProgressInput>
  }

  export type TrainingWeekCreateWithoutProgressInput = {
    id?: string
    weekNumber: number
    title: string
    dayRange: string
    objective: string
    maxHeartRate?: number | null
    heartRateLabel?: string | null
    canDo?: TrainingWeekCreatecanDoInput | string[]
    avoid?: TrainingWeekCreateavoidInput | string[]
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    protocol: TrainingProtocolCreateNestedOneWithoutWeeksInput
    sessions?: TrainingSessionCreateNestedManyWithoutWeekInput
  }

  export type TrainingWeekUncheckedCreateWithoutProgressInput = {
    id?: string
    protocolId: string
    weekNumber: number
    title: string
    dayRange: string
    objective: string
    maxHeartRate?: number | null
    heartRateLabel?: string | null
    canDo?: TrainingWeekCreatecanDoInput | string[]
    avoid?: TrainingWeekCreateavoidInput | string[]
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    sessions?: TrainingSessionUncheckedCreateNestedManyWithoutWeekInput
  }

  export type TrainingWeekCreateOrConnectWithoutProgressInput = {
    where: TrainingWeekWhereUniqueInput
    create: XOR<TrainingWeekCreateWithoutProgressInput, TrainingWeekUncheckedCreateWithoutProgressInput>
  }

  export type PatientUpsertWithoutTrainingProgressInput = {
    update: XOR<PatientUpdateWithoutTrainingProgressInput, PatientUncheckedUpdateWithoutTrainingProgressInput>
    create: XOR<PatientCreateWithoutTrainingProgressInput, PatientUncheckedCreateWithoutTrainingProgressInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutTrainingProgressInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutTrainingProgressInput, PatientUncheckedUpdateWithoutTrainingProgressInput>
  }

  export type PatientUpdateWithoutTrainingProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surgeryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surgeryType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPatientNestedInput
    clinic?: ClinicUpdateOneRequiredWithoutPatientsNestedInput
    contentAdjustments?: PatientContentAdjustmentUpdateManyWithoutPatientNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    medicationLogs?: MedicationLogUpdateManyWithoutPatientNestedInput
    chatConversations?: ChatConversationUpdateManyWithoutPatientNestedInput
    exams?: ExamUpdateManyWithoutPatientNestedInput
    sessionCompletions?: PatientSessionCompletionUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutTrainingProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surgeryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surgeryType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contentAdjustments?: PatientContentAdjustmentUncheckedUpdateManyWithoutPatientNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    medicationLogs?: MedicationLogUncheckedUpdateManyWithoutPatientNestedInput
    chatConversations?: ChatConversationUncheckedUpdateManyWithoutPatientNestedInput
    exams?: ExamUncheckedUpdateManyWithoutPatientNestedInput
    sessionCompletions?: PatientSessionCompletionUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type TrainingWeekUpsertWithoutProgressInput = {
    update: XOR<TrainingWeekUpdateWithoutProgressInput, TrainingWeekUncheckedUpdateWithoutProgressInput>
    create: XOR<TrainingWeekCreateWithoutProgressInput, TrainingWeekUncheckedCreateWithoutProgressInput>
    where?: TrainingWeekWhereInput
  }

  export type TrainingWeekUpdateToOneWithWhereWithoutProgressInput = {
    where?: TrainingWeekWhereInput
    data: XOR<TrainingWeekUpdateWithoutProgressInput, TrainingWeekUncheckedUpdateWithoutProgressInput>
  }

  export type TrainingWeekUpdateWithoutProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    dayRange?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    maxHeartRate?: NullableIntFieldUpdateOperationsInput | number | null
    heartRateLabel?: NullableStringFieldUpdateOperationsInput | string | null
    canDo?: TrainingWeekUpdatecanDoInput | string[]
    avoid?: TrainingWeekUpdateavoidInput | string[]
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    protocol?: TrainingProtocolUpdateOneRequiredWithoutWeeksNestedInput
    sessions?: TrainingSessionUpdateManyWithoutWeekNestedInput
  }

  export type TrainingWeekUncheckedUpdateWithoutProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    protocolId?: StringFieldUpdateOperationsInput | string
    weekNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    dayRange?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    maxHeartRate?: NullableIntFieldUpdateOperationsInput | number | null
    heartRateLabel?: NullableStringFieldUpdateOperationsInput | string | null
    canDo?: TrainingWeekUpdatecanDoInput | string[]
    avoid?: TrainingWeekUpdateavoidInput | string[]
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: TrainingSessionUncheckedUpdateManyWithoutWeekNestedInput
  }

  export type PatientCreateWithoutSessionCompletionsInput = {
    id?: string
    cpf?: string | null
    phone?: string | null
    birthDate?: Date | string | null
    surgeryDate?: Date | string | null
    surgeryType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPatientInput
    clinic: ClinicCreateNestedOneWithoutPatientsInput
    contentAdjustments?: PatientContentAdjustmentCreateNestedManyWithoutPatientInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    medicationLogs?: MedicationLogCreateNestedManyWithoutPatientInput
    chatConversations?: ChatConversationCreateNestedManyWithoutPatientInput
    exams?: ExamCreateNestedManyWithoutPatientInput
    trainingProgress?: PatientTrainingProgressCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutSessionCompletionsInput = {
    id?: string
    userId: string
    clinicId: string
    cpf?: string | null
    phone?: string | null
    birthDate?: Date | string | null
    surgeryDate?: Date | string | null
    surgeryType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contentAdjustments?: PatientContentAdjustmentUncheckedCreateNestedManyWithoutPatientInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    medicationLogs?: MedicationLogUncheckedCreateNestedManyWithoutPatientInput
    chatConversations?: ChatConversationUncheckedCreateNestedManyWithoutPatientInput
    exams?: ExamUncheckedCreateNestedManyWithoutPatientInput
    trainingProgress?: PatientTrainingProgressUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutSessionCompletionsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutSessionCompletionsInput, PatientUncheckedCreateWithoutSessionCompletionsInput>
  }

  export type TrainingSessionCreateWithoutCompletionsInput = {
    id?: string
    sessionNumber: number
    name: string
    description?: string | null
    duration?: number | null
    intensity?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    week: TrainingWeekCreateNestedOneWithoutSessionsInput
  }

  export type TrainingSessionUncheckedCreateWithoutCompletionsInput = {
    id?: string
    weekId: string
    sessionNumber: number
    name: string
    description?: string | null
    duration?: number | null
    intensity?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingSessionCreateOrConnectWithoutCompletionsInput = {
    where: TrainingSessionWhereUniqueInput
    create: XOR<TrainingSessionCreateWithoutCompletionsInput, TrainingSessionUncheckedCreateWithoutCompletionsInput>
  }

  export type PatientUpsertWithoutSessionCompletionsInput = {
    update: XOR<PatientUpdateWithoutSessionCompletionsInput, PatientUncheckedUpdateWithoutSessionCompletionsInput>
    create: XOR<PatientCreateWithoutSessionCompletionsInput, PatientUncheckedCreateWithoutSessionCompletionsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutSessionCompletionsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutSessionCompletionsInput, PatientUncheckedUpdateWithoutSessionCompletionsInput>
  }

  export type PatientUpdateWithoutSessionCompletionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surgeryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surgeryType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPatientNestedInput
    clinic?: ClinicUpdateOneRequiredWithoutPatientsNestedInput
    contentAdjustments?: PatientContentAdjustmentUpdateManyWithoutPatientNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    medicationLogs?: MedicationLogUpdateManyWithoutPatientNestedInput
    chatConversations?: ChatConversationUpdateManyWithoutPatientNestedInput
    exams?: ExamUpdateManyWithoutPatientNestedInput
    trainingProgress?: PatientTrainingProgressUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutSessionCompletionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surgeryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surgeryType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contentAdjustments?: PatientContentAdjustmentUncheckedUpdateManyWithoutPatientNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    medicationLogs?: MedicationLogUncheckedUpdateManyWithoutPatientNestedInput
    chatConversations?: ChatConversationUncheckedUpdateManyWithoutPatientNestedInput
    exams?: ExamUncheckedUpdateManyWithoutPatientNestedInput
    trainingProgress?: PatientTrainingProgressUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type TrainingSessionUpsertWithoutCompletionsInput = {
    update: XOR<TrainingSessionUpdateWithoutCompletionsInput, TrainingSessionUncheckedUpdateWithoutCompletionsInput>
    create: XOR<TrainingSessionCreateWithoutCompletionsInput, TrainingSessionUncheckedCreateWithoutCompletionsInput>
    where?: TrainingSessionWhereInput
  }

  export type TrainingSessionUpdateToOneWithWhereWithoutCompletionsInput = {
    where?: TrainingSessionWhereInput
    data: XOR<TrainingSessionUpdateWithoutCompletionsInput, TrainingSessionUncheckedUpdateWithoutCompletionsInput>
  }

  export type TrainingSessionUpdateWithoutCompletionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionNumber?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    intensity?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    week?: TrainingWeekUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type TrainingSessionUncheckedUpdateWithoutCompletionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekId?: StringFieldUpdateOperationsInput | string
    sessionNumber?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    intensity?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientCreateWithoutChatConversationsInput = {
    id?: string
    cpf?: string | null
    phone?: string | null
    birthDate?: Date | string | null
    surgeryDate?: Date | string | null
    surgeryType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutPatientInput
    clinic: ClinicCreateNestedOneWithoutPatientsInput
    contentAdjustments?: PatientContentAdjustmentCreateNestedManyWithoutPatientInput
    appointments?: AppointmentCreateNestedManyWithoutPatientInput
    medicationLogs?: MedicationLogCreateNestedManyWithoutPatientInput
    exams?: ExamCreateNestedManyWithoutPatientInput
    trainingProgress?: PatientTrainingProgressCreateNestedManyWithoutPatientInput
    sessionCompletions?: PatientSessionCompletionCreateNestedManyWithoutPatientInput
  }

  export type PatientUncheckedCreateWithoutChatConversationsInput = {
    id?: string
    userId: string
    clinicId: string
    cpf?: string | null
    phone?: string | null
    birthDate?: Date | string | null
    surgeryDate?: Date | string | null
    surgeryType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    contentAdjustments?: PatientContentAdjustmentUncheckedCreateNestedManyWithoutPatientInput
    appointments?: AppointmentUncheckedCreateNestedManyWithoutPatientInput
    medicationLogs?: MedicationLogUncheckedCreateNestedManyWithoutPatientInput
    exams?: ExamUncheckedCreateNestedManyWithoutPatientInput
    trainingProgress?: PatientTrainingProgressUncheckedCreateNestedManyWithoutPatientInput
    sessionCompletions?: PatientSessionCompletionUncheckedCreateNestedManyWithoutPatientInput
  }

  export type PatientCreateOrConnectWithoutChatConversationsInput = {
    where: PatientWhereUniqueInput
    create: XOR<PatientCreateWithoutChatConversationsInput, PatientUncheckedCreateWithoutChatConversationsInput>
  }

  export type ChatMessageCreateWithoutConversationInput = {
    id?: string
    role: string
    content: string
    createdAt?: Date | string
  }

  export type ChatMessageUncheckedCreateWithoutConversationInput = {
    id?: string
    role: string
    content: string
    createdAt?: Date | string
  }

  export type ChatMessageCreateOrConnectWithoutConversationInput = {
    where: ChatMessageWhereUniqueInput
    create: XOR<ChatMessageCreateWithoutConversationInput, ChatMessageUncheckedCreateWithoutConversationInput>
  }

  export type ChatMessageCreateManyConversationInputEnvelope = {
    data: ChatMessageCreateManyConversationInput | ChatMessageCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type PatientUpsertWithoutChatConversationsInput = {
    update: XOR<PatientUpdateWithoutChatConversationsInput, PatientUncheckedUpdateWithoutChatConversationsInput>
    create: XOR<PatientCreateWithoutChatConversationsInput, PatientUncheckedCreateWithoutChatConversationsInput>
    where?: PatientWhereInput
  }

  export type PatientUpdateToOneWithWhereWithoutChatConversationsInput = {
    where?: PatientWhereInput
    data: XOR<PatientUpdateWithoutChatConversationsInput, PatientUncheckedUpdateWithoutChatConversationsInput>
  }

  export type PatientUpdateWithoutChatConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surgeryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surgeryType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPatientNestedInput
    clinic?: ClinicUpdateOneRequiredWithoutPatientsNestedInput
    contentAdjustments?: PatientContentAdjustmentUpdateManyWithoutPatientNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    medicationLogs?: MedicationLogUpdateManyWithoutPatientNestedInput
    exams?: ExamUpdateManyWithoutPatientNestedInput
    trainingProgress?: PatientTrainingProgressUpdateManyWithoutPatientNestedInput
    sessionCompletions?: PatientSessionCompletionUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutChatConversationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    clinicId?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surgeryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surgeryType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contentAdjustments?: PatientContentAdjustmentUncheckedUpdateManyWithoutPatientNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    medicationLogs?: MedicationLogUncheckedUpdateManyWithoutPatientNestedInput
    exams?: ExamUncheckedUpdateManyWithoutPatientNestedInput
    trainingProgress?: PatientTrainingProgressUncheckedUpdateManyWithoutPatientNestedInput
    sessionCompletions?: PatientSessionCompletionUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type ChatMessageUpsertWithWhereUniqueWithoutConversationInput = {
    where: ChatMessageWhereUniqueInput
    update: XOR<ChatMessageUpdateWithoutConversationInput, ChatMessageUncheckedUpdateWithoutConversationInput>
    create: XOR<ChatMessageCreateWithoutConversationInput, ChatMessageUncheckedCreateWithoutConversationInput>
  }

  export type ChatMessageUpdateWithWhereUniqueWithoutConversationInput = {
    where: ChatMessageWhereUniqueInput
    data: XOR<ChatMessageUpdateWithoutConversationInput, ChatMessageUncheckedUpdateWithoutConversationInput>
  }

  export type ChatMessageUpdateManyWithWhereWithoutConversationInput = {
    where: ChatMessageScalarWhereInput
    data: XOR<ChatMessageUpdateManyMutationInput, ChatMessageUncheckedUpdateManyWithoutConversationInput>
  }

  export type ChatMessageScalarWhereInput = {
    AND?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
    OR?: ChatMessageScalarWhereInput[]
    NOT?: ChatMessageScalarWhereInput | ChatMessageScalarWhereInput[]
    id?: StringFilter<"ChatMessage"> | string
    conversationId?: StringFilter<"ChatMessage"> | string
    role?: StringFilter<"ChatMessage"> | string
    content?: StringFilter<"ChatMessage"> | string
    createdAt?: DateTimeFilter<"ChatMessage"> | Date | string
  }

  export type ChatConversationCreateWithoutMessagesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    patient: PatientCreateNestedOneWithoutChatConversationsInput
  }

  export type ChatConversationUncheckedCreateWithoutMessagesInput = {
    id?: string
    patientId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChatConversationCreateOrConnectWithoutMessagesInput = {
    where: ChatConversationWhereUniqueInput
    create: XOR<ChatConversationCreateWithoutMessagesInput, ChatConversationUncheckedCreateWithoutMessagesInput>
  }

  export type ChatConversationUpsertWithoutMessagesInput = {
    update: XOR<ChatConversationUpdateWithoutMessagesInput, ChatConversationUncheckedUpdateWithoutMessagesInput>
    create: XOR<ChatConversationCreateWithoutMessagesInput, ChatConversationUncheckedCreateWithoutMessagesInput>
    where?: ChatConversationWhereInput
  }

  export type ChatConversationUpdateToOneWithWhereWithoutMessagesInput = {
    where?: ChatConversationWhereInput
    data: XOR<ChatConversationUpdateWithoutMessagesInput, ChatConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type ChatConversationUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutChatConversationsNestedInput
  }

  export type ChatConversationUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetCreateManyUserInput = {
    id?: string
    code: string
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
  }

  export type PasswordResetUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyClinicInput = {
    id?: string
    email: string
    passwordHash: string
    name: string
    role?: $Enums.UserRole
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatientCreateManyClinicInput = {
    id?: string
    userId: string
    cpf?: string | null
    phone?: string | null
    birthDate?: Date | string | null
    surgeryDate?: Date | string | null
    surgeryType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClinicContentCreateManyClinicInput = {
    id?: string
    templateId?: string | null
    type: $Enums.ContentType
    category: $Enums.ContentCategory
    title: string
    description?: string | null
    validFromDay?: number | null
    validUntilDay?: number | null
    sortOrder?: number
    isActive?: boolean
    isCustom?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingProtocolCreateManyClinicInput = {
    id?: string
    name: string
    surgeryType?: string | null
    description?: string | null
    totalWeeks?: number
    isDefault?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneWithoutUserNestedInput
    passwordResets?: PasswordResetUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUncheckedUpdateOneWithoutUserNestedInput
    passwordResets?: PasswordResetUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateManyWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surgeryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surgeryType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutPatientNestedInput
    contentAdjustments?: PatientContentAdjustmentUpdateManyWithoutPatientNestedInput
    appointments?: AppointmentUpdateManyWithoutPatientNestedInput
    medicationLogs?: MedicationLogUpdateManyWithoutPatientNestedInput
    chatConversations?: ChatConversationUpdateManyWithoutPatientNestedInput
    exams?: ExamUpdateManyWithoutPatientNestedInput
    trainingProgress?: PatientTrainingProgressUpdateManyWithoutPatientNestedInput
    sessionCompletions?: PatientSessionCompletionUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surgeryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surgeryType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contentAdjustments?: PatientContentAdjustmentUncheckedUpdateManyWithoutPatientNestedInput
    appointments?: AppointmentUncheckedUpdateManyWithoutPatientNestedInput
    medicationLogs?: MedicationLogUncheckedUpdateManyWithoutPatientNestedInput
    chatConversations?: ChatConversationUncheckedUpdateManyWithoutPatientNestedInput
    exams?: ExamUncheckedUpdateManyWithoutPatientNestedInput
    trainingProgress?: PatientTrainingProgressUncheckedUpdateManyWithoutPatientNestedInput
    sessionCompletions?: PatientSessionCompletionUncheckedUpdateManyWithoutPatientNestedInput
  }

  export type PatientUncheckedUpdateManyWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    cpf?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surgeryDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    surgeryType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClinicContentUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    category?: EnumContentCategoryFieldUpdateOperationsInput | $Enums.ContentCategory
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    validFromDay?: NullableIntFieldUpdateOperationsInput | number | null
    validUntilDay?: NullableIntFieldUpdateOperationsInput | number | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isCustom?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patientAdjustments?: PatientContentAdjustmentUpdateManyWithoutBaseContentNestedInput
  }

  export type ClinicContentUncheckedUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    category?: EnumContentCategoryFieldUpdateOperationsInput | $Enums.ContentCategory
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    validFromDay?: NullableIntFieldUpdateOperationsInput | number | null
    validUntilDay?: NullableIntFieldUpdateOperationsInput | number | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isCustom?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patientAdjustments?: PatientContentAdjustmentUncheckedUpdateManyWithoutBaseContentNestedInput
  }

  export type ClinicContentUncheckedUpdateManyWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    templateId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    category?: EnumContentCategoryFieldUpdateOperationsInput | $Enums.ContentCategory
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    validFromDay?: NullableIntFieldUpdateOperationsInput | number | null
    validUntilDay?: NullableIntFieldUpdateOperationsInput | number | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isCustom?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingProtocolUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    surgeryType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalWeeks?: IntFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    weeks?: TrainingWeekUpdateManyWithoutProtocolNestedInput
  }

  export type TrainingProtocolUncheckedUpdateWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    surgeryType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalWeeks?: IntFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    weeks?: TrainingWeekUncheckedUpdateManyWithoutProtocolNestedInput
  }

  export type TrainingProtocolUncheckedUpdateManyWithoutClinicInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    surgeryType?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    totalWeeks?: IntFieldUpdateOperationsInput | number
    isDefault?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientContentAdjustmentCreateManyPatientInput = {
    id?: string
    baseContentId?: string | null
    adjustmentType: $Enums.AdjustmentType
    contentType?: $Enums.ContentType | null
    category?: $Enums.ContentCategory | null
    title?: string | null
    description?: string | null
    validFromDay?: number | null
    validUntilDay?: number | null
    reason?: string | null
    isActive?: boolean
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type AppointmentCreateManyPatientInput = {
    id?: string
    title: string
    description?: string | null
    date: Date | string
    time: string
    type: $Enums.AppointmentType
    status?: $Enums.AppointmentStatus
    location?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type MedicationLogCreateManyPatientInput = {
    id?: string
    contentId: string
    takenAt?: Date | string
    scheduledTime: string
    createdAt?: Date | string
  }

  export type ChatConversationCreateManyPatientInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ExamCreateManyPatientInput = {
    id?: string
    title: string
    type: string
    date: Date | string
    status?: $Enums.ExamStatus
    fileUrl?: string | null
    fileName?: string | null
    fileSize?: number | null
    mimeType?: string | null
    notes?: string | null
    result?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatientTrainingProgressCreateManyPatientInput = {
    id?: string
    weekId: string
    status?: $Enums.TrainingWeekStatus
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatientSessionCompletionCreateManyPatientInput = {
    id?: string
    sessionId: string
    completedAt?: Date | string
    notes?: string | null
  }

  export type PatientContentAdjustmentUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    adjustmentType?: EnumAdjustmentTypeFieldUpdateOperationsInput | $Enums.AdjustmentType
    contentType?: NullableEnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType | null
    category?: NullableEnumContentCategoryFieldUpdateOperationsInput | $Enums.ContentCategory | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    validFromDay?: NullableIntFieldUpdateOperationsInput | number | null
    validUntilDay?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    baseContent?: ClinicContentUpdateOneWithoutPatientAdjustmentsNestedInput
  }

  export type PatientContentAdjustmentUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    baseContentId?: NullableStringFieldUpdateOperationsInput | string | null
    adjustmentType?: EnumAdjustmentTypeFieldUpdateOperationsInput | $Enums.AdjustmentType
    contentType?: NullableEnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType | null
    category?: NullableEnumContentCategoryFieldUpdateOperationsInput | $Enums.ContentCategory | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    validFromDay?: NullableIntFieldUpdateOperationsInput | number | null
    validUntilDay?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientContentAdjustmentUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    baseContentId?: NullableStringFieldUpdateOperationsInput | string | null
    adjustmentType?: EnumAdjustmentTypeFieldUpdateOperationsInput | $Enums.AdjustmentType
    contentType?: NullableEnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType | null
    category?: NullableEnumContentCategoryFieldUpdateOperationsInput | $Enums.ContentCategory | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    validFromDay?: NullableIntFieldUpdateOperationsInput | number | null
    validUntilDay?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    type?: EnumAppointmentTypeFieldUpdateOperationsInput | $Enums.AppointmentType
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    type?: EnumAppointmentTypeFieldUpdateOperationsInput | $Enums.AppointmentType
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppointmentUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    time?: StringFieldUpdateOperationsInput | string
    type?: EnumAppointmentTypeFieldUpdateOperationsInput | $Enums.AppointmentType
    status?: EnumAppointmentStatusFieldUpdateOperationsInput | $Enums.AppointmentStatus
    location?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicationLogUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    takenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicationLogUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    takenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MedicationLogUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    contentId?: StringFieldUpdateOperationsInput | string
    takenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduledTime?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatConversationUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: ChatMessageUpdateManyWithoutConversationNestedInput
  }

  export type ChatConversationUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: ChatMessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ChatConversationUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumExamStatusFieldUpdateOperationsInput | $Enums.ExamStatus
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumExamStatusFieldUpdateOperationsInput | $Enums.ExamStatus
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ExamUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumExamStatusFieldUpdateOperationsInput | $Enums.ExamStatus
    fileUrl?: NullableStringFieldUpdateOperationsInput | string | null
    fileName?: NullableStringFieldUpdateOperationsInput | string | null
    fileSize?: NullableIntFieldUpdateOperationsInput | number | null
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    result?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientTrainingProgressUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTrainingWeekStatusFieldUpdateOperationsInput | $Enums.TrainingWeekStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    week?: TrainingWeekUpdateOneRequiredWithoutProgressNestedInput
  }

  export type PatientTrainingProgressUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekId?: StringFieldUpdateOperationsInput | string
    status?: EnumTrainingWeekStatusFieldUpdateOperationsInput | $Enums.TrainingWeekStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientTrainingProgressUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekId?: StringFieldUpdateOperationsInput | string
    status?: EnumTrainingWeekStatusFieldUpdateOperationsInput | $Enums.TrainingWeekStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientSessionCompletionUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    session?: TrainingSessionUpdateOneRequiredWithoutCompletionsNestedInput
  }

  export type PatientSessionCompletionUncheckedUpdateWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PatientSessionCompletionUncheckedUpdateManyWithoutPatientInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionId?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PatientContentAdjustmentCreateManyBaseContentInput = {
    id?: string
    patientId: string
    adjustmentType: $Enums.AdjustmentType
    contentType?: $Enums.ContentType | null
    category?: $Enums.ContentCategory | null
    title?: string | null
    description?: string | null
    validFromDay?: number | null
    validUntilDay?: number | null
    reason?: string | null
    isActive?: boolean
    createdBy?: string | null
    createdAt?: Date | string
  }

  export type PatientContentAdjustmentUpdateWithoutBaseContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    adjustmentType?: EnumAdjustmentTypeFieldUpdateOperationsInput | $Enums.AdjustmentType
    contentType?: NullableEnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType | null
    category?: NullableEnumContentCategoryFieldUpdateOperationsInput | $Enums.ContentCategory | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    validFromDay?: NullableIntFieldUpdateOperationsInput | number | null
    validUntilDay?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutContentAdjustmentsNestedInput
  }

  export type PatientContentAdjustmentUncheckedUpdateWithoutBaseContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    adjustmentType?: EnumAdjustmentTypeFieldUpdateOperationsInput | $Enums.AdjustmentType
    contentType?: NullableEnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType | null
    category?: NullableEnumContentCategoryFieldUpdateOperationsInput | $Enums.ContentCategory | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    validFromDay?: NullableIntFieldUpdateOperationsInput | number | null
    validUntilDay?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientContentAdjustmentUncheckedUpdateManyWithoutBaseContentInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    adjustmentType?: EnumAdjustmentTypeFieldUpdateOperationsInput | $Enums.AdjustmentType
    contentType?: NullableEnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType | null
    category?: NullableEnumContentCategoryFieldUpdateOperationsInput | $Enums.ContentCategory | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    validFromDay?: NullableIntFieldUpdateOperationsInput | number | null
    validUntilDay?: NullableIntFieldUpdateOperationsInput | number | null
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingWeekCreateManyProtocolInput = {
    id?: string
    weekNumber: number
    title: string
    dayRange: string
    objective: string
    maxHeartRate?: number | null
    heartRateLabel?: string | null
    canDo?: TrainingWeekCreatecanDoInput | string[]
    avoid?: TrainingWeekCreateavoidInput | string[]
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingWeekUpdateWithoutProtocolInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    dayRange?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    maxHeartRate?: NullableIntFieldUpdateOperationsInput | number | null
    heartRateLabel?: NullableStringFieldUpdateOperationsInput | string | null
    canDo?: TrainingWeekUpdatecanDoInput | string[]
    avoid?: TrainingWeekUpdateavoidInput | string[]
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: TrainingSessionUpdateManyWithoutWeekNestedInput
    progress?: PatientTrainingProgressUpdateManyWithoutWeekNestedInput
  }

  export type TrainingWeekUncheckedUpdateWithoutProtocolInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    dayRange?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    maxHeartRate?: NullableIntFieldUpdateOperationsInput | number | null
    heartRateLabel?: NullableStringFieldUpdateOperationsInput | string | null
    canDo?: TrainingWeekUpdatecanDoInput | string[]
    avoid?: TrainingWeekUpdateavoidInput | string[]
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sessions?: TrainingSessionUncheckedUpdateManyWithoutWeekNestedInput
    progress?: PatientTrainingProgressUncheckedUpdateManyWithoutWeekNestedInput
  }

  export type TrainingWeekUncheckedUpdateManyWithoutProtocolInput = {
    id?: StringFieldUpdateOperationsInput | string
    weekNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    dayRange?: StringFieldUpdateOperationsInput | string
    objective?: StringFieldUpdateOperationsInput | string
    maxHeartRate?: NullableIntFieldUpdateOperationsInput | number | null
    heartRateLabel?: NullableStringFieldUpdateOperationsInput | string | null
    canDo?: TrainingWeekUpdatecanDoInput | string[]
    avoid?: TrainingWeekUpdateavoidInput | string[]
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TrainingSessionCreateManyWeekInput = {
    id?: string
    sessionNumber: number
    name: string
    description?: string | null
    duration?: number | null
    intensity?: string | null
    sortOrder?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PatientTrainingProgressCreateManyWeekInput = {
    id?: string
    patientId: string
    status?: $Enums.TrainingWeekStatus
    startedAt?: Date | string | null
    completedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TrainingSessionUpdateWithoutWeekInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionNumber?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    intensity?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completions?: PatientSessionCompletionUpdateManyWithoutSessionNestedInput
  }

  export type TrainingSessionUncheckedUpdateWithoutWeekInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionNumber?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    intensity?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completions?: PatientSessionCompletionUncheckedUpdateManyWithoutSessionNestedInput
  }

  export type TrainingSessionUncheckedUpdateManyWithoutWeekInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionNumber?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableIntFieldUpdateOperationsInput | number | null
    intensity?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientTrainingProgressUpdateWithoutWeekInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumTrainingWeekStatusFieldUpdateOperationsInput | $Enums.TrainingWeekStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    patient?: PatientUpdateOneRequiredWithoutTrainingProgressNestedInput
  }

  export type PatientTrainingProgressUncheckedUpdateWithoutWeekInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    status?: EnumTrainingWeekStatusFieldUpdateOperationsInput | $Enums.TrainingWeekStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientTrainingProgressUncheckedUpdateManyWithoutWeekInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    status?: EnumTrainingWeekStatusFieldUpdateOperationsInput | $Enums.TrainingWeekStatus
    startedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PatientSessionCompletionCreateManySessionInput = {
    id?: string
    patientId: string
    completedAt?: Date | string
    notes?: string | null
  }

  export type PatientSessionCompletionUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    patient?: PatientUpdateOneRequiredWithoutSessionCompletionsNestedInput
  }

  export type PatientSessionCompletionUncheckedUpdateWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PatientSessionCompletionUncheckedUpdateManyWithoutSessionInput = {
    id?: StringFieldUpdateOperationsInput | string
    patientId?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ChatMessageCreateManyConversationInput = {
    id?: string
    role: string
    content: string
    createdAt?: Date | string
  }

  export type ChatMessageUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChatMessageUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClinicCountOutputTypeDefaultArgs instead
     */
    export type ClinicCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClinicCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PatientCountOutputTypeDefaultArgs instead
     */
    export type PatientCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PatientCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClinicContentCountOutputTypeDefaultArgs instead
     */
    export type ClinicContentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClinicContentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TrainingProtocolCountOutputTypeDefaultArgs instead
     */
    export type TrainingProtocolCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TrainingProtocolCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TrainingWeekCountOutputTypeDefaultArgs instead
     */
    export type TrainingWeekCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TrainingWeekCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TrainingSessionCountOutputTypeDefaultArgs instead
     */
    export type TrainingSessionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TrainingSessionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChatConversationCountOutputTypeDefaultArgs instead
     */
    export type ChatConversationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChatConversationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PasswordResetDefaultArgs instead
     */
    export type PasswordResetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PasswordResetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClinicDefaultArgs instead
     */
    export type ClinicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClinicDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PatientDefaultArgs instead
     */
    export type PatientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PatientDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AppointmentDefaultArgs instead
     */
    export type AppointmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AppointmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use MedicationLogDefaultArgs instead
     */
    export type MedicationLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = MedicationLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExamDefaultArgs instead
     */
    export type ExamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExamDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SystemContentTemplateDefaultArgs instead
     */
    export type SystemContentTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SystemContentTemplateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ClinicContentDefaultArgs instead
     */
    export type ClinicContentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ClinicContentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PatientContentAdjustmentDefaultArgs instead
     */
    export type PatientContentAdjustmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PatientContentAdjustmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TrainingProtocolDefaultArgs instead
     */
    export type TrainingProtocolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TrainingProtocolDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TrainingWeekDefaultArgs instead
     */
    export type TrainingWeekArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TrainingWeekDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TrainingSessionDefaultArgs instead
     */
    export type TrainingSessionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TrainingSessionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PatientTrainingProgressDefaultArgs instead
     */
    export type PatientTrainingProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PatientTrainingProgressDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PatientSessionCompletionDefaultArgs instead
     */
    export type PatientSessionCompletionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PatientSessionCompletionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChatConversationDefaultArgs instead
     */
    export type ChatConversationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChatConversationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChatMessageDefaultArgs instead
     */
    export type ChatMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChatMessageDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}